===== lib/bootstrap.dart =====
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';

import 'app.dart';
import 'config/env.dart';
import 'config/logger.dart';
import 'data/local/hive/boxes.dart';
import 'data/local/drift/db.dart';
import 'services/notifications/fcm_service.dart';

Future<void> bootstrap() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Set preferred orientations
  await SystemChrome.setPreferredOrientations([
    DeviceOrientation.portraitUp,
    DeviceOrientation.portraitDown,
  ]);

  // Initialize Hive
  await Hive.initFlutter();
  await HiveBoxes.init();

  // Initialize Supabase
  await Supabase.initialize(
    url: Env.supabaseUrl,
    anonKey: Env.supabaseAnonKey,
  );

  // Initialize Database
  await DatabaseHelper.instance.database;

  // Initialize Firebase Messaging
  await FirebaseMessaging.instance.requestPermission();
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

  // Initialize Local Notifications
  const AndroidInitializationSettings initializationSettingsAndroid =
      AndroidInitializationSettings('@mipmap/ic_launcher');
  const DarwinInitializationSettings initializationSettingsIOS =
      DarwinInitializationSettings();
  const InitializationSettings initializationSettings = InitializationSettings(
    android: initializationSettingsAndroid,
    iOS: initializationSettingsIOS,
  );

  await FlutterLocalNotificationsPlugin().initialize(initializationSettings);

  // Handle errors
  FlutterError.onError = (details) {
    logger.e('Flutter Error',
        error: details.exception, stackTrace: details.stack);
  };

  PlatformDispatcher.instance.onError = (error, stack) {
    logger.e('Platform Error', error: error, stackTrace: stack);
    return true;
  };

  runApp(const ArsenalSellApp());
}

@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Supabase.initialize(
    url: Env.supabaseUrl,
    anonKey: Env.supabaseAnonKey,
  );
  await FCMService.handleBackgroundMessage(message);
}


===== lib/core/utils/date_time.dart =====
import 'package:intl/intl.dart';

class DateTimeUtils {
  // Common date formats
  static const String defaultDateFormat = 'dd/MM/yyyy';
  static const String defaultTimeFormat = 'HH:mm';
  static const String defaultDateTimeFormat = 'dd/MM/yyyy HH:mm';
  static const String apiDateTimeFormat = 'yyyy-MM-ddTHH:mm:ss.SSSZ';
  static const String displayDateFormat = 'EEEE, dd MMMM yyyy';
  static const String shortDateFormat = 'dd/MM';
  static const String monthYearFormat = 'MMMM yyyy';

  // Spanish locale formatters
  static final DateFormat _dateFormatter =
      DateFormat(defaultDateFormat, 'es_ES');
  static final DateFormat _timeFormatter =
      DateFormat(defaultTimeFormat, 'es_ES');
  static final DateFormat _dateTimeFormatter =
      DateFormat(defaultDateTimeFormat, 'es_ES');
  static final DateFormat _displayDateFormatter =
      DateFormat(displayDateFormat, 'es_ES');
  static final DateFormat _shortDateFormatter =
      DateFormat(shortDateFormat, 'es_ES');
  static final DateFormat _monthYearFormatter =
      DateFormat(monthYearFormat, 'es_ES');

  /// Format date to default format (dd/MM/yyyy)
  static String formatDate(DateTime? dateTime) {
    if (dateTime == null) return '';
    return _dateFormatter.format(dateTime);
  }

  /// Format time to default format (HH:mm)
  static String formatTime(DateTime? dateTime) {
    if (dateTime == null) return '';
    return _timeFormatter.format(dateTime);
  }

  /// Format date and time to default format (dd/MM/yyyy HH:mm)
  static String formatDateTime(DateTime? dateTime) {
    if (dateTime == null) return '';
    return _dateTimeFormatter.format(dateTime);
  }

  /// Format date for display (Lunes, 15 enero 2024)
  static String formatDisplayDate(DateTime? dateTime) {
    if (dateTime == null) return '';
    return _displayDateFormatter.format(dateTime);
  }

  /// Format short date (15/01)
  static String formatShortDate(DateTime? dateTime) {
    if (dateTime == null) return '';
    return _shortDateFormatter.format(dateTime);
  }

  /// Format month and year (enero 2024)
  static String formatMonthYear(DateTime? dateTime) {
    if (dateTime == null) return '';
    return _monthYearFormatter.format(dateTime);
  }

  /// Format custom date pattern
  static String formatCustom(DateTime? dateTime, String pattern) {
    if (dateTime == null) return '';
    return DateFormat(pattern, 'es_ES').format(dateTime);
  }

  /// Get relative time (hace 2 horas, ayer, etc.)
  static String getRelativeTime(DateTime? dateTime) {
    if (dateTime == null) return '';

    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inDays > 0) {
      if (difference.inDays == 1) {
        return 'Ayer';
      } else if (difference.inDays < 7) {
        return 'Hace ${difference.inDays} días';
      } else if (difference.inDays < 30) {
        final weeks = (difference.inDays / 7).floor();
        return weeks == 1 ? 'Hace 1 semana' : 'Hace $weeks semanas';
      } else if (difference.inDays < 365) {
        final months = (difference.inDays / 30).floor();
        return months == 1 ? 'Hace 1 mes' : 'Hace $months meses';
      } else {
        final years = (difference.inDays / 365).floor();
        return years == 1 ? 'Hace 1 año' : 'Hace $years años';
      }
    } else if (difference.inHours > 0) {
      return difference.inHours == 1
          ? 'Hace 1 hora'
          : 'Hace ${difference.inHours} horas';
    } else if (difference.inMinutes > 0) {
      return difference.inMinutes == 1
          ? 'Hace 1 minuto'
          : 'Hace ${difference.inMinutes} minutos';
    } else {
      return 'Ahora mismo';
    }
  }

  /// Get time of day greeting
  static String getTimeGreeting() {
    final hour = DateTime.now().hour;
    if (hour < 12) {
      return 'Buenos días';
    } else if (hour < 18) {
      return 'Buenas tardes';
    } else {
      return 'Buenas noches';
    }
  }

  /// Check if date is today
  static bool isToday(DateTime? dateTime) {
    if (dateTime == null) return false;
    final now = DateTime.now();
    return dateTime.year == now.year &&
        dateTime.month == now.month &&
        dateTime.day == now.day;
  }

  /// Check if date is yesterday
  static bool isYesterday(DateTime? dateTime) {
    if (dateTime == null) return false;
    final yesterday = DateTime.now().subtract(const Duration(days: 1));
    return dateTime.year == yesterday.year &&
        dateTime.month == yesterday.month &&
        dateTime.day == yesterday.day;
  }

  /// Check if date is this week
  static bool isThisWeek(DateTime? dateTime) {
    if (dateTime == null) return false;
    final now = DateTime.now();
    final startOfWeek = now.subtract(Duration(days: now.weekday - 1));
    final endOfWeek = startOfWeek.add(const Duration(days: 6));

    return dateTime.isAfter(startOfWeek.subtract(const Duration(days: 1))) &&
        dateTime.isBefore(endOfWeek.add(const Duration(days: 1)));
  }

  /// Get start of day (00:00:00)
  static DateTime startOfDay(DateTime dateTime) {
    return DateTime(dateTime.year, dateTime.month, dateTime.day);
  }

  /// Get end of day (23:59:59)
  static DateTime endOfDay(DateTime dateTime) {
    return DateTime(dateTime.year, dateTime.month, dateTime.day, 23, 59, 59);
  }

  /// Get start of week (Monday)
  static DateTime startOfWeek(DateTime dateTime) {
    final daysToSubtract = dateTime.weekday - 1;
    return startOfDay(dateTime.subtract(Duration(days: daysToSubtract)));
  }

  /// Get end of week (Sunday)
  static DateTime endOfWeek(DateTime dateTime) {
    final daysToAdd = 7 - dateTime.weekday;
    return endOfDay(dateTime.add(Duration(days: daysToAdd)));
  }

  /// Get start of month
  static DateTime startOfMonth(DateTime dateTime) {
    return DateTime(dateTime.year, dateTime.month, 1);
  }

  /// Get end of month
  static DateTime endOfMonth(DateTime dateTime) {
    return DateTime(dateTime.year, dateTime.month + 1, 0, 23, 59, 59);
  }

  /// Parse date string with multiple formats
  static DateTime? parseDate(String? dateString) {
    if (dateString == null || dateString.isEmpty) return null;

    final formats = [
      defaultDateTimeFormat,
      defaultDateFormat,
      apiDateTimeFormat,
      'yyyy-MM-dd',
      'dd-MM-yyyy',
      'yyyy/MM/dd',
      'MM/dd/yyyy',
    ];

    for (final format in formats) {
      try {
        return DateFormat(format).parse(dateString);
      } catch (e) {
        continue;
      }
    }

    return null;
  }

  /// Calculate age from birth date
  static int calculateAge(DateTime birthDate) {
    final now = DateTime.now();
    int age = now.year - birthDate.year;

    if (now.month < birthDate.month ||
        (now.month == birthDate.month && now.day < birthDate.day)) {
      age--;
    }

    return age;
  }

  /// Calculate duration between two dates
  static String formatDuration(Duration duration) {
    if (duration.inDays > 0) {
      return '${duration.inDays}d ${duration.inHours % 24}h';
    } else if (duration.inHours > 0) {
      return '${duration.inHours}h ${duration.inMinutes % 60}m';
    } else if (duration.inMinutes > 0) {
      return '${duration.inMinutes}m';
    } else {
      return '${duration.inSeconds}s';
    }
  }

  /// Get business days between two dates
  static int getBusinessDays(DateTime startDate, DateTime endDate) {
    int businessDays = 0;
    DateTime current = startDate;

    while (current.isBefore(endDate) || current.isAtSameMomentAs(endDate)) {
      if (current.weekday != DateTime.saturday &&
          current.weekday != DateTime.sunday) {
        businessDays++;
      }
      current = current.add(const Duration(days: 1));
    }

    return businessDays;
  }

  /// Check if it's business hours
  static bool isBusinessHours({
    DateTime? dateTime,
    int startHour = 8,
    int endHour = 18,
  }) {
    final checkTime = dateTime ?? DateTime.now();

    // Check if it's weekend
    if (checkTime.weekday == DateTime.saturday ||
        checkTime.weekday == DateTime.sunday) {
      return false;
    }

    // Check if it's within business hours
    return checkTime.hour >= startHour && checkTime.hour < endHour;
  }

  /// Get next business day
  static DateTime getNextBusinessDay([DateTime? from]) {
    DateTime nextDay = (from ?? DateTime.now()).add(const Duration(days: 1));

    while (nextDay.weekday == DateTime.saturday ||
        nextDay.weekday == DateTime.sunday) {
      nextDay = nextDay.add(const Duration(days: 1));
    }

    return nextDay;
  }

  /// Format time spent (for visit duration, etc.)
  static String formatTimeSpent(DateTime? startTime, DateTime? endTime) {
    if (startTime == null) return 'No iniciado';
    if (endTime == null) return 'En progreso';

    final duration = endTime.difference(startTime);
    return formatDuration(duration);
  }

  /// Get week number of year
  static int getWeekOfYear(DateTime dateTime) {
    final startOfYear = DateTime(dateTime.year, 1, 1);
    final days = dateTime.difference(startOfYear).inDays;
    return ((days + startOfYear.weekday) / 7).ceil();
  }

  /// Check if date is in the future
  static bool isFuture(DateTime? dateTime) {
    if (dateTime == null) return false;
    return dateTime.isAfter(DateTime.now());
  }

  /// Check if date is in the past
  static bool isPast(DateTime? dateTime) {
    if (dateTime == null) return false;
    return dateTime.isBefore(DateTime.now());
  }

  /// Get local timezone offset
  static String getTimezoneOffset() {
    final offset = DateTime.now().timeZoneOffset;
    final hours = offset.inHours;
    final minutes = offset.inMinutes % 60;
    final sign = hours >= 0 ? '+' : '-';
    return '$sign${hours.abs().toString().padLeft(2, '0')}:${minutes.abs().toString().padLeft(2, '0')}';
  }
}


===== lib/core/utils/validators.dart =====
class Validators {
  // Email validation
  static String? validateEmail(String? value) {
    if (value == null || value.isEmpty) {
      return 'Email es requerido';
    }

    final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
    if (!emailRegex.hasMatch(value)) {
      return 'Formato de email inválido';
    }

    return null;
  }

  // Phone validation
  static String? validatePhone(String? value) {
    if (value == null || value.isEmpty) {
      return null; // Phone is usually optional
    }

    // Remove all non-digit characters
    final digitsOnly = value.replaceAll(RegExp(r'[^\d]'), '');

    if (digitsOnly.length < 10) {
      return 'Teléfono debe tener al menos 10 dígitos';
    }

    if (digitsOnly.length > 15) {
      return 'Teléfono no puede tener más de 15 dígitos';
    }

    return null;
  }

  // Required field validation
  static String? validateRequired(String? value, [String? fieldName]) {
    if (value == null || value.trim().isEmpty) {
      return '${fieldName ?? 'Campo'} es requerido';
    }
    return null;
  }

  // Password validation
  static String? validatePassword(String? value) {
    if (value == null || value.isEmpty) {
      return 'Contraseña es requerida';
    }

    if (value.length < 6) {
      return 'Contraseña debe tener al menos 6 caracteres';
    }

    return null;
  }

  // Numeric validation
  static String? validateNumeric(String? value, [String? fieldName]) {
    if (value == null || value.isEmpty) {
      return '${fieldName ?? 'Campo'} es requerido';
    }

    if (double.tryParse(value) == null) {
      return '${fieldName ?? 'Campo'} debe ser un número válido';
    }

    return null;
  }

  // Positive number validation
  static String? validatePositiveNumber(String? value, [String? fieldName]) {
    final numericValidation = validateNumeric(value, fieldName);
    if (numericValidation != null) return numericValidation;

    final number = double.parse(value!);
    if (number <= 0) {
      return '${fieldName ?? 'Campo'} debe ser mayor que cero';
    }

    return null;
  }

  // Name validation
  static String? validateName(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'Nombre es requerido';
    }

    if (value.trim().length < 2) {
      return 'Nombre debe tener al menos 2 caracteres';
    }

    if (value.trim().length > 50) {
      return 'Nombre no puede tener más de 50 caracteres';
    }

    // Check for valid characters (letters, spaces, apostrophes, hyphens)
    final nameRegex = RegExp(r"^[a-zA-ZáéíóúÁÉÍÓÚñÑüÜ\s'-]+$");
    if (!nameRegex.hasMatch(value.trim())) {
      return 'Nombre contiene caracteres inválidos';
    }

    return null;
  }

  // Address validation
  static String? validateAddress(String? value) {
    if (value == null || value.trim().isEmpty) {
      return null; // Address is usually optional
    }

    if (value.trim().length < 10) {
      return 'Dirección debe tener al menos 10 caracteres';
    }

    if (value.trim().length > 200) {
      return 'Dirección no puede tener más de 200 caracteres';
    }

    return null;
  }

  // Coordinates validation
  static String? validateLatitude(double? value) {
    if (value == null) return 'Latitud es requerida';
    if (value < -90 || value > 90) {
      return 'Latitud debe estar entre -90 y 90 grados';
    }
    return null;
  }

  static String? validateLongitude(double? value) {
    if (value == null) return 'Longitud es requerida';
    if (value < -180 || value > 180) {
      return 'Longitud debe estar entre -180 y 180 grados';
    }
    return null;
  }

  // Code validation (customer code, product SKU, etc.)
  static String? validateCode(String? value, [String? fieldName]) {
    if (value == null || value.isEmpty) {
      return null; // Code is usually optional
    }

    if (value.length < 2) {
      return '${fieldName ?? 'Código'} debe tener al menos 2 caracteres';
    }

    if (value.length > 20) {
      return '${fieldName ?? 'Código'} no puede tener más de 20 caracteres';
    }

    // Allow alphanumeric and some special characters
    final codeRegex = RegExp(r'^[a-zA-Z0-9\-_]+$');
    if (!codeRegex.hasMatch(value)) {
      return '${fieldName ?? 'Código'} solo puede contener letras, números, guiones y guiones bajos';
    }

    return null;
  }

  // Quantity validation
  static String? validateQuantity(String? value) {
    return validatePositiveNumber(value, 'Cantidad');
  }

  // Price validation
  static String? validatePrice(String? value) {
    return validatePositiveNumber(value, 'Precio');
  }

  // Notes validation
  static String? validateNotes(String? value, {int maxLength = 500}) {
    if (value == null || value.isEmpty) {
      return null; // Notes are usually optional
    }

    if (value.length > maxLength) {
      return 'Notas no pueden tener más de $maxLength caracteres';
    }

    return null;
  }

  // Date validation
  static String? validateDate(DateTime? value, [String? fieldName]) {
    if (value == null) {
      return '${fieldName ?? 'Fecha'} es requerida';
    }

    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final valueDate = DateTime(value.year, value.month, value.day);

    if (valueDate.isBefore(today)) {
      return '${fieldName ?? 'Fecha'} no puede ser anterior a hoy';
    }

    return null;
  }

  // URL validation
  static String? validateUrl(String? value) {
    if (value == null || value.isEmpty) {
      return null; // URL is usually optional
    }

    final urlRegex = RegExp(
        r'^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$');

    if (!urlRegex.hasMatch(value)) {
      return 'Formato de URL inválido';
    }

    return null;
  }

  // Custom validation combiner
  static String? validateMultiple(
      String? value, List<String? Function(String?)> validators) {
    for (final validator in validators) {
      final result = validator(value);
      if (result != null) return result;
    }
    return null;
  }

  // File size validation
  static String? validateFileSize(int? fileSizeBytes, int maxSizeBytes) {
    if (fileSizeBytes == null) return 'Tamaño de archivo no disponible';

    if (fileSizeBytes > maxSizeBytes) {
      final maxSizeMB = (maxSizeBytes / (1024 * 1024)).toStringAsFixed(1);
      return 'Archivo debe ser menor a ${maxSizeMB}MB';
    }

    return null;
  }

  // Image file validation
  static String? validateImageFile(String? fileName) {
    if (fileName == null || fileName.isEmpty) {
      return 'Nombre de archivo requerido';
    }

    final allowedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];
    final extension = fileName.split('.').last.toLowerCase();

    if (!allowedExtensions.contains(extension)) {
      return 'Formato de imagen no válido. Use: ${allowedExtensions.join(', ')}';
    }

    return null;
  }

  // Geofence radius validation
  static String? validateGeofenceRadius(String? value) {
    final numericValidation = validatePositiveNumber(value, 'Radio');
    if (numericValidation != null) return numericValidation;

    final radius = double.parse(value!);
    if (radius < 5) {
      return 'Radio mínimo es 5 metros';
    }

    if (radius > 1000) {
      return 'Radio máximo es 1000 metros';
    }

    return null;
  }
}


===== lib/core/utils/geoutils.dart =====
import 'dart:math';
import 'package:geolocator/geolocator.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';

class GeoUtils {
  /// Calculate distance between two points in meters
  static double calculateDistance(
    double lat1,
    double lon1,
    double lat2,
    double lon2,
  ) {
    return Geolocator.distanceBetween(lat1, lon1, lat2, lon2);
  }

  /// Check if a point is within a geofence
  static bool isWithinGeofence(
    double currentLat,
    double currentLon,
    double centerLat,
    double centerLon,
    double radiusMeters,
  ) {
    final distance =
        calculateDistance(currentLat, currentLon, centerLat, centerLon);
    return distance <= radiusMeters;
  }

  /// Calculate bearing between two points
  static double calculateBearing(
    double lat1,
    double lon1,
    double lat2,
    double lon2,
  ) {
    final lat1Rad = _degreesToRadians(lat1);
    final lat2Rad = _degreesToRadians(lat2);
    final deltaLonRad = _degreesToRadians(lon2 - lon1);

    final y = sin(deltaLonRad) * cos(lat2Rad);
    final x = cos(lat1Rad) * sin(lat2Rad) -
        sin(lat1Rad) * cos(lat2Rad) * cos(deltaLonRad);

    final bearingRad = atan2(y, x);
    final bearingDeg = _radiansToDegrees(bearingRad);

    return (bearingDeg + 360) % 360;
  }

  /// Get center point of multiple coordinates
  static LatLng getCenterPoint(List<LatLng> coordinates) {
    if (coordinates.isEmpty) {
      throw ArgumentError('Coordinates list cannot be empty');
    }

    if (coordinates.length == 1) {
      return coordinates.first;
    }

    double x = 0, y = 0, z = 0;

    for (final coord in coordinates) {
      final latRad = _degreesToRadians(coord.latitude);
      final lonRad = _degreesToRadians(coord.longitude);

      x += cos(latRad) * cos(lonRad);
      y += cos(latRad) * sin(lonRad);
      z += sin(latRad);
    }

    final total = coordinates.length;
    x /= total;
    y /= total;
    z /= total;

    final centralLonRad = atan2(y, x);
    final centralSquareRoot = sqrt(x * x + y * y);
    final centralLatRad = atan2(z, centralSquareRoot);

    return LatLng(
      _radiansToDegrees(centralLatRad),
      _radiansToDegrees(centralLonRad),
    );
  }

  /// Get bounds that contain all coordinates
  static LatLngBounds getBounds(List<LatLng> coordinates) {
    if (coordinates.isEmpty) {
      throw ArgumentError('Coordinates list cannot be empty');
    }

    double minLat = coordinates.first.latitude;
    double maxLat = coordinates.first.latitude;
    double minLng = coordinates.first.longitude;
    double maxLng = coordinates.first.longitude;

    for (final coord in coordinates) {
      minLat = min(minLat, coord.latitude);
      maxLat = max(maxLat, coord.latitude);
      minLng = min(minLng, coord.longitude);
      maxLng = max(maxLng, coord.longitude);
    }

    return LatLngBounds(
      southwest: LatLng(minLat, minLng),
      northeast: LatLng(maxLat, maxLng),
    );
  }

  /// Calculate zoom level to fit bounds
  static double calculateZoomLevel(
      LatLngBounds bounds, double mapWidth, double mapHeight) {
    const double padding = 50.0;

    final double latRad = _degreesToRadians(
        bounds.northeast.latitude - bounds.southwest.latitude);
    final double lngRad = _degreesToRadians(
        bounds.northeast.longitude - bounds.southwest.longitude);

    final double latZoom =
        _calculateZoomFromDistance(latRad, mapHeight - padding);
    final double lngZoom =
        _calculateZoomFromDistance(lngRad, mapWidth - padding);

    return min(latZoom, lngZoom);
  }

  /// Format coordinates to string
  static String formatCoordinates(double lat, double lng, {int precision = 6}) {
    return '${lat.toStringAsFixed(precision)}, ${lng.toStringAsFixed(precision)}';
  }

  /// Parse coordinates from string
  static LatLng? parseCoordinates(String coordString) {
    try {
      final parts = coordString.split(',');
      if (parts.length != 2) return null;

      final lat = double.parse(parts[0].trim());
      final lng = double.parse(parts[1].trim());

      if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
        return LatLng(lat, lng);
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  /// Generate Google Maps URL
  static String generateGoogleMapsUrl(double lat, double lng, {String? label}) {
    final query = label != null ? '$lat,$lng($label)' : '$lat,$lng';
    return 'https://www.google.com/maps/search/?api=1&query=$query';
  }

  /// Generate route URL between two points
  static String generateRouteUrl(
    double fromLat,
    double fromLng,
    double toLat,
    double toLng,
  ) {
    return 'https://www.google.com/maps/dir/$fromLat,$fromLng/$toLat,$toLng';
  }

  /// Validate coordinates
  static bool isValidCoordinate(double? lat, double? lng) {
    if (lat == null || lng == null) return false;
    return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
  }

  /// Get accuracy level description
  static String getAccuracyDescription(double? accuracy) {
    if (accuracy == null) return 'Desconocida';
    if (accuracy <= 5) return 'Excelente';
    if (accuracy <= 10) return 'Buena';
    if (accuracy <= 20) return 'Regular';
    return 'Pobre';
  }

  /// Calculate estimated travel time (simple estimation)
  static Duration estimateTravelTime(double distanceMeters,
      {double speedKmh = 30}) {
    final distanceKm = distanceMeters / 1000;
    final timeHours = distanceKm / speedKmh;
    return Duration(milliseconds: (timeHours * 3600 * 1000).round());
  }

  /// Check if coordinates are significantly different
  static bool coordinatesChanged(
      double? oldLat, double? oldLng, double? newLat, double? newLng,
      {double thresholdMeters = 5.0}) {
    if (oldLat == null || oldLng == null || newLat == null || newLng == null) {
      return true;
    }

    final distance = calculateDistance(oldLat, oldLng, newLat, newLng);
    return distance >= thresholdMeters;
  }

  // Private helper methods
  static double _degreesToRadians(double degrees) {
    return degrees * pi / 180;
  }

  static double _radiansToDegrees(double radians) {
    return radians * 180 / pi;
  }

  static double _calculateZoomFromDistance(double distance, double dimension) {
    return log(dimension / distance) / ln2;
  }
}


===== lib/core/theme/palette.dart =====
import 'package:flutter/material.dart';

class AppPalette {
  // Primary colors
  static const Color primary = Color(0xFF1E88E5);
  static const Color primaryDark = Color(0xFF1565C0);
  static const Color primaryLight = Color(0xFF90CAF9);

  // Secondary colors
  static const Color secondary = Color(0xFF26A69A);
  static const Color secondaryDark = Color(0xFF00695C);
  static const Color secondaryLight = Color(0xFF80CBC4);

  // Status colors
  static const Color success = Color(0xFF4CAF50);
  static const Color warning = Color(0xFFFF9800);
  static const Color error = Color(0xFFE53935);
  static const Color info = Color(0xFF2196F3);

  // Neutral colors
  static const Color background = Color(0xFFF5F5F5);
  static const Color surface = Color(0xFFFFFFFF);
  static const Color surfaceVariant = Color(0xFFF3F3F3);

  // Text colors
  static const Color textPrimary = Color(0xFF212121);
  static const Color textSecondary = Color(0xFF757575);
  static const Color textDisabled = Color(0xFFBDBDBD);

  // Role colors
  static const Color vendedor = Color(0xFF2196F3);
  static const Color repartidor = Color(0xFF4CAF50);
  static const Color supervisor = Color(0xFFFF9800);
  static const Color admin = Color(0xFF9C27B0);
}


===== lib/core/theme/theme.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'palette.dart';

class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: AppPalette.primary,
        brightness: Brightness.light,
      ),
      appBarTheme: const AppBarTheme(
        elevation: 0,
        centerTitle: true,
        backgroundColor: AppPalette.primary,
        foregroundColor: Colors.white,
        systemOverlayStyle: SystemUiOverlayStyle.light,
      ),
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: AppPalette.secondary,
        foregroundColor: Colors.white,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppPalette.primary,
          foregroundColor: Colors.white,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      cardTheme: CardTheme(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        filled: true,
        fillColor: AppPalette.surface,
      ),
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: AppPalette.primary,
        brightness: Brightness.dark,
      ),
      appBarTheme: const AppBarTheme(
        elevation: 0,
        centerTitle: true,
        systemOverlayStyle: SystemUiOverlayStyle.light,
      ),
    );
  }
}


===== lib/core/errors/exceptions.dart =====
class AppException implements Exception {
  final String message;
  final String? code;
  final dynamic details;

  const AppException(this.message, {this.code, this.details});

  @override
  String toString() =>
      'AppException: $message${code != null ? ' (Code: $code)' : ''}';
}

class NetworkException extends AppException {
  const NetworkException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}

class ServerException extends AppException {
  const ServerException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}

class CacheException extends AppException {
  const CacheException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}

class AuthException extends AppException {
  const AuthException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}

class LocationException extends AppException {
  const LocationException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}

class GeofenceException extends AppException {
  const GeofenceException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}

class ValidationException extends AppException {
  const ValidationException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}

class SyncException extends AppException {
  const SyncException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}

class StorageException extends AppException {
  const StorageException(String message, {String? code, dynamic details})
      : super(message, code: code, details: details);
}


===== lib/core/errors/failures.dart =====
abstract class Failure {
  final String message;
  final String? code;

  const Failure(this.message, {this.code});

  @override
  String toString() =>
      'Failure: $message${code != null ? ' (Code: $code)' : ''}';
}

class NetworkFailure extends Failure {
  const NetworkFailure(String message, {String? code})
      : super(message, code: code);
}

class ServerFailure extends Failure {
  const ServerFailure(String message, {String? code})
      : super(message, code: code);
}

class CacheFailure extends Failure {
  const CacheFailure(String message, {String? code})
      : super(message, code: code);
}

class AuthFailure extends Failure {
  const AuthFailure(String message, {String? code})
      : super(message, code: code);
}

class LocationFailure extends Failure {
  const LocationFailure(String message, {String? code})
      : super(message, code: code);
}

class GeofenceFailure extends Failure {
  const GeofenceFailure(String message, {String? code})
      : super(message, code: code);
}

class ValidationFailure extends Failure {
  const ValidationFailure(String message, {String? code})
      : super(message, code: code);
}

class SyncFailure extends Failure {
  const SyncFailure(String message, {String? code})
      : super(message, code: code);
}

class StorageFailure extends Failure {
  const StorageFailure(String message, {String? code})
      : super(message, code: code);
}


===== lib/core/widgets/app_signature_pad.dart =====
import 'package:flutter/material.dart';
import 'package:signature/signature.dart';
import '../theme/palette.dart';

class AppSignaturePad extends StatefulWidget {
  final SignatureController controller;
  final String? title;
  final double height;

  const AppSignaturePad({
    super.key,
    required this.controller,
    this.title,
    this.height = 200,
  });

  @override
  State<AppSignaturePad> createState() => _AppSignaturePadState();
}

class _AppSignaturePadState extends State<AppSignaturePad> {
  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (widget.title != null) ...[
          Text(
            widget.title!,
            style: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 8),
        ],
        Container(
          height: widget.height,
          width: double.infinity,
          decoration: BoxDecoration(
            border: Border.all(color: Colors.grey),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Signature(
            controller: widget.controller,
            backgroundColor: Colors.white,
          ),
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: OutlinedButton.icon(
                onPressed: _clearSignature,
                icon: const Icon(Icons.clear),
                label: const Text('Limpiar'),
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: ElevatedButton.icon(
                onPressed: _exportSignature,
                icon: const Icon(Icons.save),
                label: const Text('Guardar'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: AppPalette.success,
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }

  void _clearSignature() {
    widget.controller.clear();
  }

  Future<void> _exportSignature() async {
    if (widget.controller.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Por favor, dibuja una firma antes de guardar'),
          backgroundColor: AppPalette.warning,
        ),
      );
      return;
    }

    try {
      final signature = await widget.controller.toPngBytes();
      if (signature != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Firma guardada exitosamente'),
            backgroundColor: AppPalette.success,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error al guardar firma: $e'),
          backgroundColor: AppPalette.error,
        ),
      );
    }
  }
}


===== lib/core/widgets/app_photo_viewer.dart =====
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:photo_view/photo_view.dart';
import 'package:photo_view/photo_view_gallery.dart';

class AppPhotoViewer extends StatelessWidget {
  final List<File> photos;
  final int initialIndex;

  const AppPhotoViewer({
    super.key,
    required this.photos,
    this.initialIndex = 0,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.black,
        foregroundColor: Colors.white,
        title: Text('${initialIndex + 1} de ${photos.length}'),
      ),
      body: Container(
        color: Colors.black,
        child: PhotoViewGallery.builder(
          itemCount: photos.length,
          builder: (context, index) {
            return PhotoViewGalleryPageOptions(
              imageProvider: FileImage(photos[index]),
              heroAttributes: PhotoViewHeroAttributes(tag: photos[index].path),
            );
          },
          scrollPhysics: const BouncingScrollPhysics(),
          backgroundDecoration: const BoxDecoration(color: Colors.black),
          pageController: PageController(initialPage: initialIndex),
        ),
      ),
    );
  }
}


===== lib/core/widgets/app_scaffold.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../theme/palette.dart';
import '../../features/auth/bloc/auth_cubit.dart';
import '../../data/models/auth/user_profile.dart';

class AppScaffold extends StatelessWidget {
  final Widget child;

  const AppScaffold({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<AuthCubit, AuthState>(
      builder: (context, state) {
        return state.maybeWhen(
          authenticated: (user) => Scaffold(
            body: child,
            bottomNavigationBar: _buildBottomNavigation(context, user),
            drawer: _buildDrawer(context, user),
          ),
          orElse: () => child,
        );
      },
    );
  }

  Widget _buildBottomNavigation(BuildContext context, UserProfile user) {
    final currentLocation = GoRouterState.of(context).matchedLocation;

    // Different navigation based on role
    switch (user.role) {
      case UserRole.vendedor:
        return _buildVendedorNavigation(context, currentLocation);
      case UserRole.repartidor:
        return _buildRepartidorNavigation(context, currentLocation);
      case UserRole.supervisor:
        return _buildSupervisorNavigation(context, currentLocation);
      case UserRole.admin:
        return _buildAdminNavigation(context, currentLocation);
    }
  }

  Widget _buildVendedorNavigation(
      BuildContext context, String currentLocation) {
    return BottomNavigationBar(
      type: BottomNavigationBarType.fixed,
      selectedItemColor: AppPalette.primary,
      unselectedItemColor: AppPalette.textSecondary,
      currentIndex: _getNavigationIndex(currentLocation, [
        '/dashboard',
        '/customers',
        '/orders',
        '/payments',
      ]),
      onTap: (index) => _navigateToIndex(context, index, [
        '/dashboard',
        '/customers',
        '/orders',
        '/payments',
      ]),
      items: const [
        BottomNavigationBarItem(
          icon: Icon(Icons.map),
          label: 'Mapa',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.people),
          label: 'Clientes',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.shopping_cart),
          label: 'Pedidos',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.payment),
          label: 'Cobros',
        ),
      ],
    );
  }

  Widget _buildRepartidorNavigation(
      BuildContext context, String currentLocation) {
    return BottomNavigationBar(
      type: BottomNavigationBarType.fixed,
      selectedItemColor: AppPalette.repartidor,
      unselectedItemColor: AppPalette.textSecondary,
      currentIndex: _getNavigationIndex(currentLocation, [
        '/dashboard',
        '/deliveries',
        '/customers',
      ]),
      onTap: (index) => _navigateToIndex(context, index, [
        '/dashboard',
        '/deliveries',
        '/customers',
      ]),
      items: const [
        BottomNavigationBarItem(
          icon: Icon(Icons.map),
          label: 'Ruta',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.local_shipping),
          label: 'Entregas',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.people),
          label: 'Clientes',
        ),
      ],
    );
  }

  Widget _buildSupervisorNavigation(
      BuildContext context, String currentLocation) {
    return BottomNavigationBar(
      type: BottomNavigationBarType.fixed,
      selectedItemColor: AppPalette.supervisor,
      unselectedItemColor: AppPalette.textSecondary,
      currentIndex: _getNavigationIndex(currentLocation, [
        '/supervisor',
        '/dashboard',
        '/customers',
        '/orders',
      ]),
      onTap: (index) => _navigateToIndex(context, index, [
        '/supervisor',
        '/dashboard',
        '/customers',
        '/orders',
      ]),
      items: const [
        BottomNavigationBarItem(
          icon: Icon(Icons.dashboard),
          label: 'Panel',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.map),
          label: 'Campo',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.people),
          label: 'Clientes',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.analytics),
          label: 'Reportes',
        ),
      ],
    );
  }

  Widget _buildAdminNavigation(BuildContext context, String currentLocation) {
    return BottomNavigationBar(
      type: BottomNavigationBarType.fixed,
      selectedItemColor: AppPalette.admin,
      unselectedItemColor: AppPalette.textSecondary,
      currentIndex: _getNavigationIndex(currentLocation, [
        '/dashboard',
        '/customers',
        '/supervisor',
      ]),
      onTap: (index) => _navigateToIndex(context, index, [
        '/dashboard',
        '/customers',
        '/supervisor',
      ]),
      items: const [
        BottomNavigationBarItem(
          icon: Icon(Icons.map),
          label: 'Mapa',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.people),
          label: 'Clientes',
        ),
        BottomNavigationBarItem(
          icon: Icon(Icons.admin_panel_settings),
          label: 'Admin',
        ),
      ],
    );
  }

  Widget _buildDrawer(BuildContext context, UserProfile user) {
    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: [
          DrawerHeader(
            decoration: const BoxDecoration(
              color: AppPalette.primary,
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                CircleAvatar(
                  radius: 30,
                  backgroundColor: Colors.white,
                  child: Text(
                    user.fullName?.isNotEmpty == true
                        ? user.fullName![0].toUpperCase()
                        : '?',
                    style: const TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                      color: AppPalette.primary,
                    ),
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  user.fullName ?? 'Usuario',
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Text(
                  _getRoleLabel(user.role),
                  style: const TextStyle(
                    color: Colors.white70,
                    fontSize: 14,
                  ),
                ),
              ],
            ),
          ),

          // Navigation items based on role
          ..._getDrawerItems(context, user.role),

          const Divider(),

          ListTile(
            leading: const Icon(Icons.settings),
            title: const Text('Configuración'),
            onTap: () {
              Navigator.pop(context);
              // TODO: Navigate to settings
            },
          ),
          ListTile(
            leading: const Icon(Icons.help),
            title: const Text('Ayuda'),
            onTap: () {
              Navigator.pop(context);
              // TODO: Navigate to help
            },
          ),
          ListTile(
            leading: const Icon(Icons.logout, color: AppPalette.error),
            title: const Text('Cerrar Sesión',
                style: TextStyle(color: AppPalette.error)),
            onTap: () => _signOut(context),
          ),
        ],
      ),
    );
  }

  List<Widget> _getDrawerItems(BuildContext context, UserRole role) {
    final commonItems = [
      ListTile(
        leading: const Icon(Icons.map),
        title: const Text('Mapa'),
        onTap: () {
          Navigator.pop(context);
          context.go('/dashboard');
        },
      ),
      ListTile(
        leading: const Icon(Icons.people),
        title: const Text('Clientes'),
        onTap: () {
          Navigator.pop(context);
          context.go('/customers');
        },
      ),
    ];

    final roleSpecificItems = <Widget>[];

    switch (role) {
      case UserRole.vendedor:
        roleSpecificItems.addAll([
          ListTile(
            leading: const Icon(Icons.shopping_cart),
            title: const Text('Pedidos'),
            onTap: () {
              Navigator.pop(context);
              // TODO: Navigate to orders
            },
          ),
          ListTile(
            leading: const Icon(Icons.payment),
            title: const Text('Cobros'),
            onTap: () {
              Navigator.pop(context);
              context.go('/payments');
            },
          ),
        ]);
        break;
      case UserRole.repartidor:
        roleSpecificItems.addAll([
          ListTile(
            leading: const Icon(Icons.local_shipping),
            title: const Text('Entregas'),
            onTap: () {
              Navigator.pop(context);
              context.go('/deliveries');
            },
          ),
        ]);
        break;
      case UserRole.supervisor:
      case UserRole.admin:
        roleSpecificItems.addAll([
          ListTile(
            leading: const Icon(Icons.dashboard),
            title: const Text('Panel de Control'),
            onTap: () {
              Navigator.pop(context);
              context.go('/supervisor');
            },
          ),
          ListTile(
            leading: const Icon(Icons.analytics),
            title: const Text('Reportes'),
            onTap: () {
              Navigator.pop(context);
              // TODO: Navigate to reports
            },
          ),
        ]);
        break;
    }

    return [...commonItems, ...roleSpecificItems];
  }

  static int _getNavigationIndex(String currentLocation, List<String> routes) {
    for (int i = 0; i < routes.length; i++) {
      if (currentLocation.startsWith(routes[i])) {
        return i;
      }
    }
    return 0;
  }

  static void _navigateToIndex(
      BuildContext context, int index, List<String> routes) {
    if (index < routes.length) {
      context.go(routes[index]);
    }
  }

  static String _getRoleLabel(UserRole role) {
    switch (role) {
      case UserRole.admin:
        return 'Administrador';
      case UserRole.supervisor:
        return 'Supervisor';
      case UserRole.vendedor:
        return 'Vendedor';
      case UserRole.repartidor:
        return 'Repartidor';
    }
  }

  static void _signOut(BuildContext context) {
    Navigator.pop(context);
    context.read<AuthCubit>().signOut();
  }
}


===== lib/core/widgets/app_loading.dart =====
import 'package:flutter/material.dart';
import '../theme/palette.dart';

class AppLoading extends StatelessWidget {
  final String? message;

  const AppLoading({super.key, this.message});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const CircularProgressIndicator(
            valueColor: AlwaysStoppedAnimation<Color>(AppPalette.primary),
          ),
          if (message != null) ...[
            const SizedBox(height: 16),
            Text(
              message!,
              style: const TextStyle(
                fontSize: 16,
                color: AppPalette.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ],
      ),
    );
  }
}


===== lib/config/app_constants.dart =====
class AppConstants {
  static const String appName = 'Arsenal Sell App';
  static const String version = '1.0.0';

  // Geofence
  static const double defaultGeofenceRadius = 10.0; // meters
  static const double maxGeofenceRadius = 100.0;

  // Location
  static const double locationAccuracyThreshold = 10.0; // meters
  static const int locationUpdateInterval = 30; // seconds
  static const int backgroundLocationInterval = 60; // seconds

  // Sync
  static const int syncBatchSize = 50;
  static const int maxRetryAttempts = 3;
  static const Duration syncInterval = Duration(minutes: 5);

  // UI
  static const double defaultPadding = 16.0;
  static const double defaultRadius = 8.0;

  // File Upload
  static const int maxPhotoSize = 5 * 1024 * 1024; // 5MB
  static const List<String> allowedImageTypes = ['jpg', 'jpeg', 'png'];
}


===== lib/config/logger.dart =====
import 'package:logger/logger.dart';

final logger = Logger(
  printer: PrettyPrinter(
    methodCount: 2,
    errorMethodCount: 8,
    lineLength: 120,
    colors: true,
    printEmojis: true,
    printTime: true,
  ),
);


===== lib/config/env.dart =====
class Env {
  static const String supabaseUrl = String.fromEnvironment(
    'SUPABASE_URL',
    defaultValue: 'YOUR_SUPABASE_URL',
  );

  static const String supabaseAnonKey = String.fromEnvironment(
    'SUPABASE_ANON_KEY',
    defaultValue: 'YOUR_SUPABASE_ANON_KEY',
  );

  static const String googleMapsApiKey =
      'AIzaSyA5X9eJe3Ih4Yfo4txSQzScZmVZpoO8mf8';

  static const String resendApiKey = String.fromEnvironment(
    'RESEND_API_KEY',
    defaultValue: 'YOUR_RESEND_API_KEY',
  );
}


===== lib/features/customers/pages/customers_list_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../core/theme/palette.dart';
import '../../../data/models/customers/customer.dart';
import '../bloc/customers_cubit.dart';

class CustomersListPage extends StatefulWidget {
  const CustomersListPage({super.key});

  @override
  State<CustomersListPage> createState() => _CustomersListPageState();
}

class _CustomersListPageState extends State<CustomersListPage> {
  final _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    context.read<CustomersCubit>().loadCustomers();
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Clientes'),
        actions: [
          IconButton(
            icon: const Icon(Icons.sync),
            onPressed: () =>
                context.read<CustomersCubit>().loadCustomers(forceSync: true),
          ),
        ],
      ),
      body: Column(
        children: [
          // Search bar
          Padding(
            padding: const EdgeInsets.all(16),
            child: TextField(
              controller: _searchController,
              decoration: const InputDecoration(
                hintText: 'Buscar clientes...',
                prefixIcon: Icon(Icons.search),
              ),
              onChanged: (value) {
                context.read<CustomersCubit>().searchCustomers(value);
              },
            ),
          ),

          // Customer list
          Expanded(
            child: BlocBuilder<CustomersCubit, CustomersState>(
              builder: (context, state) {
                return state.when(
                  initial: () =>
                      const Center(child: Text('Cargando clientes...')),
                  loading: () =>
                      const Center(child: CircularProgressIndicator()),
                  loaded: (customers) {
                    if (customers.isEmpty) {
                      return const Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(
                              Icons.people_outline,
                              size: 64,
                              color: AppPalette.textSecondary,
                            ),
                            SizedBox(height: 16),
                            Text(
                              'No hay clientes',
                              style: TextStyle(
                                fontSize: 18,
                                color: AppPalette.textSecondary,
                              ),
                            ),
                          ],
                        ),
                      );
                    }

                    return RefreshIndicator(
                      onRefresh: () => context
                          .read<CustomersCubit>()
                          .loadCustomers(forceSync: true),
                      child: ListView.builder(
                        itemCount: customers.length,
                        itemBuilder: (context, index) {
                          final customer = customers[index];
                          return CustomerListTile(
                            customer: customer,
                            onTap: () =>
                                context.push('/customers/${customer.id}'),
                          );
                        },
                      ),
                    );
                  },
                  error: (message) => Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.error_outline,
                          size: 64,
                          color: AppPalette.error,
                        ),
                        const SizedBox(height: 16),
                        Text(
                          message,
                          textAlign: TextAlign.center,
                          style: const TextStyle(fontSize: 16),
                        ),
                        const SizedBox(height: 16),
                        ElevatedButton(
                          onPressed: () =>
                              context.read<CustomersCubit>().loadCustomers(),
                          child: const Text('Reintentar'),
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => context.push('/customers/new'),
        child: const Icon(Icons.add),
      ),
    );
  }
}

class CustomerListTile extends StatelessWidget {
  final Customer customer;
  final VoidCallback onTap;

  const CustomerListTile({
    super.key,
    required this.customer,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: AppPalette.primary,
          child: Text(
            customer.name.isNotEmpty ? customer.name[0].toUpperCase() : '?',
            style: const TextStyle(
              color: Colors.white,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
        title: Text(
          customer.name,
          style: const TextStyle(fontWeight: FontWeight.w500),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (customer.code != null) ...[
              Text('Código: ${customer.code}'),
              const SizedBox(height: 2),
            ],
            if (customer.address != null) ...[
              Text(
                customer.address!,
                style: const TextStyle(fontSize: 12),
              ),
            ],
          ],
        ),
        trailing: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              customer.latitude != null && customer.longitude != null
                  ? Icons.location_on
                  : Icons.location_off,
              color: customer.latitude != null && customer.longitude != null
                  ? AppPalette.success
                  : AppPalette.textDisabled,
            ),
            const SizedBox(height: 4),
            const Icon(Icons.chevron_right),
          ],
        ),
        onTap: onTap,
      ),
    );
  }
}


===== lib/features/customers/pages/customer_detail_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:url_launcher/url_launcher.dart';
import '../../../core/theme/palette.dart';
import '../../../data/models/customers/customer.dart';
import '../../../data/models/visits/visit.dart';
import '../bloc/customers_cubit.dart';
import '../../visits/bloc/visits_cubit.dart';

class CustomerDetailPage extends StatefulWidget {
  final String customerId;

  const CustomerDetailPage({
    super.key,
    required this.customerId,
  });

  @override
  State<CustomerDetailPage> createState() => _CustomerDetailPageState();
}

class _CustomerDetailPageState extends State<CustomerDetailPage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  Customer? _customer;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
    _loadCustomer();
    _loadVisitHistory();
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  void _loadCustomer() {
    // TODO: Load customer details from repository
    _customer = Customer(
      id: widget.customerId,
      companyId: 'company_id',
      name: 'Cliente Ejemplo',
      email: 'cliente@ejemplo.com',
      phone: '+1234567890',
      address: 'Calle Ejemplo 123, Ciudad, País',
      latitude: 19.4326,
      longitude: -99.1332,
    );
  }

  void _loadVisitHistory() {
    context.read<VisitsCubit>().loadVisitHistory(widget.customerId);
  }

  @override
  Widget build(BuildContext context) {
    if (_customer == null) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: Text(_customer!.name),
        actions: [
          IconButton(
            icon: const Icon(Icons.edit),
            onPressed: () =>
                context.push('/customers/edit/${widget.customerId}'),
          ),
        ],
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(text: 'Info', icon: Icon(Icons.info)),
            Tab(text: 'Visitas', icon: Icon(Icons.location_on)),
            Tab(text: 'Pedidos', icon: Icon(Icons.shopping_cart)),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildInfoTab(),
          _buildVisitsTab(),
          _buildOrdersTab(),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _showVisitOptions(context),
        icon: const Icon(Icons.add_location),
        label: const Text('Nueva Visita'),
      ),
    );
  }

  Widget _buildInfoTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Contact info card
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Información de Contacto',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: AppPalette.primary,
                    ),
                  ),
                  const SizedBox(height: 16),
                  if (_customer!.email != null) ...[
                    _buildInfoRow(
                      Icons.email,
                      'Email',
                      _customer!.email!,
                      onTap: () => _launchEmail(_customer!.email!),
                    ),
                    const SizedBox(height: 12),
                  ],
                  if (_customer!.phone != null) ...[
                    _buildInfoRow(
                      Icons.phone,
                      'Teléfono',
                      _customer!.phone!,
                      onTap: () => _launchPhone(_customer!.phone!),
                    ),
                    const SizedBox(height: 12),
                  ],
                  if (_customer!.address != null) ...[
                    _buildInfoRow(
                      Icons.location_on,
                      'Dirección',
                      _customer!.address!,
                      onTap: () => _launchMaps(),
                    ),
                  ],
                ],
              ),
            ),
          ),
          const SizedBox(height: 16),

          // Stats card
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Estadísticas',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: AppPalette.primary,
                    ),
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Expanded(
                        child:
                            _buildStatItem('Visitas', '15', Icons.location_on),
                      ),
                      Expanded(
                        child:
                            _buildStatItem('Pedidos', '8', Icons.shopping_cart),
                      ),
                    ],
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Expanded(
                        child: _buildStatItem(
                            'Última Visita', '2 días', Icons.schedule),
                      ),
                      Expanded(
                        child: _buildStatItem(
                            'Total Ventas', '\$2,450', Icons.attach_money),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildVisitsTab() {
    return BlocBuilder<VisitsCubit, VisitsState>(
      builder: (context, state) {
        return state.when(
          initial: () => const Center(child: Text('Cargando...')),
          loading: () => const Center(child: CircularProgressIndicator()),
          history: (visits) {
            if (visits.isEmpty) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.location_off,
                      size: 64,
                      color: AppPalette.textSecondary,
                    ),
                    SizedBox(height: 16),
                    Text(
                      'No hay visitas registradas',
                      style: TextStyle(
                        fontSize: 18,
                        color: AppPalette.textSecondary,
                      ),
                    ),
                  ],
                ),
              );
            }

            return ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: visits.length,
              itemBuilder: (context, index) {
                final visit = visits[index];
                return VisitListTile(visit: visit);
              },
            );
          },
          orElse: () => const Center(child: Text('Error cargando visitas')),
        );
      },
    );
  }

  Widget _buildOrdersTab() {
    return const Center(
      child: Text('Historial de pedidos - TODO'),
    );
  }

  Widget _buildInfoRow(IconData icon, String label, String value,
      {VoidCallback? onTap}) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 4),
        child: Row(
          children: [
            Icon(icon, size: 20, color: AppPalette.primary),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    label,
                    style: const TextStyle(
                      fontSize: 12,
                      color: AppPalette.textSecondary,
                    ),
                  ),
                  Text(
                    value,
                    style: const TextStyle(fontSize: 16),
                  ),
                ],
              ),
            ),
            if (onTap != null)
              const Icon(Icons.chevron_right, color: AppPalette.textSecondary),
          ],
        ),
      ),
    );
  }

  Widget _buildStatItem(String label, String value, IconData icon) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: AppPalette.primary.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        children: [
          Icon(icon, color: AppPalette.primary, size: 24),
          const SizedBox(height: 8),
          Text(
            value,
            style: const TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
              color: AppPalette.primary,
            ),
          ),
          Text(
            label,
            style: const TextStyle(
              fontSize: 12,
              color: AppPalette.textSecondary,
            ),
          ),
        ],
      ),
    );
  }

  void _showVisitOptions(BuildContext context) {
    showModalBottomSheet(
      context: context,
      builder: (context) => VisitOptionsSheet(customer: _customer!),
    );
  }

  void _launchEmail(String email) async {
    final uri = Uri.parse('mailto:$email');
    if (await canLaunchUrl(uri)) {
      await launchUrl(uri);
    }
  }

  void _launchPhone(String phone) async {
    final uri = Uri.parse('tel:$phone');
    if (await canLaunchUrl(uri)) {
      await launchUrl(uri);
    }
  }

  void _launchMaps() async {
    if (_customer!.latitude != null && _customer!.longitude != null) {
      final uri = Uri.parse(
          'https://www.google.com/maps/search/?api=1&query=${_customer!.latitude},${_customer!.longitude}');
      if (await canLaunchUrl(uri)) {
        await launchUrl(uri);
      }
    }
  }
}

class VisitListTile extends StatelessWidget {
  final Visit visit;

  const VisitListTile({super.key, required this.visit});

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: _getPurposeColor(visit.purpose),
          child: Icon(
            _getPurposeIcon(visit.purpose),
            color: Colors.white,
            size: 20,
          ),
        ),
        title: Text(_getPurposeLabel(visit.purpose)),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (visit.startedAt != null)
              Text('Inicio: ${_formatDateTime(visit.startedAt!)}'),
            if (visit.finishedAt != null)
              Text('Fin: ${_formatDateTime(visit.finishedAt!)}'),
            if (visit.notes?.isNotEmpty == true) Text('Notas: ${visit.notes}'),
          ],
        ),
        trailing: Icon(
          visit.finishedAt != null ? Icons.check_circle : Icons.schedule,
          color: visit.finishedAt != null
              ? AppPalette.success
              : AppPalette.warning,
        ),
      ),
    );
  }

  Color _getPurposeColor(VisitPurpose purpose) {
    switch (purpose) {
      case VisitPurpose.venta:
        return AppPalette.success;
      case VisitPurpose.cobro:
        return AppPalette.warning;
      case VisitPurpose.entrega:
        return AppPalette.info;
      case VisitPurpose.auditoria:
        return AppPalette.primary;
      case VisitPurpose.devolucion:
        return AppPalette.error;
      default:
        return AppPalette.textSecondary;
    }
  }

  IconData _getPurposeIcon(VisitPurpose purpose) {
    switch (purpose) {
      case VisitPurpose.venta:
        return Icons.shopping_cart;
      case VisitPurpose.cobro:
        return Icons.payment;
      case VisitPurpose.entrega:
        return Icons.local_shipping;
      case VisitPurpose.auditoria:
        return Icons.assignment;
      case VisitPurpose.devolucion:
        return Icons.keyboard_return;
      default:
        return Icons.location_on;
    }
  }

  String _getPurposeLabel(VisitPurpose purpose) {
    switch (purpose) {
      case VisitPurpose.venta:
        return 'Venta';
      case VisitPurpose.cobro:
        return 'Cobro';
      case VisitPurpose.entrega:
        return 'Entrega';
      case VisitPurpose.visita:
        return 'Visita General';
      case VisitPurpose.auditoria:
        return 'Auditoría';
      case VisitPurpose.devolucion:
        return 'Devolución';
      case VisitPurpose.otro:
        return 'Otro';
    }
  }

  String _formatDateTime(DateTime dateTime) {
    return '${dateTime.day}/${dateTime.month}/${dateTime.year} ${dateTime.hour}:${dateTime.minute.toString().padLeft(2, '0')}';
  }
}

class VisitOptionsSheet extends StatelessWidget {
  final Customer customer;

  const VisitOptionsSheet({super.key, required this.customer});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Text(
            'Seleccionar tipo de visita',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),
          GridView.count(
            shrinkWrap: true,
            crossAxisCount: 2,
            childAspectRatio: 2,
            crossAxisSpacing: 8,
            mainAxisSpacing: 8,
            children: [
              _VisitOptionTile(
                icon: Icons.visibility,
                label: 'Visita General',
                color: AppPalette.info,
                onTap: () => _startVisit(context, VisitPurpose.visita),
              ),
              _VisitOptionTile(
                icon: Icons.shopping_cart,
                label: 'Venta',
                color: AppPalette.success,
                onTap: () => _startVisit(context, VisitPurpose.venta),
              ),
              _VisitOptionTile(
                icon: Icons.payment,
                label: 'Cobro',
                color: AppPalette.warning,
                onTap: () => _startVisit(context, VisitPurpose.cobro),
              ),
              _VisitOptionTile(
                icon: Icons.local_shipping,
                label: 'Entrega',
                color: AppPalette.primary,
                onTap: () => _startVisit(context, VisitPurpose.entrega),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void _startVisit(BuildContext context, VisitPurpose purpose) {
    Navigator.of(context).pop();
    context.push('/visit/checkin/${customer.id}?purpose=${purpose.name}');
  }
}

class _VisitOptionTile extends StatelessWidget {
  final IconData icon;
  final String label;
  final Color color;
  final VoidCallback onTap;

  const _VisitOptionTile({
    required this.icon,
    required this.label,
    required this.color,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: color),
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, color: color, size: 24),
            const SizedBox(height: 4),
            Text(
              label,
              style: TextStyle(
                color: color,
                fontSize: 12,
                fontWeight: FontWeight.w500,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}


===== lib/features/customers/pages/customer_form_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:geolocator/geolocator.dart';
import '../../../core/theme/palette.dart';
import '../../../data/models/customers/customer.dart';
import '../../../services/location/location_service.dart';
import '../bloc/customers_cubit.dart';

class CustomerFormPage extends StatefulWidget {
  final String? customerId;

  const CustomerFormPage({
    super.key,
    this.customerId,
  });

  @override
  State<CustomerFormPage> createState() => _CustomerFormPageState();
}

class _CustomerFormPageState extends State<CustomerFormPage> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _codeController = TextEditingController();
  final _emailController = TextEditingController();
  final _phoneController = TextEditingController();
  final _addressController = TextEditingController();

  bool _isLocationSet = false;
  double? _latitude;
  double? _longitude;
  bool _isLoadingLocation = false;

  bool get _isEditing => widget.customerId != null;

  @override
  void initState() {
    super.initState();
    if (_isEditing) {
      _loadCustomer();
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _codeController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _addressController.dispose();
    super.dispose();
  }

  void _loadCustomer() {
    // TODO: Load customer data for editing
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(_isEditing ? 'Editar Cliente' : 'Nuevo Cliente'),
        actions: [
          TextButton(
            onPressed: _saveCustomer,
            child: const Text(
              'Guardar',
              style: TextStyle(color: Colors.white),
            ),
          ),
        ],
      ),
      body: BlocConsumer<CustomersCubit, CustomersState>(
        listener: (context, state) {
          state.whenOrNull(
            loaded: (customers) {
              context.pop();
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(
                      _isEditing ? 'Cliente actualizado' : 'Cliente creado'),
                  backgroundColor: AppPalette.success,
                ),
              );
            },
            error: (message) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(message),
                  backgroundColor: AppPalette.error,
                ),
              );
            },
          );
        },
        builder: (context, state) {
          return SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Basic info section
                  _buildSection(
                    'Información Básica',
                    [
                      TextFormField(
                        controller: _nameController,
                        decoration: const InputDecoration(
                          labelText: 'Nombre *',
                          border: OutlineInputBorder(),
                        ),
                        validator: (value) {
                          if (value?.isEmpty ?? true) {
                            return 'Nombre es requerido';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _codeController,
                        decoration: const InputDecoration(
                          labelText: 'Código',
                          border: OutlineInputBorder(),
                        ),
                      ),
                    ],
                  ),

                  // Contact info section
                  _buildSection(
                    'Información de Contacto',
                    [
                      TextFormField(
                        controller: _emailController,
                        keyboardType: TextInputType.emailAddress,
                        decoration: const InputDecoration(
                          labelText: 'Email',
                          border: OutlineInputBorder(),
                        ),
                        validator: (value) {
                          if (value?.isNotEmpty == true) {
                            if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
                                .hasMatch(value!)) {
                              return 'Email inválido';
                            }
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _phoneController,
                        keyboardType: TextInputType.phone,
                        decoration: const InputDecoration(
                          labelText: 'Teléfono',
                          border: OutlineInputBorder(),
                        ),
                      ),
                    ],
                  ),

                  // Address section
                  _buildSection(
                    'Dirección y Ubicación',
                    [
                      TextFormField(
                        controller: _addressController,
                        maxLines: 2,
                        decoration: const InputDecoration(
                          labelText: 'Dirección',
                          border: OutlineInputBorder(),
                        ),
                      ),
                      const SizedBox(height: 16),

                      // Location section
                      Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          color: _isLocationSet
                              ? AppPalette.success.withOpacity(0.1)
                              : AppPalette.warning.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(
                            color: _isLocationSet
                                ? AppPalette.success
                                : AppPalette.warning,
                          ),
                        ),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              children: [
                                Icon(
                                  _isLocationSet
                                      ? Icons.location_on
                                      : Icons.location_off,
                                  color: _isLocationSet
                                      ? AppPalette.success
                                      : AppPalette.warning,
                                ),
                                const SizedBox(width: 8),
                                Text(
                                  _isLocationSet
                                      ? 'Ubicación configurada'
                                      : 'Ubicación no configurada',
                                  style: TextStyle(
                                    fontWeight: FontWeight.w500,
                                    color: _isLocationSet
                                        ? AppPalette.success
                                        : AppPalette.warning,
                                  ),
                                ),
                              ],
                            ),
                            if (_isLocationSet) ...[
                              const SizedBox(height: 8),
                              Text(
                                'Lat: ${_latitude?.toStringAsFixed(6)}\nLng: ${_longitude?.toStringAsFixed(6)}',
                                style: const TextStyle(
                                  fontSize: 12,
                                  color: AppPalette.textSecondary,
                                ),
                              ),
                            ],
                            const SizedBox(height: 12),
                            SizedBox(
                              width: double.infinity,
                              child: ElevatedButton.icon(
                                onPressed: _isLoadingLocation
                                    ? null
                                    : _getCurrentLocation,
                                icon: _isLoadingLocation
                                    ? const SizedBox(
                                        width: 16,
                                        height: 16,
                                        child: CircularProgressIndicator(
                                            strokeWidth: 2),
                                      )
                                    : const Icon(Icons.my_location),
                                label: Text(_isLoadingLocation
                                    ? 'Obteniendo...'
                                    : 'Obtener Ubicación Actual'),
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: AppPalette.primary,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),

                  const SizedBox(height: 32),

                  // Save button
                  SizedBox(
                    width: double.infinity,
                    height: 48,
                    child: ElevatedButton(
                      onPressed: state.maybeWhen(
                        loading: () => null,
                        orElse: () => _saveCustomer,
                      ),
                      child: state.maybeWhen(
                        loading: () => const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            valueColor:
                                AlwaysStoppedAnimation<Color>(Colors.white),
                          ),
                        ),
                        orElse: () => Text(
                          _isEditing ? 'Actualizar Cliente' : 'Crear Cliente',
                          style: const TextStyle(fontSize: 16),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildSection(String title, List<Widget> children) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
            color: AppPalette.primary,
          ),
        ),
        const SizedBox(height: 16),
        ...children,
        const SizedBox(height: 24),
      ],
    );
  }

  Future<void> _getCurrentLocation() async {
    setState(() {
      _isLoadingLocation = true;
    });

    try {
      final position = await LocationService().getCurrentLocation();
      if (position != null) {
        setState(() {
          _latitude = position.latitude;
          _longitude = position.longitude;
          _isLocationSet = true;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Ubicación obtenida exitosamente'),
            backgroundColor: AppPalette.success,
          ),
        );
      } else {
        throw Exception('No se pudo obtener la ubicación');
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error al obtener ubicación: $e'),
          backgroundColor: AppPalette.error,
        ),
      );
    } finally {
      setState(() {
        _isLoadingLocation = false;
      });
    }
  }

  void _saveCustomer() {
    if (_formKey.currentState?.validate() ?? false) {
      final customer = Customer(
        id: widget.customerId ??
            DateTime.now().millisecondsSinceEpoch.toString(),
        companyId: 'current_company_id', // TODO: Get from auth
        code: _codeController.text.isNotEmpty ? _codeController.text : null,
        name: _nameController.text,
        email: _emailController.text.isNotEmpty ? _emailController.text : null,
        phone: _phoneController.text.isNotEmpty ? _phoneController.text : null,
        address:
            _addressController.text.isNotEmpty ? _addressController.text : null,
        latitude: _latitude,
        longitude: _longitude,
      );

      context.read<CustomersCubit>().createCustomer(customer);
    }
  }
}


===== lib/features/customers/bloc/customers_cubit.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../../data/models/customers/customer.dart';
import '../../../data/repositories/customers_repository.dart';
import '../../../config/logger.dart';

part 'customers_state.dart';
part 'customers_cubit.freezed.dart';

class CustomersCubit extends Cubit<CustomersState> {
  final CustomersRepository _repository;

  CustomersCubit(this._repository) : super(const CustomersState.initial());

  Future<void> loadCustomers({bool forceSync = false}) async {
    emit(const CustomersState.loading());

    try {
      final customers = await _repository.getCustomers(forceSync: forceSync);
      emit(CustomersState.loaded(customers));
    } catch (e) {
      logger.e('Load customers error: $e');
      emit(CustomersState.error(e.toString()));
    }
  }

  Future<void> createCustomer(Customer customer) async {
    try {
      final currentState = state;
      if (currentState is CustomersLoaded) {
        emit(const CustomersState.loading());

        final newCustomer = await _repository.createCustomer(customer);
        final updatedCustomers = [...currentState.customers, newCustomer];

        emit(CustomersState.loaded(updatedCustomers));
      }
    } catch (e) {
      logger.e('Create customer error: $e');
      emit(CustomersState.error(e.toString()));
    }
  }

  Future<void> searchCustomers(String query) async {
    try {
      final currentState = state;
      if (currentState is CustomersLoaded) {
        final filteredCustomers = currentState.customers
            .where((customer) =>
                customer.name.toLowerCase().contains(query.toLowerCase()) ||
                (customer.code?.toLowerCase().contains(query.toLowerCase()) ??
                    false) ||
                (customer.email?.toLowerCase().contains(query.toLowerCase()) ??
                    false))
            .toList();

        emit(CustomersState.loaded(filteredCustomers));
      }
    } catch (e) {
      logger.e('Search customers error: $e');
    }
  }
}

@freezed
class CustomersState with _$CustomersState {
  const factory CustomersState.initial() = _Initial;
  const factory CustomersState.loading() = _Loading;
  const factory CustomersState.loaded(List<Customer> customers) =
      CustomersLoaded;
  const factory CustomersState.error(String message) = _Error;
}


===== lib/features/payments/pages/payments_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../core/theme/palette.dart';
import '../../../data/models/customers/customer.dart';
import '../bloc/payments_cubit.dart';

class PaymentsPage extends StatefulWidget {
  const PaymentsPage({super.key});

  @override
  State<PaymentsPage> createState() => _PaymentsPageState();
}

class _PaymentsPageState extends State<PaymentsPage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    context.read<PaymentsCubit>().loadPayments();
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Gestión de Cobros'),
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(text: 'Pendientes', icon: Icon(Icons.schedule)),
            Tab(text: 'Completados', icon: Icon(Icons.check_circle)),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildPendingPayments(),
          _buildCompletedPayments(),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _showNewPaymentForm(),
        icon: const Icon(Icons.add),
        label: const Text('Nuevo Cobro'),
      ),
    );
  }

  Widget _buildPendingPayments() {
    return BlocBuilder<PaymentsCubit, PaymentsState>(
      builder: (context, state) {
        return state.when(
          initial: () => const Center(child: Text('Cargando...')),
          loading: () => const Center(child: CircularProgressIndicator()),
          loaded: (payments) {
            final pendingPayments =
                payments.where((p) => p.status == 'PENDING').toList();

            if (pendingPayments.isEmpty) {
              return const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.payment_outlined,
                      size: 64,
                      color: AppPalette.textSecondary,
                    ),
                    SizedBox(height: 16),
                    Text(
                      'No hay cobros pendientes',
                      style: TextStyle(
                        fontSize: 18,
                        color: AppPalette.textSecondary,
                      ),
                    ),
                  ],
                ),
              );
            }

            return ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: pendingPayments.length,
              itemBuilder: (context, index) {
                final payment = pendingPayments[index];
                return PaymentCard(
                  payment: payment,
                  onTap: () => _processPayment(payment),
                );
              },
            );
          },
          error: (message) => Center(child: Text(message)),
        );
      },
    );
  }

  Widget _buildCompletedPayments() {
    return BlocBuilder<PaymentsCubit, PaymentsState>(
      builder: (context, state) {
        return state.when(
          initial: () => const Center(child: Text('Cargando...')),
          loading: () => const Center(child: CircularProgressIndicator()),
          loaded: (payments) {
            final completedPayments =
                payments.where((p) => p.status == 'COMPLETED').toList();

            return ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: completedPayments.length,
              itemBuilder: (context, index) {
                final payment = completedPayments[index];
                return PaymentCard(
                  payment: payment,
                  onTap: () => _showPaymentDetails(payment),
                );
              },
            );
          },
          error: (message) => Center(child: Text(message)),
        );
      },
    );
  }

  void _showNewPaymentForm() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => const NewPaymentForm(),
    );
  }

  void _processPayment(dynamic payment) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => PaymentProcessForm(payment: payment),
    );
  }

  void _showPaymentDetails(dynamic payment) {
    // TODO: Show payment details
  }
}

class PaymentCard extends StatelessWidget {
  final dynamic payment;
  final VoidCallback onTap;

  const PaymentCard({
    super.key,
    required this.payment,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Text(
                      'Cliente Ejemplo',
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                  Text(
                    '\$2,500.00',
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: AppPalette.primary,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Row(
                children: [
                  const Icon(
                    Icons.schedule,
                    size: 16,
                    color: AppPalette.textSecondary,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    'Vence: 15/08/2025',
                    style: const TextStyle(
                      fontSize: 14,
                      color: AppPalette.textSecondary,
                    ),
                  ),
                  const Spacer(),
                  Container(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: AppPalette.warning.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      'PENDIENTE',
                      style: TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.w600,
                        color: AppPalette.warning,
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class NewPaymentForm extends StatefulWidget {
  const NewPaymentForm({super.key});

  @override
  State<NewPaymentForm> createState() => _NewPaymentFormState();
}

class _NewPaymentFormState extends State<NewPaymentForm> {
  final _formKey = GlobalKey<FormState>();
  final _amountController = TextEditingController();
  final _notesController = TextEditingController();

  Customer? _selectedCustomer;
  String _selectedMethod = 'EFECTIVO';

  @override
  Widget build(BuildContext context) {
    return Container(
      height: MediaQuery.of(context).size.height * 0.8,
      padding: const EdgeInsets.all(16),
      child: Form(
        key: _formKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            const Text(
              'Registrar Nuevo Cobro',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
            const Divider(),

            // Form fields
            Expanded(
              child: SingleChildScrollView(
                child: Column(
                  children: [
                    // Customer selection
                    DropdownButtonFormField<Customer>(
                      value: _selectedCustomer,
                      decoration: const InputDecoration(
                        labelText: 'Cliente *',
                        border: OutlineInputBorder(),
                      ),
                      items: [], // TODO: Load customers
                      onChanged: (customer) {
                        setState(() {
                          _selectedCustomer = customer;
                        });
                      },
                      validator: (value) {
                        if (value == null) return 'Cliente es requerido';
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Amount
                    TextFormField(
                      controller: _amountController,
                      keyboardType:
                          TextInputType.numberWithOptions(decimal: true),
                      decoration: const InputDecoration(
                        labelText: 'Monto *',
                        prefixText: '\$',
                        border: OutlineInputBorder(),
                      ),
                      validator: (value) {
                        if (value?.isEmpty ?? true) return 'Monto es requerido';
                        if (double.tryParse(value!) == null)
                          return 'Monto inválido';
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Payment method
                    DropdownButtonFormField<String>(
                      value: _selectedMethod,
                      decoration: const InputDecoration(
                        labelText: 'Método de Pago',
                        border: OutlineInputBorder(),
                      ),
                      items: const [
                        DropdownMenuItem(
                            value: 'EFECTIVO', child: Text('Efectivo')),
                        DropdownMenuItem(
                            value: 'TARJETA', child: Text('Tarjeta')),
                        DropdownMenuItem(
                            value: 'TRANSFERENCIA',
                            child: Text('Transferencia')),
                        DropdownMenuItem(
                            value: 'CHEQUE', child: Text('Cheque')),
                      ],
                      onChanged: (value) {
                        if (value != null) {
                          setState(() {
                            _selectedMethod = value;
                          });
                        }
                      },
                    ),
                    const SizedBox(height: 16),

                    // Notes
                    TextFormField(
                      controller: _notesController,
                      maxLines: 3,
                      decoration: const InputDecoration(
                        labelText: 'Notas',
                        border: OutlineInputBorder(),
                      ),
                    ),
                  ],
                ),
              ),
            ),

            // Save button
            SizedBox(
              width: double.infinity,
              height: 48,
              child: ElevatedButton(
                onPressed: _savePayment,
                child: const Text('Registrar Cobro'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _savePayment() {
    if (_formKey.currentState?.validate() ?? false) {
      // TODO: Save payment
      Navigator.of(context).pop();
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Cobro registrado exitosamente'),
          backgroundColor: AppPalette.success,
        ),
      );
    }
  }
}

class PaymentProcessForm extends StatefulWidget {
  final dynamic payment;

  const PaymentProcessForm({
    super.key,
    required this.payment,
  });

  @override
  State<PaymentProcessForm> createState() => _PaymentProcessFormState();
}

class _PaymentProcessFormState extends State<PaymentProcessForm> {
  final _amountController = TextEditingController();
  final _notesController = TextEditingController();
  String _selectedMethod = 'EFECTIVO';

  @override
  Widget build(BuildContext context) {
    return Container(
      height: MediaQuery.of(context).size.height * 0.7,
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Procesar Cobro',
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          const Divider(),

          // Payment amount
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: AppPalette.primary.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Monto a cobrar:',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                Text(
                  '\$2,500.00',
                  style: const TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: AppPalette.primary,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 24),

          // Form fields
          TextFormField(
            controller: _amountController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: const InputDecoration(
              labelText: 'Monto recibido *',
              prefixText: '\$',
              border: OutlineInputBorder(),
            ),
          ),
          const SizedBox(height: 16),

          DropdownButtonFormField<String>(
            value: _selectedMethod,
            decoration: const InputDecoration(
              labelText: 'Método de Pago',
              border: OutlineInputBorder(),
            ),
            items: const [
              DropdownMenuItem(value: 'EFECTIVO', child: Text('Efectivo')),
              DropdownMenuItem(value: 'TARJETA', child: Text('Tarjeta')),
              DropdownMenuItem(
                  value: 'TRANSFERENCIA', child: Text('Transferencia')),
              DropdownMenuItem(value: 'CHEQUE', child: Text('Cheque')),
            ],
            onChanged: (value) {
              if (value != null) {
                setState(() {
                  _selectedMethod = value;
                });
              }
            },
          ),
          const SizedBox(height: 16),

          TextFormField(
            controller: _notesController,
            maxLines: 3,
            decoration: const InputDecoration(
              labelText: 'Observaciones',
              border: OutlineInputBorder(),
            ),
          ),
          const Spacer(),

          // Action buttons
          Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: const Text('Cancelar'),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: ElevatedButton(
                  onPressed: _processPayment,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppPalette.success,
                  ),
                  child: const Text('Procesar Cobro'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void _processPayment() {
    // TODO: Process payment
    Navigator.of(context).pop();
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Cobro procesado exitosamente'),
        backgroundColor: AppPalette.success,
      ),
    );
  }
}


===== lib/features/payments/bloc/payments_cubit.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../../data/repositories/payments_repository.dart';
import '../../../data/models/customers/customer.dart';
import '../../../config/logger.dart';

part 'payments_state.dart';
part 'payments_cubit.freezed.dart';

class PaymentsCubit extends Cubit<PaymentsState> {
  final PaymentsRepository _repository;

  PaymentsCubit(this._repository) : super(const PaymentsState.initial());

  Future<void> loadPayments({bool forceSync = false}) async {
    emit(const PaymentsState.loading());

    try {
      final payments = await _repository.getPayments(forceSync: forceSync);
      emit(PaymentsState.loaded(payments));
    } catch (e) {
      logger.e('Load payments error: $e');
      emit(PaymentsState.error(e.toString()));
    }
  }

  Future<void> loadPendingPayments() async {
    emit(const PaymentsState.loading());

    try {
      final pendingPayments = await _repository.getPendingPayments();
      emit(PaymentsState.pendingLoaded(pendingPayments));
    } catch (e) {
      logger.e('Load pending payments error: $e');
      emit(PaymentsState.error(e.toString()));
    }
  }

  Future<void> registerPayment({
    required String? customerId,
    required double amount,
    required String method,
    String? orderId,
    String? notes,
  }) async {
    try {
      emit(const PaymentsState.processing());

      final payment = PaymentModel(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        customerId: customerId,
        orderId: orderId,
        userId: 'current_user_id', // TODO: Get from auth
        amount: amount,
        method: method,
        paidAt: DateTime.now(),
        notes: notes,
        status: 'COMPLETED',
      );

      final registeredPayment = await _repository.registerPayment(payment);

      // Update the payments list
      final currentState = state;
      if (currentState is PaymentsLoaded) {
        final updatedPayments = [registeredPayment, ...currentState.payments];
        emit(PaymentsState.loaded(updatedPayments));
      } else {
        // If not loaded, just show success
        emit(PaymentsState.paymentRegistered(
          registeredPayment,
          'Pago registrado exitosamente',
        ));
      }
    } catch (e) {
      logger.e('Register payment error: $e');
      emit(PaymentsState.error(e.toString()));
    }
  }

  Future<void> processPayment({
    required String paymentId,
    required double receivedAmount,
    required String method,
    String? notes,
  }) async {
    try {
      emit(const PaymentsState.processing());

      // Find the payment to process
      final currentState = state;
      PaymentModel? paymentToProcess;

      if (currentState is PaymentsPendingLoaded) {
        paymentToProcess =
            currentState.pendingPayments.firstWhere((p) => p.id == paymentId);
      }

      if (paymentToProcess == null) {
        throw Exception('Payment not found');
      }

      // Create processed payment
      final processedPayment = PaymentModel(
        id: paymentToProcess.id,
        customerId: paymentToProcess.customerId,
        orderId: paymentToProcess.orderId,
        userId: paymentToProcess.userId,
        amount: receivedAmount,
        method: method,
        paidAt: DateTime.now(),
        notes: notes,
        status: 'COMPLETED',
        customer: paymentToProcess.customer,
      );

      await _repository.registerPayment(processedPayment);

      emit(PaymentsState.paymentProcessed(
        processedPayment,
        'Pago procesado exitosamente',
      ));

      // Reload pending payments
      await loadPendingPayments();
    } catch (e) {
      logger.e('Process payment error: $e');
      emit(PaymentsState.error(e.toString()));
    }
  }

  Future<void> searchPayments(String query) async {
    try {
      final currentState = state;
      if (currentState is PaymentsLoaded) {
        if (query.isEmpty) {
          // Return to normal loaded state
          return;
        }

        final filteredPayments = currentState.payments.where((payment) {
          final searchFields = [
            payment.customer?.name ?? '',
            payment.method ?? '',
            payment.amount.toString(),
            payment.notes ?? '',
          ];

          return searchFields.any(
              (field) => field.toLowerCase().contains(query.toLowerCase()));
        }).toList();

        emit(PaymentsState.searched(filteredPayments, query));
      }
    } catch (e) {
      logger.e('Search payments error: $e');
    }
  }

  Future<void> filterPaymentsByMethod(String method) async {
    try {
      final currentState = state;
      if (currentState is PaymentsLoaded) {
        final filteredPayments = currentState.payments
            .where((payment) => payment.method == method)
            .toList();

        emit(PaymentsState.filtered(filteredPayments, method));
      }
    } catch (e) {
      logger.e('Filter payments by method error: $e');
    }
  }

  Future<void> filterPaymentsByStatus(String status) async {
    try {
      final currentState = state;
      if (currentState is PaymentsLoaded) {
        final filteredPayments = currentState.payments
            .where((payment) => payment.status == status)
            .toList();

        emit(PaymentsState.filtered(filteredPayments, status));
      }
    } catch (e) {
      logger.e('Filter payments by status error: $e');
    }
  }

  Future<void> filterPaymentsByDateRange({
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      final currentState = state;
      if (currentState is PaymentsLoaded) {
        final filteredPayments = currentState.payments.where((payment) {
          return payment.paidAt.isAfter(startDate) &&
              payment.paidAt.isBefore(endDate.add(const Duration(days: 1)));
        }).toList();

        emit(PaymentsState.filtered(
          filteredPayments,
          '${_formatDate(startDate)} - ${_formatDate(endDate)}',
        ));
      }
    } catch (e) {
      logger.e('Filter payments by date range error: $e');
    }
  }

  void clearFilters() {
    final currentState = state;
    if (currentState is PaymentsFiltered || currentState is PaymentsSearched) {
      // Reload all payments
      loadPayments();
    }
  }

  Future<void> generatePaymentReport({
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      emit(const PaymentsState.generatingReport());

      final currentState = state;
      if (currentState is PaymentsLoaded) {
        // Filter payments by date range
        final payments = currentState.payments.where((payment) {
          return payment.paidAt.isAfter(startDate) &&
              payment.paidAt.isBefore(endDate.add(const Duration(days: 1)));
        }).toList();

        // Calculate report data
        final totalAmount =
            payments.fold<double>(0, (sum, payment) => sum + payment.amount);

        final paymentsByMethod = <String, PaymentMethodSummary>{};
        for (final payment in payments) {
          final method = payment.method ?? 'UNKNOWN';
          if (paymentsByMethod.containsKey(method)) {
            paymentsByMethod[method] = paymentsByMethod[method]!.copyWith(
              count: paymentsByMethod[method]!.count + 1,
              amount: paymentsByMethod[method]!.amount + payment.amount,
            );
          } else {
            paymentsByMethod[method] = PaymentMethodSummary(
              method: method,
              count: 1,
              amount: payment.amount,
            );
          }
        }

        final report = PaymentReport(
          period: '${_formatDate(startDate)} - ${_formatDate(endDate)}',
          totalPayments: payments.length,
          totalAmount: totalAmount,
          averagePayment:
              payments.isNotEmpty ? totalAmount / payments.length : 0,
          paymentsByMethod: paymentsByMethod.values.toList(),
          dailyPayments: _calculateDailyPayments(payments, startDate, endDate),
        );

        emit(PaymentsState.reportGenerated(report));
      }
    } catch (e) {
      logger.e('Generate payment report error: $e');
      emit(PaymentsState.error(e.toString()));
    }
  }

  List<DailyPaymentSummary> _calculateDailyPayments(
    List<PaymentModel> payments,
    DateTime startDate,
    DateTime endDate,
  ) {
    final dailyPayments = <DateTime, DailyPaymentSummary>{};

    // Initialize all days with zero
    DateTime currentDate = startDate;
    while (currentDate.isBefore(endDate.add(const Duration(days: 1)))) {
      final dateKey =
          DateTime(currentDate.year, currentDate.month, currentDate.day);
      dailyPayments[dateKey] = DailyPaymentSummary(
        date: dateKey,
        count: 0,
        amount: 0,
      );
      currentDate = currentDate.add(const Duration(days: 1));
    }

    // Add actual payments
    for (final payment in payments) {
      final dateKey = DateTime(
        payment.paidAt.year,
        payment.paidAt.month,
        payment.paidAt.day,
      );

      if (dailyPayments.containsKey(dateKey)) {
        dailyPayments[dateKey] = dailyPayments[dateKey]!.copyWith(
          count: dailyPayments[dateKey]!.count + 1,
          amount: dailyPayments[dateKey]!.amount + payment.amount,
        );
      }
    }

    return dailyPayments.values.toList()
      ..sort((a, b) => a.date.compareTo(b.date));
  }

  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }
}

@freezed
class PaymentsState with _$PaymentsState {
  const factory PaymentsState.initial() = _Initial;
  const factory PaymentsState.loading() = _Loading;
  const factory PaymentsState.loaded(List<PaymentModel> payments) =
      PaymentsLoaded;
  const factory PaymentsState.pendingLoaded(
      List<PaymentModel> pendingPayments) = PaymentsPendingLoaded;
  const factory PaymentsState.filtered(
      List<PaymentModel> payments, String filter) = PaymentsFiltered;
  const factory PaymentsState.searched(
      List<PaymentModel> payments, String query) = PaymentsSearched;
  const factory PaymentsState.processing() = _Processing;
  const factory PaymentsState.paymentRegistered(
      PaymentModel payment, String message) = _PaymentRegistered;
  const factory PaymentsState.paymentProcessed(
      PaymentModel payment, String message) = _PaymentProcessed;
  const factory PaymentsState.generatingReport() = _GeneratingReport;
  const factory PaymentsState.reportGenerated(PaymentReport report) =
      _ReportGenerated;
  const factory PaymentsState.error(String message) = _Error;
}

@freezed
class PaymentReport with _$PaymentReport {
  const factory PaymentReport({
    required String period,
    required int totalPayments,
    required double totalAmount,
    required double averagePayment,
    required List<PaymentMethodSummary> paymentsByMethod,
    required List<DailyPaymentSummary> dailyPayments,
  }) = _PaymentReport;
}

@freezed
class PaymentMethodSummary with _$PaymentMethodSummary {
  const factory PaymentMethodSummary({
    required String method,
    required int count,
    required double amount,
  }) = _PaymentMethodSummary;
}

@freezed
class DailyPaymentSummary with _$DailyPaymentSummary {
  const factory DailyPaymentSummary({
    required DateTime date,
    required int count,
    required double amount,
  }) = _DailyPaymentSummary;
}


===== lib/features/auth/pages/sign_in_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../core/theme/palette.dart';
import '../bloc/auth_cubit.dart';

class SignInPage extends StatefulWidget {
  const SignInPage({super.key});

  @override
  State<SignInPage> createState() => _SignInPageState();
}

class _SignInPageState extends State<SignInPage> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _obscurePassword = true;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: BlocConsumer<AuthCubit, AuthState>(
        listener: (context, state) {
          state.whenOrNull(
            authenticated: (_) => context.go('/dashboard'),
            error: (message) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(message),
                  backgroundColor: AppPalette.error,
                ),
              );
            },
          );
        },
        builder: (context, state) {
          return SafeArea(
            child: Center(
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(24),
                child: Form(
                  key: _formKey,
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      // Logo
                      Container(
                        width: 120,
                        height: 120,
                        decoration: const BoxDecoration(
                          color: AppPalette.primary,
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(
                          Icons.business_center,
                          size: 60,
                          color: Colors.white,
                        ),
                      ),
                      const SizedBox(height: 32),

                      // Title
                      const Text(
                        'Arsenal Sell App',
                        style: TextStyle(
                          fontSize: 28,
                          fontWeight: FontWeight.bold,
                          color: AppPalette.primary,
                        ),
                      ),
                      const SizedBox(height: 8),
                      const Text(
                        'Control de Fuerza de Ventas',
                        style: TextStyle(
                          fontSize: 16,
                          color: AppPalette.textSecondary,
                        ),
                      ),
                      const SizedBox(height: 48),

                      // Email Field
                      TextFormField(
                        controller: _emailController,
                        keyboardType: TextInputType.emailAddress,
                        decoration: const InputDecoration(
                          labelText: 'Email',
                          prefixIcon: Icon(Icons.email_outlined),
                        ),
                        validator: (value) {
                          if (value?.isEmpty ?? true) {
                            return 'Email es requerido';
                          }
                          if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
                              .hasMatch(value!)) {
                            return 'Email inválido';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),

                      // Password Field
                      TextFormField(
                        controller: _passwordController,
                        obscureText: _obscurePassword,
                        decoration: InputDecoration(
                          labelText: 'Contraseña',
                          prefixIcon: const Icon(Icons.lock_outlined),
                          suffixIcon: IconButton(
                            icon: Icon(
                              _obscurePassword
                                  ? Icons.visibility
                                  : Icons.visibility_off,
                            ),
                            onPressed: () {
                              setState(() {
                                _obscurePassword = !_obscurePassword;
                              });
                            },
                          ),
                        ),
                        validator: (value) {
                          if (value?.isEmpty ?? true) {
                            return 'Contraseña es requerida';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 32),

                      // Sign In Button
                      SizedBox(
                        width: double.infinity,
                        height: 48,
                        child: ElevatedButton(
                          onPressed: state.maybeWhen(
                            loading: () => null,
                            orElse: () => _signIn,
                          ),
                          child: state.maybeWhen(
                            loading: () => const SizedBox(
                              height: 20,
                              width: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                valueColor:
                                    AlwaysStoppedAnimation<Color>(Colors.white),
                              ),
                            ),
                            orElse: () => const Text(
                              'Iniciar Sesión',
                              style: TextStyle(fontSize: 16),
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  void _signIn() {
    if (_formKey.currentState?.validate() ?? false) {
      context.read<AuthCubit>().signIn(
            _emailController.text.trim(),
            _passwordController.text,
          );
    }
  }
}


===== lib/features/auth/bloc/auth_cubit.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../../data/models/auth/user_profile.dart';
import '../../../data/repositories/auth_repository.dart';
import '../../../config/logger.dart';

part 'auth_state.dart';
part 'auth_cubit.freezed.dart';

class AuthCubit extends Cubit<AuthState> {
  final AuthRepository _authRepository;

  AuthCubit(this._authRepository) : super(const AuthState.initial());

  Future<void> checkAuthStatus() async {
    emit(const AuthState.loading());

    try {
      final user = await _authRepository.getCurrentUser();
      if (user != null) {
        emit(AuthState.authenticated(user));
      } else {
        emit(const AuthState.unauthenticated());
      }
    } catch (e) {
      logger.e('Check auth status error: $e');
      emit(AuthState.error(e.toString()));
    }
  }

  Future<void> signIn(String email, String password) async {
    emit(const AuthState.loading());

    try {
      final user = await _authRepository.signIn(email, password);
      if (user != null) {
        emit(AuthState.authenticated(user));
      } else {
        emit(const AuthState.error('Invalid credentials'));
      }
    } catch (e) {
      logger.e('Sign in error: $e');
      emit(AuthState.error(e.toString()));
    }
  }

  Future<void> signOut() async {
    try {
      await _authRepository.signOut();
      emit(const AuthState.unauthenticated());
    } catch (e) {
      logger.e('Sign out error: $e');
      emit(AuthState.error(e.toString()));
    }
  }
}

@freezed
class AuthState with _$AuthState {
  const factory AuthState.initial() = _Initial;
  const factory AuthState.loading() = _Loading;
  const factory AuthState.authenticated(UserProfile user) = _Authenticated;
  const factory AuthState.unauthenticated() = _Unauthenticated;
  const factory AuthState.error(String message) = _Error;
}


===== lib/features/visits/pages/visit_photos_page.dart =====
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../core/theme/palette.dart';
import '../../../services/media/camera_service.dart';
import '../bloc/visits_cubit.dart';

class VisitPhotosPage extends StatefulWidget {
  final String visitId;

  const VisitPhotosPage({
    super.key,
    required this.visitId,
  });

  @override
  State<VisitPhotosPage> createState() => _VisitPhotosPageState();
}

class _VisitPhotosPageState extends State<VisitPhotosPage> {
  final List<File> _capturedPhotos = [];
  bool _isUploading = false;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Evidencia Fotográfica'),
        actions: [
          TextButton(
            onPressed: _capturedPhotos.isNotEmpty
                ? () => context.push('/visit/signature/${widget.visitId}')
                : null,
            child: Text(
              'Siguiente',
              style: TextStyle(
                color:
                    _capturedPhotos.isNotEmpty ? Colors.white : Colors.white54,
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          // Instructions
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(16),
            color: AppPalette.info.withOpacity(0.1),
            child: const Text(
              'Toma fotos como evidencia de tu visita. Mínimo 1 foto requerida.',
              style: TextStyle(
                fontSize: 14,
                color: AppPalette.info,
              ),
              textAlign: TextAlign.center,
            ),
          ),

          // Photo grid
          Expanded(
            child: _capturedPhotos.isEmpty
                ? _buildEmptyState()
                : _buildPhotoGrid(),
          ),

          // Camera buttons
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.white,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.1),
                  blurRadius: 4,
                  offset: const Offset(0, -2),
                ),
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: ElevatedButton.icon(
                    onPressed: _isUploading ? null : _takePicture,
                    icon: const Icon(Icons.camera_alt),
                    label: const Text('Tomar Foto'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppPalette.primary,
                    ),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: _isUploading ? null : _pickFromGallery,
                    icon: const Icon(Icons.photo_library),
                    label: const Text('Galería'),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState() {
    return const Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.camera_alt_outlined,
            size: 80,
            color: AppPalette.textSecondary,
          ),
          SizedBox(height: 16),
          Text(
            'No hay fotos capturadas',
            style: TextStyle(
              fontSize: 18,
              color: AppPalette.textSecondary,
            ),
          ),
          SizedBox(height: 8),
          Text(
            'Toma fotos como evidencia de tu visita',
            style: TextStyle(
              fontSize: 14,
              color: AppPalette.textDisabled,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildPhotoGrid() {
    return GridView.builder(
      padding: const EdgeInsets.all(16),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
        crossAxisSpacing: 8,
        mainAxisSpacing: 8,
        childAspectRatio: 1,
      ),
      itemCount: _capturedPhotos.length,
      itemBuilder: (context, index) {
        final photo = _capturedPhotos[index];
        return Stack(
          children: [
            Container(
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(8),
                image: DecorationImage(
                  image: FileImage(photo),
                  fit: BoxFit.cover,
                ),
              ),
            ),
            Positioned(
              top: 4,
              right: 4,
              child: Container(
                decoration: const BoxDecoration(
                  color: Colors.black54,
                  shape: BoxShape.circle,
                ),
                child: IconButton(
                  icon: const Icon(
                    Icons.close,
                    color: Colors.white,
                    size: 20,
                  ),
                  onPressed: () => _removePhoto(index),
                ),
              ),
            ),
            Positioned(
              bottom: 4,
              right: 4,
              child: Container(
                decoration: const BoxDecoration(
                  color: Colors.black54,
                  shape: BoxShape.circle,
                ),
                child: IconButton(
                  icon: const Icon(
                    Icons.fullscreen,
                    color: Colors.white,
                    size: 20,
                  ),
                  onPressed: () => _viewPhoto(photo),
                ),
              ),
            ),
          ],
        );
      },
    );
  }

  Future<void> _takePicture() async {
    try {
      final photo = await CameraService.takePicture();
      if (photo != null) {
        setState(() {
          _capturedPhotos.add(photo);
        });
      }
    } catch (e) {
      _showError('Error al tomar foto: $e');
    }
  }

  Future<void> _pickFromGallery() async {
    try {
      final photos = await CameraService.pickMultipleFromGallery();
      if (photos.isNotEmpty) {
        setState(() {
          _capturedPhotos.addAll(photos);
        });
      }
    } catch (e) {
      _showError('Error al seleccionar fotos: $e');
    }
  }

  void _removePhoto(int index) {
    setState(() {
      _capturedPhotos.removeAt(index);
    });
  }

  void _viewPhoto(File photo) {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => PhotoViewPage(photo: photo),
      ),
    );
  }

  void _showError(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: AppPalette.error,
      ),
    );
  }
}

class PhotoViewPage extends StatelessWidget {
  final File photo;

  const PhotoViewPage({super.key, required this.photo});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.black,
        foregroundColor: Colors.white,
      ),
      body: Container(
        color: Colors.black,
        child: Center(
          child: Image.file(photo),
        ),
      ),
    );
  }
}


===== lib/features/visits/pages/visit_signature_page.dart =====
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:signature/signature.dart';
import '../../../core/theme/palette.dart';
import '../../../services/media/signature_service.dart';
import '../bloc/visits_cubit.dart';

class VisitSignaturePage extends StatefulWidget {
  final String visitId;

  const VisitSignaturePage({
    super.key,
    required this.visitId,
  });

  @override
  State<VisitSignaturePage> createState() => _VisitSignaturePageState();
}

class _VisitSignaturePageState extends State<VisitSignaturePage> {
  late SignatureController _signatureController;
  final _signerNameController = TextEditingController();
  Uint8List? _signatureData;

  @override
  void initState() {
    super.initState();
    _signatureController = SignatureService.createController();
  }

  @override
  void dispose() {
    _signatureController.dispose();
    _signerNameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Firma del Cliente'),
        actions: [
          TextButton(
            onPressed: _signatureData != null ? _finishVisit : null,
            child: Text(
              'Finalizar',
              style: TextStyle(
                color: _signatureData != null ? Colors.white : Colors.white54,
              ),
            ),
          ),
        ],
      ),
      body: BlocConsumer<VisitsCubit, VisitsState>(
        listener: (context, state) {
          state.whenOrNull(
            completed: (visit) {
              context.go('/dashboard');
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Visita completada exitosamente'),
                  backgroundColor: AppPalette.success,
                ),
              );
            },
            error: (message) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(message),
                  backgroundColor: AppPalette.error,
                ),
              );
            },
          );
        },
        builder: (context, state) {
          return SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Instructions
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: AppPalette.info.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: AppPalette.info.withOpacity(0.3)),
                  ),
                  child: const Text(
                    'Solicita al cliente que firme en el área designada para confirmar la visita.',
                    style: TextStyle(
                      fontSize: 14,
                      color: AppPalette.info,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ),
                const SizedBox(height: 24),

                // Signer name
                const Text(
                  'Nombre del firmante',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _signerNameController,
                  decoration: const InputDecoration(
                    hintText: 'Nombre completo',
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 24),

                // Signature pad
                const Text(
                  'Firma',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 8),
                Container(
                  height: 250,
                  width: double.infinity,
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.grey),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Signature(
                    controller: _signatureController,
                    backgroundColor: Colors.white,
                  ),
                ),
                const SizedBox(height: 16),

                // Signature controls
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton.icon(
                        onPressed: _clearSignature,
                        icon: const Icon(Icons.clear),
                        label: const Text('Limpiar'),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton.icon(
                        onPressed: _captureSignature,
                        icon: const Icon(Icons.check),
                        label: const Text('Capturar'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppPalette.success,
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),

                // Preview signature
                if (_signatureData != null) ...[
                  const Text(
                    'Firma capturada',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Container(
                    height: 150,
                    width: double.infinity,
                    decoration: BoxDecoration(
                      border: Border.all(color: AppPalette.success),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Image.memory(
                      _signatureData!,
                      fit: BoxFit.contain,
                    ),
                  ),
                  const SizedBox(height: 32),
                ],

                // Finish visit button
                SizedBox(
                  width: double.infinity,
                  height: 48,
                  child: ElevatedButton(
                    onPressed: state.maybeWhen(
                      loading: () => null,
                      orElse: () =>
                          _signatureData != null ? _finishVisit : null,
                    ),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppPalette.success,
                    ),
                    child: state.maybeWhen(
                      loading: () => const SizedBox(
                        height: 20,
                        width: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor:
                              AlwaysStoppedAnimation<Color>(Colors.white),
                        ),
                      ),
                      orElse: () => const Text(
                        'Finalizar Visita',
                        style: TextStyle(fontSize: 16),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }

  Future<void> _captureSignature() async {
    try {
      final signatureData =
          await SignatureService.exportSignature(_signatureController);
      if (signatureData != null) {
        setState(() {
          _signatureData = signatureData;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Firma capturada exitosamente'),
            backgroundColor: AppPalette.success,
          ),
        );
      } else {
        _showError('Por favor, dibuja una firma antes de capturar');
      }
    } catch (e) {
      _showError('Error al capturar firma: $e');
    }
  }

  void _clearSignature() {
    _signatureController.clear();
    setState(() {
      _signatureData = null;
    });
  }

  void _finishVisit() {
    if (_signatureData == null) {
      _showError('Firma requerida para finalizar la visita');
      return;
    }

    if (_signerNameController.text.isEmpty) {
      _showError('Nombre del firmante requerido');
      return;
    }

    context.read<VisitsCubit>().finishVisit(
          visitId: widget.visitId,
          notes: 'Firmado por: ${_signerNameController.text}',
        );
  }

  void _showError(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: AppPalette.error,
      ),
    );
  }
}


===== lib/features/visits/pages/visit_checkin_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../core/theme/palette.dart';
import '../../../data/models/customers/customer.dart';
import '../../../data/models/visits/visit.dart';
import '../bloc/visits_cubit.dart';

class VisitCheckinPage extends StatefulWidget {
  final String customerId;
  final String? purpose;

  const VisitCheckinPage({
    super.key,
    required this.customerId,
    this.purpose,
  });

  @override
  State<VisitCheckinPage> createState() => _VisitCheckinPageState();
}

class _VisitCheckinPageState extends State<VisitCheckinPage> {
  final _notesController = TextEditingController();
  VisitPurpose _selectedPurpose = VisitPurpose.visita;
  Customer? _customer;

  @override
  void initState() {
    super.initState();
    _loadCustomer();
    if (widget.purpose != null) {
      _selectedPurpose = _parseVisitPurpose(widget.purpose!);
    }
  }

  @override
  void dispose() {
    _notesController.dispose();
    super.dispose();
  }

  void _loadCustomer() {
    // TODO: Load customer from repository
    _customer = Customer(
      id: widget.customerId,
      companyId: 'company_id',
      name: 'Cliente Ejemplo',
      address: 'Dirección del cliente',
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Iniciar Visita'),
      ),
      body: BlocConsumer<VisitsCubit, VisitsState>(
        listener: (context, state) {
          state.whenOrNull(
            activeVisit: (visit) {
              context.go('/visit/forms/${visit.id}');
            },
            error: (message) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(message),
                  backgroundColor: AppPalette.error,
                ),
              );
            },
          );
        },
        builder: (context, state) {
          if (_customer == null) {
            return const Center(child: CircularProgressIndicator());
          }

          return SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Customer info card
                Card(
                  child: Padding(
                    padding: const EdgeInsets.all(16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          _customer!.name,
                          style: const TextStyle(
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 8),
                        if (_customer!.address != null) ...[
                          Row(
                            children: [
                              const Icon(Icons.location_on, size: 16),
                              const SizedBox(width: 4),
                              Expanded(child: Text(_customer!.address!)),
                            ],
                          ),
                          const SizedBox(height: 4),
                        ],
                        if (_customer!.phone != null) ...[
                          Row(
                            children: [
                              const Icon(Icons.phone, size: 16),
                              const SizedBox(width: 4),
                              Text(_customer!.phone!),
                            ],
                          ),
                        ],
                      ],
                    ),
                  ),
                ),
                const SizedBox(height: 24),

                // Purpose selection
                const Text(
                  'Propósito de la visita',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 8),
                DropdownButtonFormField<VisitPurpose>(
                  value: _selectedPurpose,
                  decoration: const InputDecoration(
                    border: OutlineInputBorder(),
                  ),
                  items: VisitPurpose.values.map((purpose) {
                    return DropdownMenuItem(
                      value: purpose,
                      child: Text(_getVisitPurposeLabel(purpose)),
                    );
                  }).toList(),
                  onChanged: (value) {
                    if (value != null) {
                      setState(() {
                        _selectedPurpose = value;
                      });
                    }
                  },
                ),
                const SizedBox(height: 16),

                // Notes
                const Text(
                  'Notas (opcional)',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _notesController,
                  maxLines: 3,
                  decoration: const InputDecoration(
                    hintText: 'Agregar notas sobre la visita...',
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 32),

                // Start visit button
                SizedBox(
                  width: double.infinity,
                  height: 48,
                  child: ElevatedButton(
                    onPressed: state.maybeWhen(
                      loading: () => null,
                      orElse: () => _startVisit,
                    ),
                    child: state.maybeWhen(
                      loading: () => const SizedBox(
                        height: 20,
                        width: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor:
                              AlwaysStoppedAnimation<Color>(Colors.white),
                        ),
                      ),
                      orElse: () => const Text(
                        'Iniciar Visita',
                        style: TextStyle(fontSize: 16),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }

  void _startVisit() {
    context.read<VisitsCubit>().startVisit(
          customer: _customer!,
          purpose: _selectedPurpose,
          notes:
              _notesController.text.isNotEmpty ? _notesController.text : null,
        );
  }

  VisitPurpose _parseVisitPurpose(String purpose) {
    switch (purpose.toLowerCase()) {
      case 'venta':
        return VisitPurpose.venta;
      case 'cobro':
        return VisitPurpose.cobro;
      case 'entrega':
        return VisitPurpose.entrega;
      case 'auditoria':
        return VisitPurpose.auditoria;
      case 'devolucion':
        return VisitPurpose.devolucion;
      default:
        return VisitPurpose.visita;
    }
  }

  String _getVisitPurposeLabel(VisitPurpose purpose) {
    switch (purpose) {
      case VisitPurpose.venta:
        return 'Venta';
      case VisitPurpose.cobro:
        return 'Cobro';
      case VisitPurpose.entrega:
        return 'Entrega';
      case VisitPurpose.visita:
        return 'Visita General';
      case VisitPurpose.auditoria:
        return 'Auditoría';
      case VisitPurpose.devolucion:
        return 'Devolución';
      case VisitPurpose.otro:
        return 'Otro';
    }
  }
}


===== lib/features/visits/pages/visit_forms_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../core/theme/palette.dart';
import '../bloc/visits_cubit.dart';

class VisitFormsPage extends StatefulWidget {
  final String visitId;

  const VisitFormsPage({
    super.key,
    required this.visitId,
  });

  @override
  State<VisitFormsPage> createState() => _VisitFormsPageState();
}

class _VisitFormsPageState extends State<VisitFormsPage> {
  final _formKey = GlobalKey<FormState>();
  final Map<String, dynamic> _formData = {};

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Formularios de Visita'),
        actions: [
          TextButton(
            onPressed: () => context.push('/visit/photos/${widget.visitId}'),
            child: const Text(
              'Siguiente',
              style: TextStyle(color: Colors.white),
            ),
          ),
        ],
      ),
      body: BlocBuilder<VisitsCubit, VisitsState>(
        builder: (context, state) {
          return state.maybeWhen(
            activeVisit: (visit) =>
                _buildFormContent(visit.customer?.name ?? 'Cliente'),
            orElse: () => const Center(child: CircularProgressIndicator()),
          );
        },
      ),
    );
  }

  Widget _buildFormContent(String customerName) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Form(
        key: _formKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Customer info
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Row(
                  children: [
                    const Icon(Icons.person, color: AppPalette.primary),
                    const SizedBox(width: 8),
                    Text(
                      customerName,
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 24),

            // Dynamic form fields
            _buildFormSection('Información General', [
              _buildTextFormField(
                'observaciones',
                'Observaciones',
                maxLines: 3,
              ),
              _buildDropdownField(
                'estado_cliente',
                'Estado del Cliente',
                ['Activo', 'Inactivo', 'Prospecto', 'Moroso'],
              ),
              _buildSwitchField(
                'acepta_promociones',
                'Acepta promociones',
              ),
            ]),

            _buildFormSection('Información Comercial', [
              _buildTextFormField(
                'ultimo_pedido',
                'Último Pedido',
                keyboardType: TextInputType.datetime,
              ),
              _buildTextFormField(
                'monto_promedio',
                'Monto Promedio',
                keyboardType: TextInputType.number,
                prefix: '\$',
              ),
              _buildDropdownField(
                'frecuencia_compra',
                'Frecuencia de Compra',
                ['Semanal', 'Quincenal', 'Mensual', 'Trimestral'],
              ),
            ]),

            _buildFormSection('Satisfacción', [
              _buildRatingField(
                'satisfaccion_servicio',
                'Satisfacción con el Servicio',
              ),
              _buildRatingField(
                'satisfaccion_productos',
                'Satisfacción con los Productos',
              ),
              _buildTextFormField(
                'sugerencias',
                'Sugerencias',
                maxLines: 2,
              ),
            ]),

            const SizedBox(height: 32),

            // Continue button
            SizedBox(
              width: double.infinity,
              height: 48,
              child: ElevatedButton(
                onPressed: _saveAndContinue,
                child: const Text('Continuar a Fotos'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFormSection(String title, List<Widget> fields) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
            color: AppPalette.primary,
          ),
        ),
        const SizedBox(height: 16),
        ...fields.map((field) => Padding(
              padding: const EdgeInsets.only(bottom: 16),
              child: field,
            )),
        const SizedBox(height: 16),
      ],
    );
  }

  Widget _buildTextFormField(
    String key,
    String label, {
    TextInputType? keyboardType,
    int maxLines = 1,
    String? prefix,
  }) {
    return TextFormField(
      keyboardType: keyboardType,
      maxLines: maxLines,
      decoration: InputDecoration(
        labelText: label,
        prefixText: prefix,
        border: const OutlineInputBorder(),
      ),
      onSaved: (value) => _formData[key] = value,
    );
  }

  Widget _buildDropdownField(String key, String label, List<String> options) {
    return DropdownButtonFormField<String>(
      decoration: InputDecoration(
        labelText: label,
        border: const OutlineInputBorder(),
      ),
      items: options
          .map((option) => DropdownMenuItem(
                value: option,
                child: Text(option),
              ))
          .toList(),
      onChanged: (value) => _formData[key] = value,
    );
  }

  Widget _buildSwitchField(String key, String label) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(label),
        Switch(
          value: _formData[key] ?? false,
          onChanged: (value) {
            setState(() {
              _formData[key] = value;
            });
          },
        ),
      ],
    );
  }

  Widget _buildRatingField(String key, String label) {
    final rating = _formData[key] ?? 0;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label),
        const SizedBox(height: 8),
        Row(
          children: List.generate(5, (index) {
            return GestureDetector(
              onTap: () {
                setState(() {
                  _formData[key] = index + 1;
                });
              },
              child: Icon(
                index < rating ? Icons.star : Icons.star_border,
                color: AppPalette.warning,
                size: 32,
              ),
            );
          }),
        ),
      ],
    );
  }

  void _saveAndContinue() {
    if (_formKey.currentState?.validate() ?? false) {
      _formKey.currentState?.save();
      // TODO: Save form data
      context.push('/visit/photos/${widget.visitId}');
    }
  }

  VisitPurpose _parseVisitPurpose(String purpose) {
    switch (purpose.toLowerCase()) {
      case 'venta':
        return VisitPurpose.venta;
      case 'cobro':
        return VisitPurpose.cobro;
      case 'entrega':
        return VisitPurpose.entrega;
      case 'auditoria':
        return VisitPurpose.auditoria;
      case 'devolucion':
        return VisitPurpose.devolucion;
      default:
        return VisitPurpose.visita;
    }
  }
}


===== lib/features/visits/bloc/visits_cubit.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:geolocator/geolocator.dart';
import '../../../data/models/visits/visit.dart';
import '../../../data/models/customers/customer.dart';
import '../../../data/repositories/visits_repository.dart';
import '../../../services/location/location_service.dart';
import '../../../config/logger.dart';
import '../../../config/app_constants.dart';

part 'visits_state.dart';
part 'visits_cubit.freezed.dart';

class VisitsCubit extends Cubit<VisitsState> {
  final VisitsRepository _repository;
  final LocationService _locationService;

  VisitsCubit(this._repository, this._locationService)
      : super(const VisitsState.initial());

  Future<void> startVisit({
    required Customer customer,
    required VisitPurpose purpose,
    String? notes,
  }) async {
    emit(const VisitsState.loading());

    try {
      final position = await _locationService.getCurrentLocation();
      if (position == null) {
        emit(const VisitsState.error('No se pudo obtener la ubicación actual'));
        return;
      }

      // Validate geofence
      if (customer.latitude != null && customer.longitude != null) {
        final distance = _locationService.calculateDistance(
          position.latitude,
          position.longitude,
          customer.latitude!,
          customer.longitude!,
        );

        if (distance > AppConstants.defaultGeofenceRadius) {
          emit(VisitsState.error(
              'Estás a ${distance.toStringAsFixed(1)}m del cliente. '
              'Debes estar dentro de ${AppConstants.defaultGeofenceRadius.toInt()}m para iniciar la visita.'));
          return;
        }
      }

      final visit = Visit(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        companyId: customer.companyId,
        customerId: customer.id,
        purpose: purpose,
        startedAt: DateTime.now(),
        checkinLatitude: position.latitude,
        checkinLongitude: position.longitude,
        checkinAccuracyM: position.accuracy,
        notes: notes,
        customer: customer,
      );

      final createdVisit = await _repository.startVisit(visit);
      emit(VisitsState.activeVisit(createdVisit));
    } catch (e) {
      logger.e('Start visit error: $e');
      emit(VisitsState.error(e.toString()));
    }
  }

  Future<void> finishVisit({
    required String visitId,
    String? notes,
  }) async {
    try {
      final currentState = state;
      if (currentState is VisitsActiveVisit) {
        final position = await _locationService.getCurrentLocation();

        final updatedVisit = currentState.visit.copyWith(
          finishedAt: DateTime.now(),
          checkoutLatitude: position?.latitude,
          checkoutLongitude: position?.longitude,
          checkoutAccuracyM: position?.accuracy,
          notes: notes ?? currentState.visit.notes,
        );

        await _repository.finishVisit(updatedVisit);
        emit(VisitsState.completed(updatedVisit));
      }
    } catch (e) {
      logger.e('Finish visit error: $e');
      emit(VisitsState.error(e.toString()));
    }
  }

  Future<void> loadVisitHistory(String customerId) async {
    emit(const VisitsState.loading());

    try {
      final visits = await _repository.getVisitsByCustomer(customerId);
      emit(VisitsState.history(visits));
    } catch (e) {
      logger.e('Load visit history error: $e');
      emit(VisitsState.error(e.toString()));
    }
  }

  void resetState() {
    emit(const VisitsState.initial());
  }
}

@freezed
class VisitsState with _$VisitsState {
  const factory VisitsState.initial() = _Initial;
  const factory VisitsState.loading() = _Loading;
  const factory VisitsState.activeVisit(Visit visit) = VisitsActiveVisit;
  const factory VisitsState.completed(Visit visit) = _Completed;
  const factory VisitsState.history(List<Visit> visits) = _History;
  const factory VisitsState.error(String message) = _Error;
}


===== lib/features/map/pages/live_map_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import '../../../core/theme/palette.dart';
import '../../../data/models/customers/customer.dart';
import '../bloc/map_cubit.dart';
import '../widgets/customer_marker.dart';

class LiveMapPage extends StatefulWidget {
  const LiveMapPage({super.key});

  @override
  State<LiveMapPage> createState() => _LiveMapPageState();
}

class _LiveMapPageState extends State<LiveMapPage> {
  GoogleMapController? _controller;
  Set<Marker> _markers = {};

  @override
  void initState() {
    super.initState();
    context.read<MapCubit>().initializeMap();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Mapa en Vivo'),
        actions: [
          IconButton(
            icon: const Icon(Icons.my_location),
            onPressed: _centerOnCurrentLocation,
          ),
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () => context.read<MapCubit>().initializeMap(),
          ),
        ],
      ),
      body: BlocConsumer<MapCubit, MapState>(
        listener: (context, state) {
          state.whenOrNull(
            error: (message) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(message),
                  backgroundColor: AppPalette.error,
                ),
              );
            },
          );
        },
        builder: (context, state) {
          return state.when(
            initial: () => const Center(child: Text('Inicializando...')),
            loading: () => const Center(child: CircularProgressIndicator()),
            ready: (currentPosition, customers, teamLocations) {
              _updateMarkers(currentPosition, customers, teamLocations);

              return GoogleMap(
                onMapCreated: (GoogleMapController controller) {
                  _controller = controller;
                  context.read<MapCubit>().setMapController(controller);
                },
                initialCameraPosition: CameraPosition(
                  target: currentPosition,
                  zoom: 15.0,
                ),
                markers: _markers,
                myLocationEnabled: true,
                myLocationButtonEnabled: false,
                zoomControlsEnabled: false,
                mapToolbarEnabled: false,
              );
            },
            error: (message) => Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.error_outline,
                    size: 64,
                    color: AppPalette.error,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    message,
                    textAlign: TextAlign.center,
                    style: const TextStyle(fontSize: 16),
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () => context.read<MapCubit>().initializeMap(),
                    child: const Text('Reintentar'),
                  ),
                ],
              ),
            ),
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // Navigate to customer selection for visit
        },
        child: const Icon(Icons.add_location),
      ),
    );
  }

  void _updateMarkers(
    LatLng currentPosition,
    List<Customer> customers,
    List<dynamic> teamLocations,
  ) {
    final markers = <Marker>{};

    // Customer markers
    for (final customer in customers) {
      if (customer.latitude != null && customer.longitude != null) {
        markers.add(
          Marker(
            markerId: MarkerId('customer_${customer.id}'),
            position: LatLng(customer.latitude!, customer.longitude!),
            icon:
                BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueBlue),
            infoWindow: InfoWindow(
              title: customer.name,
              snippet: customer.address,
            ),
            onTap: () => _onCustomerMarkerTap(customer),
          ),
        );
      }
    }

    setState(() {
      _markers = markers;
    });
  }

  void _onCustomerMarkerTap(Customer customer) {
    showModalBottomSheet(
      context: context,
      builder: (context) => CustomerBottomSheet(customer: customer),
    );
  }

  void _centerOnCurrentLocation() {
    final state = context.read<MapCubit>().state;
    if (state is MapReady && _controller != null) {
      _controller!.animateCamera(
        CameraUpdate.newLatLng(state.currentPosition),
      );
    }
  }
}

class CustomerBottomSheet extends StatelessWidget {
  final Customer customer;

  const CustomerBottomSheet({
    super.key,
    required this.customer,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            customer.name,
            style: const TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          if (customer.address != null) ...[
            Row(
              children: [
                const Icon(Icons.location_on, size: 16),
                const SizedBox(width: 4),
                Expanded(child: Text(customer.address!)),
              ],
            ),
            const SizedBox(height: 4),
          ],
          if (customer.phone != null) ...[
            Row(
              children: [
                const Icon(Icons.phone, size: 16),
                const SizedBox(width: 4),
                Text(customer.phone!),
              ],
            ),
            const SizedBox(height: 16),
          ],

          // Action buttons
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _ActionButton(
                icon: Icons.visibility,
                label: 'Visita',
                color: AppPalette.info,
                onTap: () => _startVisit(context, VisitPurpose.visita),
              ),
              _ActionButton(
                icon: Icons.shopping_cart,
                label: 'Venta',
                color: AppPalette.success,
                onTap: () => _startVisit(context, VisitPurpose.venta),
              ),
              _ActionButton(
                icon: Icons.payment,
                label: 'Cobro',
                color: AppPalette.warning,
                onTap: () => _startVisit(context, VisitPurpose.cobro),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void _startVisit(BuildContext context, VisitPurpose purpose) {
    Navigator.of(context).pop();
    context.push('/visit/checkin/${customer.id}?purpose=${purpose.name}');
  }
}

class _ActionButton extends StatelessWidget {
  final IconData icon;
  final String label;
  final Color color;
  final VoidCallback onTap;

  const _ActionButton({
    required this.icon,
    required this.label,
    required this.color,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: color),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: color, size: 24),
            const SizedBox(height: 4),
            Text(
              label,
              style: TextStyle(
                color: color,
                fontSize: 12,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===== lib/features/map/widgets/route_layer.dart =====
import 'dart:async';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import '../../../data/models/routes/route_plan.dart';
import '../../../data/models/customers/customer.dart';
import '../../../core/theme/palette.dart';
import '../../../core/utils/geoutils.dart';

class RouteLayerService {
  /// Create polylines for a route plan
  static Set<Polyline> createRoutePolylines({
    required RoutePlan routePlan,
    Color? routeColor,
  }) {
    final polylines = <Polyline>{};

    if (routePlan.stops.length < 2) return polylines;

    // Sort stops by sequence
    final sortedStops = List<RouteStop>.from(routePlan.stops)
      ..sort((a, b) => (a.sequence ?? 0).compareTo(b.sequence ?? 0));

    final routePoints = <LatLng>[];

    for (final stop in sortedStops) {
      if (stop.customer?.latitude != null && stop.customer?.longitude != null) {
        routePoints.add(LatLng(
          stop.customer!.latitude!,
          stop.customer!.longitude!,
        ));
      }
    }

    if (routePoints.length < 2) return polylines;

    // Main route polyline
    polylines.add(Polyline(
      polylineId: PolylineId('route_${routePlan.id}'),
      points: routePoints,
      color: routeColor ?? AppPalette.primary,
      width: 4,
      patterns: [PatternItem.solid],
    ));

    // Add segment polylines with different colors for completed/pending
    for (int i = 0; i < routePoints.length - 1; i++) {
      final segment = [routePoints[i], routePoints[i + 1]];
      final stop = sortedStops[i];

      // Determine segment color based on visit completion
      Color segmentColor = AppPalette.textSecondary; // Default: not visited

      if (stop.customer != null) {
        // TODO: Check if this stop has been visited
        // For now, use different logic
        segmentColor = AppPalette.primary;
      }

      polylines.add(Polyline(
        polylineId: PolylineId('segment_${routePlan.id}_$i'),
        points: segment,
        color: segmentColor,
        width: 3,
        patterns: [PatternItem.solid],
      ));
    }

    return polylines;
  }

  /// Create markers for route stops
  static Future<Set<Marker>> createRouteStopMarkers({
    required List<RouteStop> stops,
    required Function(RouteStop) onStopTap,
  }) async {
    final markers = <Marker>{};

    for (int i = 0; i < stops.length; i++) {
      final stop = stops[i];

      if (stop.customer?.latitude == null || stop.customer?.longitude == null) {
        continue;
      }

      final marker = await _createRouteStopMarker(
        stop: stop,
        sequence: i + 1,
        onTap: () => onStopTap(stop),
      );

      markers.add(marker);
    }

    return markers;
  }

  /// Create a single route stop marker
  static Future<Marker> _createRouteStopMarker({
    required RouteStop stop,
    required int sequence,
    required VoidCallback onTap,
  }) async {
    final icon = await _createSequenceIcon(
      sequence: sequence,
      isCompleted: false, // TODO: Check if stop is completed
      isPending: true,
    );

    return Marker(
      markerId: MarkerId('route_stop_${stop.id}'),
      position: LatLng(
        stop.customer!.latitude!,
        stop.customer!.longitude!,
      ),
      icon: icon,
      infoWindow: InfoWindow(
        title: '${sequence}. ${stop.customer?.name ?? 'Cliente'}',
        snippet: stop.plannedTime != null
            ? 'Programado: ${_formatTime(stop.plannedTime!)}'
            : 'Sin horario programado',
        onTap: onTap,
      ),
      onTap: onTap,
    );
  }

  /// Create navigation polyline between two points
  static Future<Polyline?> createNavigationPolyline({
    required LatLng origin,
    required LatLng destination,
    Color? color,
  }) async {
    try {
      // In a real implementation, you would use Google Directions API
      // For now, create a simple straight line
      final points = [origin, destination];

      return Polyline(
        polylineId: const PolylineId('navigation'),
        points: points,
        color: color ?? AppPalette.info,
        width: 5,
        patterns: [
          PatternItem.dash(20),
          PatternItem.gap(10),
        ],
      );
    } catch (e) {
      return null;
    }
  }

  /// Create optimized route polylines
  static Set<Polyline> createOptimizedRoute({
    required List<LatLng> waypoints,
    required LatLng currentLocation,
    Color? routeColor,
  }) {
    final polylines = <Polyline>{};

    if (waypoints.isEmpty) return polylines;

    // Simple optimization: nearest neighbor
    final optimizedWaypoints = _optimizeRoute(currentLocation, waypoints);

    // Add current location as starting point
    final allPoints = [currentLocation, ...optimizedWaypoints];

    polylines.add(Polyline(
      polylineId: const PolylineId('optimized_route'),
      points: allPoints,
      color: routeColor ?? AppPalette.success,
      width: 4,
      patterns: [PatternItem.solid],
    ));

    return polylines;
  }

  /// Simple route optimization using nearest neighbor algorithm
  static List<LatLng> _optimizeRoute(LatLng start, List<LatLng> waypoints) {
    final unvisited = List<LatLng>.from(waypoints);
    final optimized = <LatLng>[];
    LatLng current = start;

    while (unvisited.isNotEmpty) {
      double minDistance = double.infinity;
      int nearestIndex = 0;

      for (int i = 0; i < unvisited.length; i++) {
        final distance = GeoUtils.calculateDistance(
          current.latitude,
          current.longitude,
          unvisited[i].latitude,
          unvisited[i].longitude,
        );

        if (distance < minDistance) {
          minDistance = distance;
          nearestIndex = i;
        }
      }

      current = unvisited.removeAt(nearestIndex);
      optimized.add(current);
    }

    return optimized;
  }

  /// Create sequence number icon for route stops
  static Future<BitmapDescriptor> _createSequenceIcon({
    required int sequence,
    required bool isCompleted,
    required bool isPending,
  }) async {
    const size = 48.0;
    final pictureRecorder = ui.PictureRecorder();
    final canvas = Canvas(pictureRecorder);

    Color backgroundColor;
    Color textColor = Colors.white;

    if (isCompleted) {
      backgroundColor = AppPalette.success;
    } else if (isPending) {
      backgroundColor = AppPalette.warning;
    } else {
      backgroundColor = AppPalette.textSecondary;
    }

    // Draw background circle
    final backgroundPaint = Paint()
      ..color = backgroundColor
      ..style = PaintingStyle.fill;

    final borderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3;

    final center = Offset(size / 2, size / 2);
    final radius = size / 2 - 2;

    canvas.drawCircle(center, radius, backgroundPaint);
    canvas.drawCircle(center, radius, borderPaint);

    // Draw sequence number
    final textPainter = TextPainter(textDirection: ui.TextDirection.ltr);
    textPainter.text = TextSpan(
      text: sequence.toString(),
      style: TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.bold,
        color: textColor,
      ),
    );

    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        (size - textPainter.width) / 2,
        (size - textPainter.height) / 2,
      ),
    );

    final picture = pictureRecorder.endRecording();
    final image = await picture.toImage(size.toInt(), size.toInt());
    final bytes = await image.toByteData(format: ui.ImageByteFormat.png);

    return BitmapDescriptor.fromBytes(bytes!.buffer.asUint8List());
  }

  /// Calculate route statistics
  static RouteStatistics calculateRouteStatistics({
    required List<RouteStop> stops,
    LatLng? currentLocation,
  }) {
    if (stops.isEmpty) {
      return const RouteStatistics(
        totalDistance: 0,
        estimatedDuration: Duration.zero,
        completedStops: 0,
        pendingStops: 0,
      );
    }

    final validStops = stops
        .where((stop) =>
            stop.customer?.latitude != null && stop.customer?.longitude != null)
        .toList();

    if (validStops.isEmpty) {
      return const RouteStatistics(
        totalDistance: 0,
        estimatedDuration: Duration.zero,
        completedStops: 0,
        pendingStops: validStops.length,
      );
    }

    double totalDistance = 0;
    int completedStops = 0;
    int pendingStops = validStops.length;

    // Calculate distances between consecutive stops
    LatLng? previousPoint = currentLocation;

    for (final stop in validStops) {
      final stopLocation = LatLng(
        stop.customer!.latitude!,
        stop.customer!.longitude!,
      );

      if (previousPoint != null) {
        totalDistance += GeoUtils.calculateDistance(
          previousPoint.latitude,
          previousPoint.longitude,
          stopLocation.latitude,
          stopLocation.longitude,
        );
      }

      previousPoint = stopLocation;

      // TODO: Check if stop is completed
      // For now, assume all are pending
    }

    // Estimate duration (average 30 km/h + 15 minutes per stop)
    final travelTime =
        Duration(milliseconds: (totalDistance / 30000 * 3600 * 1000).round());
    final stopTime = Duration(minutes: validStops.length * 15);
    final estimatedDuration = travelTime + stopTime;

    return RouteStatistics(
      totalDistance: totalDistance,
      estimatedDuration: estimatedDuration,
      completedStops: completedStops,
      pendingStops: pendingStops,
    );
  }

  /// Create route bounds that include all stops
  static LatLngBounds? createRouteBounds(List<RouteStop> stops) {
    final validLocations = stops
        .where((stop) =>
            stop.customer?.latitude != null && stop.customer?.longitude != null)
        .map((stop) =>
            LatLng(stop.customer!.latitude!, stop.customer!.longitude!))
        .toList();

    if (validLocations.isEmpty) return null;

    return GeoUtils.getBounds(validLocations);
  }

  /// Format time for display
  static String _formatTime(DateTime dateTime) {
    return '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }
}

class RouteStatistics {
  final double totalDistance; // in meters
  final Duration estimatedDuration;
  final int completedStops;
  final int pendingStops;

  const RouteStatistics({
    required this.totalDistance,
    required this.estimatedDuration,
    required this.completedStops,
    required this.pendingStops,
  });

  String get formattedDistance {
    if (totalDistance < 1000) {
      return '${totalDistance.toStringAsFixed(0)} m';
    } else {
      return '${(totalDistance / 1000).toStringAsFixed(1)} km';
    }
  }

  String get formattedDuration {
    final hours = estimatedDuration.inHours;
    final minutes = estimatedDuration.inMinutes % 60;

    if (hours > 0) {
      return '${hours}h ${minutes}m';
    } else {
      return '${minutes}m';
    }
  }

  int get totalStops => completedStops + pendingStops;

  double get completionPercentage {
    if (totalStops == 0) return 0;
    return (completedStops / totalStops) * 100;
  }
}

// Helper widget for route information display
class RouteInfoWidget extends StatelessWidget {
  final RouteStatistics statistics;
  final VoidCallback? onOptimize;
  final VoidCallback? onStartNavigation;

  const RouteInfoWidget({
    super.key,
    required this.statistics,
    this.onOptimize,
    this.onStartNavigation,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Información de Ruta',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                if (onOptimize != null)
                  TextButton.icon(
                    onPressed: onOptimize,
                    icon: const Icon(Icons.route),
                    label: const Text('Optimizar'),
                  ),
              ],
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: _buildStatItem(
                    'Distancia',
                    statistics.formattedDistance,
                    Icons.straighten,
                  ),
                ),
                Expanded(
                  child: _buildStatItem(
                    'Tiempo Est.',
                    statistics.formattedDuration,
                    Icons.access_time,
                  ),
                ),
                Expanded(
                  child: _buildStatItem(
                    'Paradas',
                    '${statistics.completedStops}/${statistics.totalStops}',
                    Icons.location_on,
                  ),
                ),
              ],
            ),
            if (statistics.totalStops > 0) ...[
              const SizedBox(height: 16),
              LinearProgressIndicator(
                value: statistics.completionPercentage / 100,
                backgroundColor: AppPalette.textSecondary.withOpacity(0.3),
                valueColor: AlwaysStoppedAnimation<Color>(AppPalette.success),
              ),
              const SizedBox(height: 8),
              Text(
                '${statistics.completionPercentage.toStringAsFixed(1)}% completado',
                style: const TextStyle(
                  fontSize: 12,
                  color: AppPalette.textSecondary,
                ),
              ),
            ],
            if (onStartNavigation != null) ...[
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  onPressed: onStartNavigation,
                  icon: const Icon(Icons.navigation),
                  label: const Text('Iniciar Navegación'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppPalette.primary,
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildStatItem(String label, String value, IconData icon) {
    return Column(
      children: [
        Icon(icon, color: AppPalette.primary, size: 24),
        const SizedBox(height: 4),
        Text(
          value,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: const TextStyle(
            fontSize: 12,
            color: AppPalette.textSecondary,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }
}


===== lib/features/map/widgets/customer_marker.dart =====
import 'dart:typed_data';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import '../../../data/models/customers/customer.dart';
import '../../../data/models/visits/visit.dart';
import '../../../core/theme/palette.dart';

class CustomerMarkerService {
  static final Map<String, BitmapDescriptor> _cachedIcons = {};

  /// Create a marker for a customer
  static Future<Marker> createCustomerMarker({
    required Customer customer,
    required VoidCallback onTap,
    bool hasActiveVisit = false,
    bool hasUncompletedOrders = false,
    CustomerStatus status = CustomerStatus.active,
  }) async {
    if (customer.latitude == null || customer.longitude == null) {
      throw ArgumentError('Customer must have valid coordinates');
    }

    final icon = await _getCustomerIcon(
      status: status,
      hasActiveVisit: hasActiveVisit,
      hasUncompletedOrders: hasUncompletedOrders,
    );

    return Marker(
      markerId: MarkerId('customer_${customer.id}'),
      position: LatLng(customer.latitude!, customer.longitude!),
      icon: icon,
      infoWindow: InfoWindow(
        title: customer.name,
        snippet: customer.address ?? 'Sin dirección',
        onTap: onTap,
      ),
      onTap: onTap,
    );
  }

  /// Create a marker for team member location
  static Future<Marker> createTeamMemberMarker({
    required String userId,
    required String userName,
    required double latitude,
    required double longitude,
    required DateTime lastUpdate,
    bool isActive = true,
  }) async {
    final icon = await _getTeamMemberIcon(isActive: isActive);

    return Marker(
      markerId: MarkerId('team_$userId'),
      position: LatLng(latitude, longitude),
      icon: icon,
      infoWindow: InfoWindow(
        title: userName,
        snippet: 'Actualizado: ${_formatTime(lastUpdate)}',
      ),
    );
  }

  /// Create a marker for visit location
  static Future<Marker> createVisitMarker({
    required Visit visit,
    required VoidCallback onTap,
  }) async {
    if (visit.checkinLatitude == null || visit.checkinLongitude == null) {
      throw ArgumentError('Visit must have check-in coordinates');
    }

    final icon = await _getVisitIcon(
      purpose: visit.purpose,
      isCompleted: visit.finishedAt != null,
    );

    return Marker(
      markerId: MarkerId('visit_${visit.id}'),
      position: LatLng(visit.checkinLatitude!, visit.checkinLongitude!),
      icon: icon,
      infoWindow: InfoWindow(
        title: 'Visita - ${_getVisitPurposeLabel(visit.purpose)}',
        snippet: visit.customer?.name ?? 'Cliente',
        onTap: onTap,
      ),
      onTap: onTap,
    );
  }

  /// Get customer icon based on status
  static Future<BitmapDescriptor> _getCustomerIcon({
    required CustomerStatus status,
    required bool hasActiveVisit,
    required bool hasUncompletedOrders,
  }) async {
    final key =
        'customer_${status.name}_${hasActiveVisit}_$hasUncompletedOrders';

    if (_cachedIcons.containsKey(key)) {
      return _cachedIcons[key]!;
    }

    Color iconColor;
    IconData iconData = Icons.business;

    if (hasActiveVisit) {
      iconColor = AppPalette.warning;
      iconData = Icons.location_on;
    } else if (hasUncompletedOrders) {
      iconColor = AppPalette.info;
      iconData = Icons.shopping_cart;
    } else {
      switch (status) {
        case CustomerStatus.active:
          iconColor = AppPalette.success;
          break;
        case CustomerStatus.inactive:
          iconColor = AppPalette.textSecondary;
          break;
        case CustomerStatus.blocked:
          iconColor = AppPalette.error;
          break;
        case CustomerStatus.prospect:
          iconColor = AppPalette.primary;
          break;
      }
    }

    final icon = await _createCustomIcon(
      icon: iconData,
      color: iconColor,
      size: 48,
    );

    _cachedIcons[key] = icon;
    return icon;
  }

  /// Get team member icon
  static Future<BitmapDescriptor> _getTeamMemberIcon({
    required bool isActive,
  }) async {
    final key = 'team_member_$isActive';

    if (_cachedIcons.containsKey(key)) {
      return _cachedIcons[key]!;
    }

    final icon = await _createCustomIcon(
      icon: Icons.person_pin_circle,
      color: isActive ? AppPalette.vendedor : AppPalette.textSecondary,
      size: 48,
    );

    _cachedIcons[key] = icon;
    return icon;
  }

  /// Get visit icon based on purpose
  static Future<BitmapDescriptor> _getVisitIcon({
    required VisitPurpose purpose,
    required bool isCompleted,
  }) async {
    final key = 'visit_${purpose.name}_$isCompleted';

    if (_cachedIcons.containsKey(key)) {
      return _cachedIcons[key]!;
    }

    IconData iconData;
    Color baseColor;

    switch (purpose) {
      case VisitPurpose.venta:
        iconData = Icons.shopping_cart;
        baseColor = AppPalette.success;
        break;
      case VisitPurpose.cobro:
        iconData = Icons.payment;
        baseColor = AppPalette.warning;
        break;
      case VisitPurpose.entrega:
        iconData = Icons.local_shipping;
        baseColor = AppPalette.info;
        break;
      case VisitPurpose.auditoria:
        iconData = Icons.assignment;
        baseColor = AppPalette.primary;
        break;
      case VisitPurpose.devolucion:
        iconData = Icons.keyboard_return;
        baseColor = AppPalette.error;
        break;
      default:
        iconData = Icons.location_on;
        baseColor = AppPalette.textSecondary;
    }

    final color = isCompleted ? baseColor : baseColor.withOpacity(0.6);

    final icon = await _createCustomIcon(
      icon: iconData,
      color: color,
      size: 40,
    );

    _cachedIcons[key] = icon;
    return icon;
  }

  /// Create custom icon from IconData
  static Future<BitmapDescriptor> _createCustomIcon({
    required IconData icon,
    required Color color,
    required double size,
  }) async {
    final pictureRecorder = ui.PictureRecorder();
    final canvas = Canvas(pictureRecorder);

    // Draw background circle
    final backgroundPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill;

    final borderPaint = Paint()
      ..color = color
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3;

    final center = Offset(size / 2, size / 2);
    final radius = size / 2 - 2;

    canvas.drawCircle(center, radius, backgroundPaint);
    canvas.drawCircle(center, radius, borderPaint);

    // Draw icon
    final textPainter = TextPainter(textDirection: TextDirection.ltr);
    textPainter.text = TextSpan(
      text: String.fromCharCode(icon.codePoint),
      style: TextStyle(
        fontSize: size * 0.6,
        fontFamily: icon.fontFamily,
        color: color,
      ),
    );

    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        (size - textPainter.width) / 2,
        (size - textPainter.height) / 2,
      ),
    );

    final picture = pictureRecorder.endRecording();
    final image = await picture.toImage(size.toInt(), size.toInt());
    final bytes = await image.toByteData(format: ui.ImageByteFormat.png);

    return BitmapDescriptor.fromBytes(bytes!.buffer.asUint8List());
  }

  /// Create cluster marker for multiple customers
  static Future<BitmapDescriptor> createClusterIcon({
    required int count,
    required Color color,
  }) async {
    final key = 'cluster_${count}_${color.value}';

    if (_cachedIcons.containsKey(key)) {
      return _cachedIcons[key]!;
    }

    const size = 60.0;
    final pictureRecorder = ui.PictureRecorder();
    final canvas = Canvas(pictureRecorder);

    // Draw background circle
    final backgroundPaint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    final borderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3;

    final center = Offset(size / 2, size / 2);
    final radius = size / 2 - 2;

    canvas.drawCircle(center, radius, backgroundPaint);
    canvas.drawCircle(center, radius, borderPaint);

    // Draw count text
    final textPainter = TextPainter(textDirection: TextDirection.ltr);
    textPainter.text = TextSpan(
      text: count.toString(),
      style: const TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.bold,
        color: Colors.white,
      ),
    );

    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        (size - textPainter.width) / 2,
        (size - textPainter.height) / 2,
      ),
    );

    final picture = pictureRecorder.endRecording();
    final image = await picture.toImage(size.toInt(), size.toInt());
    final bytes = await image.toByteData(format: ui.ImageByteFormat.png);

    final icon = BitmapDescriptor.fromBytes(bytes!.buffer.asUint8List());
    _cachedIcons[key] = icon;
    return icon;
  }

  /// Get geofence circle overlay
  static Circle createGeofenceCircle({
    required String id,
    required LatLng center,
    required double radiusMeters,
    Color? strokeColor,
    Color? fillColor,
  }) {
    return Circle(
      circleId: CircleId('geofence_$id'),
      center: center,
      radius: radiusMeters,
      strokeWidth: 2,
      strokeColor: strokeColor ?? AppPalette.primary,
      fillColor: (fillColor ?? AppPalette.primary).withOpacity(0.2),
    );
  }

  /// Clear cached icons
  static void clearCache() {
    _cachedIcons.clear();
  }

  static String _getVisitPurposeLabel(VisitPurpose purpose) {
    switch (purpose) {
      case VisitPurpose.venta:
        return 'Venta';
      case VisitPurpose.cobro:
        return 'Cobro';
      case VisitPurpose.entrega:
        return 'Entrega';
      case VisitPurpose.visita:
        return 'Visita';
      case VisitPurpose.auditoria:
        return 'Auditoría';
      case VisitPurpose.devolucion:
        return 'Devolución';
      case VisitPurpose.otro:
        return 'Otro';
    }
  }

  static String _formatTime(DateTime dateTime) {
    return '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }
}

enum CustomerStatus {
  active,
  inactive,
  blocked,
  prospect,
}


===== lib/features/map/bloc/map_cubit.dart =====
import 'dart:async';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:geolocator/geolocator.dart';
import '../../../data/models/geo/location_sample.dart';
import '../../../data/models/customers/customer.dart';
import '../../../services/location/location_service.dart';
import '../../../data/repositories/tracking_repository.dart';
import '../../../config/logger.dart';

part 'map_state.dart';
part 'map_cubit.freezed.dart';

class MapCubit extends Cubit<MapState> {
  final LocationService _locationService;
  final TrackingRepository _trackingRepository;

  MapCubit(this._locationService, this._trackingRepository)
      : super(const MapState.initial());

  StreamSubscription<Position>? _locationSubscription;
  GoogleMapController? _mapController;

  Future<void> initializeMap() async {
    emit(const MapState.loading());

    try {
      final hasPermission = await _locationService.requestPermissions();
      if (!hasPermission) {
        emit(const MapState.error('Permisos de ubicación requeridos'));
        return;
      }

      final position = await _locationService.getCurrentLocation();
      if (position == null) {
        emit(const MapState.error('No se pudo obtener la ubicación'));
        return;
      }

      emit(MapState.ready(
        currentPosition: LatLng(position.latitude, position.longitude),
        customers: [],
        teamLocations: [],
      ));

      _startLocationTracking();
    } catch (e) {
      logger.e('Initialize map error: $e');
      emit(MapState.error(e.toString()));
    }
  }

  void _startLocationTracking() {
    _locationSubscription = _locationService.locationStream.listen(
      (position) {
        final currentState = state;
        if (currentState is MapReady) {
          final newPosition = LatLng(position.latitude, position.longitude);
          emit(currentState.copyWith(currentPosition: newPosition));

          // Save tracking data
          _saveLocationSample(position);

          // Update map camera
          _mapController?.animateCamera(
            CameraUpdate.newLatLng(newPosition),
          );
        }
      },
      onError: (error) {
        logger.e('Location tracking error: $error');
      },
    );
  }

  Future<void> _saveLocationSample(Position position) async {
    try {
      // This would get the current user ID from auth
      const userId = 'current_user_id'; // TODO: Get from auth
      const companyId = 'current_company_id'; // TODO: Get from auth

      final sample = LocationSample(
        id: DateTime.now().millisecondsSinceEpoch,
        companyId: companyId,
        userId: userId,
        at: DateTime.now(),
        latitude: position.latitude,
        longitude: position.longitude,
        speedMs: position.speed,
        accuracyM: position.accuracy,
      );

      await _trackingRepository.saveLocationSample(sample);
    } catch (e) {
      logger.e('Save location sample error: $e');
    }
  }

  void updateCustomers(List<Customer> customers) {
    final currentState = state;
    if (currentState is MapReady) {
      emit(currentState.copyWith(customers: customers));
    }
  }

  void updateTeamLocations(List<LocationSample> locations) {
    final currentState = state;
    if (currentState is MapReady) {
      emit(currentState.copyWith(teamLocations: locations));
    }
  }

  void setMapController(GoogleMapController controller) {
    _mapController = controller;
  }

  @override
  Future<void> close() {
    _locationSubscription?.cancel();
    return super.close();
  }
}

@freezed
class MapState with _$MapState {
  const factory MapState.initial() = _Initial;
  const factory MapState.loading() = _Loading;
  const factory MapState.ready({
    required LatLng currentPosition,
    required List<Customer> customers,
    required List<LocationSample> teamLocations,
  }) = MapReady;
  const factory MapState.error(String message) = _Error;
}


===== lib/features/orders/pages/cart_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../core/theme/palette.dart';
import '../../../data/models/sales/order.dart';
import '../bloc/order_cubit.dart';

class CartPage extends StatelessWidget {
  final String customerId;

  const CartPage({
    super.key,
    required this.customerId,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Carrito de Compras'),
        actions: [
          BlocBuilder<OrderCubit, OrderState>(
            builder: (context, state) {
              return TextButton(
                onPressed: state.maybeWhen(
                  editing: (order) =>
                      order.items.isNotEmpty ? () => _saveOrder(context) : null,
                  orElse: () => null,
                ),
                child: const Text(
                  'Guardar',
                  style: TextStyle(color: Colors.white),
                ),
              );
            },
          ),
        ],
      ),
      body: BlocConsumer<OrderCubit, OrderState>(
        listener: (context, state) {
          state.whenOrNull(
            saved: (order) {
              context.pop();
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Pedido guardado exitosamente'),
                  backgroundColor: AppPalette.success,
                ),
              );
            },
            error: (message) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(message),
                  backgroundColor: AppPalette.error,
                ),
              );
            },
          );
        },
        builder: (context, state) {
          return state.when(
            initial: () {
              // Auto-create new order
              WidgetsBinding.instance.addPostFrameCallback((_) {
                context.read<OrderCubit>().createNewOrder(customerId);
              });
              return const Center(child: CircularProgressIndicator());
            },
            loading: () => const Center(child: CircularProgressIndicator()),
            editing: (order) => _buildCartContent(context, order),
            saving: () => const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CircularProgressIndicator(),
                  SizedBox(height: 16),
                  Text('Guardando pedido...'),
                ],
              ),
            ),
            saved: (order) => _buildOrderSaved(order),
            error: (message) => Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.error_outline,
                    size: 64,
                    color: AppPalette.error,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    message,
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
          );
        },
      ),
      floatingActionButton: BlocBuilder<OrderCubit, OrderState>(
        builder: (context, state) {
          return state.maybeWhen(
            editing: (order) => FloatingActionButton(
              onPressed: () => _showProductSelector(context),
              child: const Icon(Icons.add),
            ),
            orElse: () => const SizedBox.shrink(),
          );
        },
      ),
    );
  }

  Widget _buildCartContent(BuildContext context, Order order) {
    if (order.items.isEmpty) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.shopping_cart_outlined,
              size: 80,
              color: AppPalette.textSecondary,
            ),
            SizedBox(height: 16),
            Text(
              'Carrito vacío',
              style: TextStyle(
                fontSize: 18,
                color: AppPalette.textSecondary,
              ),
            ),
            SizedBox(height: 8),
            Text(
              'Agrega productos usando el botón +',
              style: TextStyle(
                fontSize: 14,
                color: AppPalette.textDisabled,
              ),
            ),
          ],
        ),
      );
    }

    return Column(
      children: [
        // Items list
        Expanded(
          child: ListView.builder(
            padding: const EdgeInsets.all(16),
            itemCount: order.items.length,
            itemBuilder: (context, index) {
              final item = order.items[index];
              return CartItemTile(
                item: item,
                onQuantityChanged: (newQty) {
                  context
                      .read<OrderCubit>()
                      .updateItemQuantity(item.id, newQty);
                },
                onRemove: () {
                  context.read<OrderCubit>().removeItem(item.id);
                },
              );
            },
          ),
        ),

        // Order summary
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Colors.white,
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.1),
                blurRadius: 4,
                offset: const Offset(0, -2),
              ),
            ],
          ),
          child: Column(
            children: [
              _buildSummaryRow(
                  'Subtotal:', '\$${order.subtotal.toStringAsFixed(2)}'),
              if (order.discountTotal > 0) ...[
                const SizedBox(height: 4),
                _buildSummaryRow('Descuento:',
                    '-\$${order.discountTotal.toStringAsFixed(2)}'),
              ],
              if (order.taxTotal > 0) ...[
                const SizedBox(height: 4),
                _buildSummaryRow(
                    'Impuestos:', '\$${order.taxTotal.toStringAsFixed(2)}'),
              ],
              const Divider(),
              _buildSummaryRow(
                'Total:',
                '\$${order.grandTotal.toStringAsFixed(2)}',
                isTotal: true,
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildSummaryRow(String label, String value, {bool isTotal = false}) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          label,
          style: TextStyle(
            fontSize: isTotal ? 18 : 14,
            fontWeight: isTotal ? FontWeight.bold : FontWeight.normal,
          ),
        ),
        Text(
          value,
          style: TextStyle(
            fontSize: isTotal ? 18 : 14,
            fontWeight: isTotal ? FontWeight.bold : FontWeight.normal,
            color: isTotal ? AppPalette.primary : null,
          ),
        ),
      ],
    );
  }

  Widget _buildOrderSaved(Order order) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(
            Icons.check_circle_outline,
            size: 80,
            color: AppPalette.success,
          ),
          const SizedBox(height: 16),
          const Text(
            'Pedido Guardado',
            style: TextStyle(
              fontSize: 24,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Total: \$${order.grandTotal.toStringAsFixed(2)}',
            style: const TextStyle(
              fontSize: 18,
              color: AppPalette.primary,
            ),
          ),
          const SizedBox(height: 32),
          ElevatedButton(
            onPressed: () => context.go('/dashboard'),
            child: const Text('Volver al Inicio'),
          ),
        ],
      ),
    );
  }

  void _showProductSelector(BuildContext context) {
    // TODO: Implement product selector
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => const ProductSelectorSheet(),
    );
  }

  void _saveOrder(BuildContext context) {
    context.read<OrderCubit>().saveOrder();
  }
}

class CartItemTile extends StatelessWidget {
  final OrderItem item;
  final Function(double) onQuantityChanged;
  final VoidCallback onRemove;

  const CartItemTile({
    super.key,
    required this.item,
    required this.onQuantityChanged,
    required this.onRemove,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          children: [
            // Product info
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    item.product?.name ?? 'Producto',
                    style: const TextStyle(
                      fontWeight: FontWeight.w500,
                      fontSize: 16,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Precio: \$${item.price.toStringAsFixed(2)}',
                    style: const TextStyle(
                      color: AppPalette.textSecondary,
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),

            // Quantity controls
            Row(
              children: [
                IconButton(
                  onPressed: item.qty > 1
                      ? () => onQuantityChanged(item.qty - 1)
                      : null,
                  icon: const Icon(Icons.remove_circle_outline),
                  color: AppPalette.error,
                ),
                Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.grey),
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    item.qty.toStringAsFixed(0),
                    style: const TextStyle(fontSize: 16),
                  ),
                ),
                IconButton(
                  onPressed: () => onQuantityChanged(item.qty + 1),
                  icon: const Icon(Icons.add_circle_outline),
                  color: AppPalette.success,
                ),
              ],
            ),

            // Total and remove
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  '\$${item.total.toStringAsFixed(2)}',
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                  ),
                ),
                IconButton(
                  onPressed: onRemove,
                  icon: const Icon(Icons.delete_outline),
                  color: AppPalette.error,
                  iconSize: 20,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class ProductSelectorSheet extends StatelessWidget {
  const ProductSelectorSheet({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      height: MediaQuery.of(context).size.height * 0.8,
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          // Header
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Seleccionar Producto',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              IconButton(
                onPressed: () => Navigator.of(context).pop(),
                icon: const Icon(Icons.close),
              ),
            ],
          ),
          const Divider(),

          // Search
          TextField(
            decoration: const InputDecoration(
              hintText: 'Buscar productos...',
              prefixIcon: Icon(Icons.search),
            ),
            onChanged: (value) {
              // TODO: Implement product search
            },
          ),
          const SizedBox(height: 16),

          // Products list
          Expanded(
            child: ListView.builder(
              itemCount: 10, // TODO: Use real products
              itemBuilder: (context, index) {
                return ListTile(
                  title: Text('Producto $index'),
                  subtitle: Text('\$${(index + 1) * 10}.00'),
                  trailing: ElevatedButton(
                    onPressed: () {
                      // TODO: Add product to cart
                      Navigator.of(context).pop();
                    },
                    child: const Text('Agregar'),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}


===== lib/features/orders/bloc/order_cubit.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../../data/models/sales/order.dart';
import '../../../data/models/sales/product.dart';
import '../../../data/repositories/orders_repository.dart';
import '../../../config/logger.dart';

part 'order_state.dart';
part 'order_cubit.freezed.dart';

class OrderCubit extends Cubit<OrderState> {
  final OrdersRepository _repository;

  OrderCubit(this._repository) : super(const OrderState.initial());

  void createNewOrder(String customerId) {
    final order = Order(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      companyId: 'current_company_id', // TODO: Get from auth
      customerId: customerId,
      status: OrderStatus.draft,
      items: [],
    );

    emit(OrderState.editing(order));
  }

  void addItem(Product product, double quantity, double price) {
    final currentState = state;
    if (currentState is OrderEditing) {
      final newItem = OrderItem(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        orderId: currentState.order.id,
        productId: product.id,
        qty: quantity,
        price: price,
        total: quantity * price,
        product: product,
      );

      final updatedItems = [...currentState.order.items, newItem];
      final updatedOrder = currentState.order.copyWith(items: updatedItems);
      final recalculatedOrder = _recalculateOrderTotals(updatedOrder);

      emit(OrderState.editing(recalculatedOrder));
    }
  }

  void removeItem(String itemId) {
    final currentState = state;
    if (currentState is OrderEditing) {
      final updatedItems =
          currentState.order.items.where((item) => item.id != itemId).toList();

      final updatedOrder = currentState.order.copyWith(items: updatedItems);
      final recalculatedOrder = _recalculateOrderTotals(updatedOrder);

      emit(OrderState.editing(recalculatedOrder));
    }
  }

  void updateItemQuantity(String itemId, double newQuantity) {
    final currentState = state;
    if (currentState is OrderEditing) {
      final updatedItems = currentState.order.items.map((item) {
        if (item.id == itemId) {
          return item.copyWith(
            qty: newQuantity,
            total: newQuantity * item.price,
          );
        }
        return item;
      }).toList();

      final updatedOrder = currentState.order.copyWith(items: updatedItems);
      final recalculatedOrder = _recalculateOrderTotals(updatedOrder);

      emit(OrderState.editing(recalculatedOrder));
    }
  }

  Future<void> saveOrder() async {
    try {
      final currentState = state;
      if (currentState is OrderEditing) {
        emit(const OrderState.saving());

        final savedOrder = await _repository.createOrder(currentState.order);
        emit(OrderState.saved(savedOrder));
      }
    } catch (e) {
      logger.e('Save order error: $e');
      emit(OrderState.error(e.toString()));
    }
  }

  Order _recalculateOrderTotals(Order order) {
    double subtotal = 0;
    double taxTotal = 0;
    double discountTotal = 0;

    for (final item in order.items) {
      subtotal += item.total;
      discountTotal += item.discount;
      // Tax calculation would be based on product tax rate
      if (item.product != null) {
        taxTotal += (item.total * item.product!.tax / 100);
      }
    }

    final grandTotal = subtotal + taxTotal - discountTotal;

    return order.copyWith(
      subtotal: subtotal,
      taxTotal: taxTotal,
      discountTotal: discountTotal,
      grandTotal: grandTotal,
    );
  }
}

@freezed
class OrderState with _$OrderState {
  const factory OrderState.initial() = _Initial;
  const factory OrderState.loading() = _Loading;
  const factory OrderState.editing(Order order) = OrderEditing;
  const factory OrderState.saving() = _Saving;
  const factory OrderState.saved(Order order) = _Saved;
  const factory OrderState.error(String message) = _Error;
}


===== lib/features/supervisor/pages/supervisor_dashboard_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import '../../../core/theme/palette.dart';
import '../../../data/models/geo/location_sample.dart';
import '../../../data/models/visits/visit.dart';
import '../../../data/models/auth/user_profile.dart';
import '../bloc/supervisor_cubit.dart';

class SupervisorDashboardPage extends StatefulWidget {
  const SupervisorDashboardPage({super.key});

  @override
  State<SupervisorDashboardPage> createState() =>
      _SupervisorDashboardPageState();
}

class _SupervisorDashboardPageState extends State<SupervisorDashboardPage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  GoogleMapController? _mapController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
    context.read<SupervisorCubit>().initializeDashboard();
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Panel de Supervisor'),
        backgroundColor: AppPalette.supervisor,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () => context.read<SupervisorCubit>().refreshData(),
          ),
          IconButton(
            icon: const Icon(Icons.message),
            onPressed: _showTeamMessageDialog,
          ),
        ],
        bottom: TabBar(
          controller: _tabController,
          indicatorColor: Colors.white,
          tabs: const [
            Tab(text: 'Resumen', icon: Icon(Icons.dashboard)),
            Tab(text: 'Equipo', icon: Icon(Icons.people)),
            Tab(text: 'Reportes', icon: Icon(Icons.analytics)),
          ],
        ),
      ),
      body: BlocConsumer<SupervisorCubit, SupervisorState>(
        listener: (context, state) {
          state.whenOrNull(
            error: (message) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(message),
                  backgroundColor: AppPalette.error,
                ),
              );
            },
          );
        },
        builder: (context, state) {
          return TabBarView(
            controller: _tabController,
            children: [
              _buildOverviewTab(state),
              _buildTeamTab(state),
              _buildReportsTab(state),
            ],
          );
        },
      ),
    );
  }

  Widget _buildOverviewTab(SupervisorState state) {
    return state.when(
      initial: () => const Center(child: Text('Inicializando...')),
      loading: () => const Center(child: CircularProgressIndicator()),
      loaded: (teamLocations, todayStats, activeVisits, teamMembers,
              isRefreshing, isLoadingMember, selectedMemberDetails) =>
          RefreshIndicator(
        onRefresh: () => context.read<SupervisorCubit>().refreshData(),
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              // Stats Cards
              _buildStatsCards(todayStats),
              const SizedBox(height: 16),

              // Team Map
              _buildTeamMap(teamLocations),
              const SizedBox(height: 16),

              // Active Visits
              _buildActiveVisitsSection(activeVisits),
            ],
          ),
        ),
      ),
      orElse: () => const Center(child: Text('Error cargando datos')),
    );
  }

  Widget _buildTeamTab(SupervisorState state) {
    return state.when(
      loaded: (teamLocations, todayStats, activeVisits, teamMembers,
              isRefreshing, isLoadingMember, selectedMemberDetails) =>
          Column(
        children: [
          // Team member list
          Expanded(
            child: ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: teamLocations.length,
              itemBuilder: (context, index) {
                final location = teamLocations[index];
                return TeamMemberCard(
                  location: location,
                  onTap: () => context
                      .read<SupervisorCubit>()
                      .loadTeamMember(location.userId),
                );
              },
            ),
          ),

          // Member details panel
          if (selectedMemberDetails != null)
            _buildMemberDetailsPanel(selectedMemberDetails),
        ],
      ),
      orElse: () => const Center(child: CircularProgressIndicator()),
    );
  }

  Widget _buildReportsTab(SupervisorState state) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          // Report period selector
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Generar Reporte',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Expanded(
                        child: ElevatedButton(
                          onPressed: () => _generateReport(ReportPeriod.today),
                          child: const Text('Hoy'),
                        ),
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: ElevatedButton(
                          onPressed: () => _generateReport(ReportPeriod.week),
                          child: const Text('Esta Semana'),
                        ),
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: ElevatedButton(
                          onPressed: () => _generateReport(ReportPeriod.month),
                          child: const Text('Este Mes'),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(height: 16),

          // Report display
          Expanded(
            child: state.when(
              reportLoaded: (report) => _buildReportView(report),
              loadingReport: () =>
                  const Center(child: CircularProgressIndicator()),
              orElse: () => const Center(
                child: Text('Selecciona un período para generar el reporte'),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatsCards(SupervisorStats stats) {
    return GridView.count(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      crossAxisCount: 2,
      childAspectRatio: 1.5,
      crossAxisSpacing: 8,
      mainAxisSpacing: 8,
      children: [
        _buildStatCard(
          'Visitas Hoy',
          '${stats.completedVisits}/${stats.totalVisits}',
          Icons.location_on,
          AppPalette.primary,
        ),
        _buildStatCard(
          'Pedidos',
          '${stats.totalOrders}',
          Icons.shopping_cart,
          AppPalette.success,
        ),
        _buildStatCard(
          'Ventas',
          '\$${stats.totalSales.toStringAsFixed(0)}',
          Icons.attach_money,
          AppPalette.warning,
        ),
        _buildStatCard(
          'Equipo Activo',
          '${stats.teamMembersActive}',
          Icons.people,
          AppPalette.info,
        ),
      ],
    );
  }

  Widget _buildStatCard(
      String title, String value, IconData icon, Color color) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, size: 32, color: color),
            const SizedBox(height: 8),
            Text(
              value,
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: color,
              ),
            ),
            Text(
              title,
              style: const TextStyle(
                fontSize: 12,
                color: AppPalette.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTeamMap(List<LocationSample> teamLocations) {
    return SizedBox(
      height: 300,
      child: Card(
        child: ClipRRect(
          borderRadius: BorderRadius.circular(12),
          child: GoogleMap(
            onMapCreated: (controller) => _mapController = controller,
            initialCameraPosition: const CameraPosition(
              target: LatLng(19.4326, -99.1332), // Mexico City
              zoom: 11,
            ),
            markers: teamLocations.map((location) {
              return Marker(
                markerId: MarkerId(location.userId),
                position: LatLng(location.latitude, location.longitude),
                icon: BitmapDescriptor.defaultMarkerWithHue(
                  BitmapDescriptor.hueBlue,
                ),
                infoWindow: InfoWindow(
                  title: 'Equipo ${location.userId}',
                  snippet: 'Actualizado: ${_formatTime(location.at)}',
                ),
              );
            }).toSet(),
            myLocationButtonEnabled: false,
            zoomControlsEnabled: false,
          ),
        ),
      ),
    );
  }

  Widget _buildActiveVisitsSection(List<Visit> activeVisits) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Visitas Activas',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Text(
                  '${activeVisits.length}',
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: AppPalette.primary,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            if (activeVisits.isEmpty)
              const Center(
                child: Text(
                  'No hay visitas activas',
                  style: TextStyle(color: AppPalette.textSecondary),
                ),
              )
            else
              ListView.separated(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: activeVisits.length,
                separatorBuilder: (context, index) => const Divider(),
                itemBuilder: (context, index) {
                  final visit = activeVisits[index];
                  return ActiveVisitTile(visit: visit);
                },
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildMemberDetailsPanel(TeamMemberDetails memberDetails) {
    return Container(
      height: 300,
      margin: const EdgeInsets.all(16),
      child: Card(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    memberDetails.user.fullName ?? 'Usuario',
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: () =>
                        context.read<SupervisorCubit>().clearSelectedMember(),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: _buildMemberStat(
                      'Visitas',
                      '${memberDetails.performance.visitsToday}',
                      Icons.location_on,
                    ),
                  ),
                  Expanded(
                    child: _buildMemberStat(
                      'Pedidos',
                      '${memberDetails.performance.ordersToday}',
                      Icons.shopping_cart,
                    ),
                  ),
                  Expanded(
                    child: _buildMemberStat(
                      'Ventas',
                      '\$${memberDetails.performance.salesAmount.toStringAsFixed(0)}',
                      Icons.attach_money,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMemberStat(String label, String value, IconData icon) {
    return Column(
      children: [
        Icon(icon, color: AppPalette.primary),
        const SizedBox(height: 4),
        Text(
          value,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: const TextStyle(
            fontSize: 12,
            color: AppPalette.textSecondary,
          ),
        ),
      ],
    );
  }

  Widget _buildReportView(PerformanceReport report) {
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Reporte de Rendimiento',
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Text(
                    report.period,
                    style: const TextStyle(
                      color: AppPalette.textSecondary,
                    ),
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Expanded(
                        child: _buildReportStat(
                          'Total Visitas',
                          '${report.totalVisits}',
                        ),
                      ),
                      Expanded(
                        child: _buildReportStat(
                          'Pedidos',
                          '${report.totalOrders}',
                        ),
                      ),
                      Expanded(
                        child: _buildReportStat(
                          'Ventas',
                          '\$${report.totalSales.toStringAsFixed(0)}',
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
          const SizedBox(height: 16),

          // Top performers
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Mejores Vendedores',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 16),
                  ListView.separated(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: report.topPerformers.length,
                    separatorBuilder: (context, index) => const Divider(),
                    itemBuilder: (context, index) {
                      final performer = report.topPerformers[index];
                      return ListTile(
                        leading: CircleAvatar(
                          backgroundColor: AppPalette.primary,
                          child: Text('${index + 1}'),
                        ),
                        title: Text(performer.userName),
                        subtitle: Text(
                            '${performer.visits} visitas • ${performer.orders} pedidos'),
                        trailing: Text(
                          '\$${performer.sales.toStringAsFixed(0)}',
                          style: const TextStyle(
                            fontWeight: FontWeight.bold,
                            color: AppPalette.success,
                          ),
                        ),
                      );
                    },
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildReportStat(String label, String value) {
    return Column(
      children: [
        Text(
          value,
          style: const TextStyle(
            fontSize: 24,
            fontWeight: FontWeight.bold,
            color: AppPalette.primary,
          ),
        ),
        Text(
          label,
          style: const TextStyle(
            fontSize: 12,
            color: AppPalette.textSecondary,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  void _generateReport(ReportPeriod period) {
    final now = DateTime.now();
    DateTime startDate;
    DateTime endDate = now;

    switch (period) {
      case ReportPeriod.today:
        startDate = DateTime(now.year, now.month, now.day);
        break;
      case ReportPeriod.week:
        startDate = now.subtract(Duration(days: now.weekday - 1));
        break;
      case ReportPeriod.month:
        startDate = DateTime(now.year, now.month, 1);
        break;
    }

    context.read<SupervisorCubit>().loadPerformanceReport(
          startDate: startDate,
          endDate: endDate,
        );
  }

  void _showTeamMessageDialog() {
    showDialog(
      context: context,
      builder: (context) => TeamMessageDialog(),
    );
  }

  String _formatTime(DateTime dateTime) {
    return '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }
}

class TeamMemberCard extends StatelessWidget {
  final LocationSample location;
  final VoidCallback onTap;

  const TeamMemberCard({
    super.key,
    required this.location,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: AppPalette.success,
          child: const Icon(Icons.person, color: Colors.white),
        ),
        title: Text('Usuario ${location.userId}'),
        subtitle: Text('Última actualización: ${_formatTime(location.at)}'),
        trailing: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.location_on,
              color: AppPalette.success,
            ),
            Text(
              '${location.accuracyM?.toStringAsFixed(0) ?? 'N/A'}m',
              style: const TextStyle(fontSize: 10),
            ),
          ],
        ),
        onTap: onTap,
      ),
    );
  }

  String _formatTime(DateTime dateTime) {
    return '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }
}

class ActiveVisitTile extends StatelessWidget {
  final Visit visit;

  const ActiveVisitTile({super.key, required this.visit});

  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: CircleAvatar(
        backgroundColor: AppPalette.warning,
        child: Icon(_getPurposeIcon(), color: Colors.white, size: 20),
      ),
      title: Text(visit.customer?.name ?? 'Cliente'),
      subtitle: Text(
        'Iniciada: ${visit.startedAt != null ? _formatTime(visit.startedAt!) : 'N/A'}',
      ),
      trailing: Text(_getPurposeLabel()),
    );
  }

  IconData _getPurposeIcon() {
    switch (visit.purpose) {
      case VisitPurpose.venta:
        return Icons.shopping_cart;
      case VisitPurpose.cobro:
        return Icons.payment;
      case VisitPurpose.entrega:
        return Icons.local_shipping;
      case VisitPurpose.auditoria:
        return Icons.assignment;
      case VisitPurpose.devolucion:
        return Icons.keyboard_return;
      default:
        return Icons.location_on;
    }
  }

  String _getPurposeLabel() {
    switch (visit.purpose) {
      case VisitPurpose.venta:
        return 'Venta';
      case VisitPurpose.cobro:
        return 'Cobro';
      case VisitPurpose.entrega:
        return 'Entrega';
      case VisitPurpose.visita:
        return 'Visita';
      case VisitPurpose.auditoria:
        return 'Auditoría';
      case VisitPurpose.devolucion:
        return 'Devolución';
      case VisitPurpose.otro:
        return 'Otro';
    }
  }

  String _formatTime(DateTime dateTime) {
    return '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }
}

class TeamMessageDialog extends StatefulWidget {
  @override
  State<TeamMessageDialog> createState() => _TeamMessageDialogState();
}

class _TeamMessageDialogState extends State<TeamMessageDialog> {
  final _messageController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Mensaje al Equipo'),
      content: TextField(
        controller: _messageController,
        maxLines: 3,
        decoration: const InputDecoration(
          hintText: 'Escribe tu mensaje...',
          border: OutlineInputBorder(),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancelar'),
        ),
        ElevatedButton(
          onPressed: () {
            context.read<SupervisorCubit>().sendTeamMessage(
                  message: _messageController.text,
                );
            Navigator.of(context).pop();
          },
          child: const Text('Enviar'),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _messageController.dispose();
    super.dispose();
  }
}

enum ReportPeriod { today, week, month }


===== lib/features/supervisor/bloc/supervisor_cubit.dart =====
import 'dart:async';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../../data/models/geo/location_sample.dart';
import '../../../data/models/customers/customer.dart';
import '../../../data/models/visits/visit.dart';
import '../../../data/models/sales/order.dart';
import '../../../data/models/auth/user_profile.dart';
import '../../../data/repositories/tracking_repository.dart';
import '../../../data/repositories/customers_repository.dart';
import '../../../data/repositories/visits_repository.dart';
import '../../../data/repositories/orders_repository.dart';
import '../../../config/logger.dart';

part 'supervisor_state.dart';
part 'supervisor_cubit.freezed.dart';

class SupervisorCubit extends Cubit<SupervisorState> {
  final TrackingRepository _trackingRepository;
  final CustomersRepository _customersRepository;
  final VisitsRepository _visitsRepository;
  final OrdersRepository _ordersRepository;

  Timer? _locationUpdateTimer;

  SupervisorCubit(
    this._trackingRepository,
    this._customersRepository,
    this._visitsRepository,
    this._ordersRepository,
  ) : super(const SupervisorState.initial());

  Future<void> initializeDashboard() async {
    emit(const SupervisorState.loading());

    try {
      // Load initial data
      await Future.wait([
        _loadTeamLocations(),
        _loadTodayStats(),
        _loadActiveVisits(),
      ]);

      // Start real-time location updates
      _startLocationUpdates();

      emit(SupervisorState.loaded(
        teamLocations: [],
        todayStats: const SupervisorStats(),
        activeVisits: [],
        teamMembers: [],
      ));
    } catch (e) {
      logger.e('Initialize supervisor dashboard error: $e');
      emit(SupervisorState.error(e.toString()));
    }
  }

  Future<void> _loadTeamLocations() async {
    try {
      final locations = await _trackingRepository.getRealtimeLocations();
      final currentState = state;

      if (currentState is SupervisorLoaded) {
        emit(currentState.copyWith(teamLocations: locations));
      }
    } catch (e) {
      logger.e('Load team locations error: $e');
    }
  }

  Future<void> _loadTodayStats() async {
    try {
      // Mock stats - implement actual stats calculation
      const stats = SupervisorStats(
        totalVisits: 25,
        completedVisits: 18,
        pendingVisits: 7,
        totalOrders: 12,
        totalSales: 15480.50,
        teamMembersActive: 8,
        averageVisitDuration: 35,
      );

      final currentState = state;
      if (currentState is SupervisorLoaded) {
        emit(currentState.copyWith(todayStats: stats));
      }
    } catch (e) {
      logger.e('Load today stats error: $e');
    }
  }

  Future<void> _loadActiveVisits() async {
    try {
      // Get active visits for today
      final today = DateTime.now();
      final startOfDay = DateTime(today.year, today.month, today.day);

      // Mock active visits - implement actual query
      final activeVisits = <Visit>[];

      final currentState = state;
      if (currentState is SupervisorLoaded) {
        emit(currentState.copyWith(activeVisits: activeVisits));
      }
    } catch (e) {
      logger.e('Load active visits error: $e');
    }
  }

  void _startLocationUpdates() {
    _locationUpdateTimer?.cancel();
    _locationUpdateTimer = Timer.periodic(
      const Duration(seconds: 30),
      (_) => _loadTeamLocations(),
    );
  }

  Future<void> refreshData() async {
    final currentState = state;
    if (currentState is SupervisorLoaded) {
      emit(currentState.copyWith(isRefreshing: true));
    }

    await Future.wait([
      _loadTeamLocations(),
      _loadTodayStats(),
      _loadActiveVisits(),
    ]);

    if (currentState is SupervisorLoaded) {
      emit(currentState.copyWith(isRefreshing: false));
    }
  }

  Future<void> loadTeamMember(String userId) async {
    try {
      final currentState = state;
      if (currentState is SupervisorLoaded) {
        emit(currentState.copyWith(isLoadingMember: true));

        // Load team member details, visits, and performance
        // Mock data for now
        final memberDetails = TeamMemberDetails(
          user: UserProfile(
            id: userId,
            fullName: 'Juan Pérez',
            role: UserRole.vendedor,
          ),
          todayVisits: [],
          todayOrders: [],
          currentLocation: null,
          performance: const MemberPerformance(
            visitsToday: 5,
            ordersToday: 3,
            salesAmount: 2500.0,
            visitDuration: 42,
            efficiency: 85.5,
          ),
        );

        emit(currentState.copyWith(
          isLoadingMember: false,
          selectedMemberDetails: memberDetails,
        ));
      }
    } catch (e) {
      logger.e('Load team member error: $e');
      final currentState = state;
      if (currentState is SupervisorLoaded) {
        emit(currentState.copyWith(isLoadingMember: false));
      }
    }
  }

  Future<void> loadPerformanceReport({
    required DateTime startDate,
    required DateTime endDate,
    String? userId,
  }) async {
    try {
      emit(const SupervisorState.loadingReport());

      // Generate performance report
      final report = PerformanceReport(
        period: '${_formatDate(startDate)} - ${_formatDate(endDate)}',
        totalVisits: 150,
        completedVisits: 135,
        totalOrders: 89,
        totalSales: 125680.50,
        averageOrderValue: 1412.58,
        topPerformers: [
          TeamPerformance(
            userId: 'user1',
            userName: 'Juan Pérez',
            visits: 25,
            orders: 18,
            sales: 22500.0,
          ),
          TeamPerformance(
            userId: 'user2',
            userName: 'María García',
            visits: 22,
            orders: 16,
            sales: 19800.0,
          ),
        ],
        visitsByDay: [
          DayPerformance(date: startDate, visits: 20, orders: 15),
          DayPerformance(
              date: startDate.add(const Duration(days: 1)),
              visits: 18,
              orders: 12),
        ],
      );

      emit(SupervisorState.reportLoaded(report));
    } catch (e) {
      logger.e('Load performance report error: $e');
      emit(SupervisorState.error(e.toString()));
    }
  }

  Future<void> sendTeamMessage({
    required String message,
    List<String>? targetUserIds,
  }) async {
    try {
      // Send message to team members
      // This would integrate with FCM or another messaging service

      // For now, just show success
      logger.i('Team message sent: $message');
    } catch (e) {
      logger.e('Send team message error: $e');
    }
  }

  Future<void> approveOrder(String orderId) async {
    try {
      // Approve order logic
      logger.i('Order approved: $orderId');
    } catch (e) {
      logger.e('Approve order error: $e');
    }
  }

  Future<void> rejectOrder(String orderId, String reason) async {
    try {
      // Reject order logic
      logger.i('Order rejected: $orderId, reason: $reason');
    } catch (e) {
      logger.e('Reject order error: $e');
    }
  }

  Future<void> reassignCustomer({
    required String customerId,
    required String newUserId,
  }) async {
    try {
      // Reassign customer to another team member
      logger.i('Customer $customerId reassigned to $newUserId');
    } catch (e) {
      logger.e('Reassign customer error: $e');
    }
  }

  Future<void> setGeofenceAlert({
    required String userId,
    required double lat,
    required double lng,
    required double radiusM,
  }) async {
    try {
      // Set geofence alert for team member
      logger.i('Geofence alert set for user $userId');
    } catch (e) {
      logger.e('Set geofence alert error: $e');
    }
  }

  void clearSelectedMember() {
    final currentState = state;
    if (currentState is SupervisorLoaded) {
      emit(currentState.copyWith(selectedMemberDetails: null));
    }
  }

  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }

  @override
  Future<void> close() {
    _locationUpdateTimer?.cancel();
    return super.close();
  }
}

@freezed
class SupervisorState with _$SupervisorState {
  const factory SupervisorState.initial() = _Initial;
  const factory SupervisorState.loading() = _Loading;
  const factory SupervisorState.loaded({
    required List<LocationSample> teamLocations,
    required SupervisorStats todayStats,
    required List<Visit> activeVisits,
    required List<UserProfile> teamMembers,
    @Default(false) bool isRefreshing,
    @Default(false) bool isLoadingMember,
    TeamMemberDetails? selectedMemberDetails,
  }) = SupervisorLoaded;
  const factory SupervisorState.loadingReport() = _LoadingReport;
  const factory SupervisorState.reportLoaded(PerformanceReport report) =
      _ReportLoaded;
  const factory SupervisorState.error(String message) = _Error;
}

@freezed
class SupervisorStats with _$SupervisorStats {
  const factory SupervisorStats({
    @Default(0) int totalVisits,
    @Default(0) int completedVisits,
    @Default(0) int pendingVisits,
    @Default(0) int totalOrders,
    @Default(0.0) double totalSales,
    @Default(0) int teamMembersActive,
    @Default(0) int averageVisitDuration,
  }) = _SupervisorStats;
}

@freezed
class TeamMemberDetails with _$TeamMemberDetails {
  const factory TeamMemberDetails({
    required UserProfile user,
    required List<Visit> todayVisits,
    required List<Order> todayOrders,
    LocationSample? currentLocation,
    required MemberPerformance performance,
  }) = _TeamMemberDetails;
}

@freezed
class MemberPerformance with _$MemberPerformance {
  const factory MemberPerformance({
    required int visitsToday,
    required int ordersToday,
    required double salesAmount,
    required int visitDuration,
    required double efficiency,
  }) = _MemberPerformance;
}

@freezed
class PerformanceReport with _$PerformanceReport {
  const factory PerformanceReport({
    required String period,
    required int totalVisits,
    required int completedVisits,
    required int totalOrders,
    required double totalSales,
    required double averageOrderValue,
    required List<TeamPerformance> topPerformers,
    required List<DayPerformance> visitsByDay,
  }) = _PerformanceReport;
}

@freezed
class TeamPerformance with _$TeamPerformance {
  const factory TeamPerformance({
    required String userId,
    required String userName,
    required int visits,
    required int orders,
    required double sales,
  }) = _TeamPerformance;
}

@freezed
class DayPerformance with _$DayPerformance {
  const factory DayPerformance({
    required DateTime date,
    required int visits,
    required int orders,
  }) = _DayPerformance;
}


===== lib/features/deliveries/pages/deliveries_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../core/theme/palette.dart';
import '../../../data/models/sales/order.dart';
import '../bloc/deliveries_cubit.dart';

class DeliveriesPage extends StatefulWidget {
  const DeliveriesPage({super.key});

  @override
  State<DeliveriesPage> createState() => _DeliveriesPageState();
}

class _DeliveriesPageState extends State<DeliveriesPage> {
  @override
  void initState() {
    super.initState();
    context.read<DeliveriesCubit>().loadDeliveries();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Entregas'),
        actions: [
          IconButton(
            icon: const Icon(Icons.sync),
            onPressed: () =>
                context.read<DeliveriesCubit>().loadDeliveries(forceSync: true),
          ),
        ],
      ),
      body: BlocBuilder<DeliveriesCubit, DeliveriesState>(
        builder: (context, state) {
          return state.when(
            initial: () => const Center(child: Text('Cargando entregas...')),
            loading: () => const Center(child: CircularProgressIndicator()),
            loaded: (deliveries) {
              if (deliveries.isEmpty) {
                return const Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.local_shipping_outlined,
                        size: 64,
                        color: AppPalette.textSecondary,
                      ),
                      SizedBox(height: 16),
                      Text(
                        'No hay entregas pendientes',
                        style: TextStyle(
                          fontSize: 18,
                          color: AppPalette.textSecondary,
                        ),
                      ),
                    ],
                  ),
                );
              }

              return RefreshIndicator(
                onRefresh: () => context
                    .read<DeliveriesCubit>()
                    .loadDeliveries(forceSync: true),
                child: ListView.builder(
                  padding: const EdgeInsets.all(16),
                  itemCount: deliveries.length,
                  itemBuilder: (context, index) {
                    final delivery = deliveries[index];
                    return DeliveryCard(
                      delivery: delivery,
                      onTap: () => _showDeliveryDetails(delivery),
                    );
                  },
                ),
              );
            },
            error: (message) => Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.error_outline,
                    size: 64,
                    color: AppPalette.error,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    message,
                    textAlign: TextAlign.center,
                    style: const TextStyle(fontSize: 16),
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () =>
                        context.read<DeliveriesCubit>().loadDeliveries(),
                    child: const Text('Reintentar'),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  void _showDeliveryDetails(dynamic delivery) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => DeliveryDetailsSheet(delivery: delivery),
    );
  }
}

class DeliveryCard extends StatelessWidget {
  final dynamic delivery;
  final VoidCallback onTap;

  const DeliveryCard({
    super.key,
    required this.delivery,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  Container(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: _getStatusColor('PENDING').withOpacity(0.1),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      'PENDIENTE',
                      style: TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.w600,
                        color: _getStatusColor('PENDING'),
                      ),
                    ),
                  ),
                  const Spacer(),
                  Text(
                    'Pedido #12345',
                    style: const TextStyle(
                      fontSize: 12,
                      color: AppPalette.textSecondary,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),

              // Customer info
              Row(
                children: [
                  const Icon(
                    Icons.business,
                    size: 16,
                    color: AppPalette.textSecondary,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Tienda Ejemplo',
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),

              // Address
              Row(
                children: [
                  const Icon(
                    Icons.location_on,
                    size: 16,
                    color: AppPalette.textSecondary,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Calle Ejemplo 123, Colonia, Ciudad',
                      style: const TextStyle(
                        fontSize: 14,
                        color: AppPalette.textSecondary,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),

              // Footer with amount and items
              Row(
                children: [
                  Container(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: AppPalette.primary.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      '5 productos',
                      style: TextStyle(
                        fontSize: 12,
                        color: AppPalette.primary,
                      ),
                    ),
                  ),
                  const Spacer(),
                  Text(
                    '\$1,250.00',
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: AppPalette.primary,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Color _getStatusColor(String status) {
    switch (status) {
      case 'PENDING':
        return AppPalette.warning;
      case 'PARTIAL':
        return AppPalette.info;
      case 'DELIVERED':
        return AppPalette.success;
      case 'REJECTED':
        return AppPalette.error;
      default:
        return AppPalette.textSecondary;
    }
  }
}

class DeliveryDetailsSheet extends StatelessWidget {
  final dynamic delivery;

  const DeliveryDetailsSheet({
    super.key,
    required this.delivery,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      height: MediaQuery.of(context).size.height * 0.8,
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Detalles de Entrega',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              IconButton(
                onPressed: () => Navigator.of(context).pop(),
                icon: const Icon(Icons.close),
              ),
            ],
          ),
          const Divider(),

          // Delivery info
          Expanded(
            child: SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildInfoSection('Cliente', [
                    _buildInfoRow('Nombre', 'Tienda Ejemplo'),
                    _buildInfoRow(
                        'Dirección', 'Calle Ejemplo 123, Colonia, Ciudad'),
                    _buildInfoRow('Teléfono', '+52 55 1234 5678'),
                  ]),
                  _buildInfoSection('Pedido', [
                    _buildInfoRow('Número', '#12345'),
                    _buildInfoRow('Fecha', '07/08/2025'),
                    _buildInfoRow('Total', '\$1,250.00'),
                  ]),
                  _buildInfoSection('Productos', [
                    _buildProductRow('Producto A', 2, '\$500.00'),
                    _buildProductRow('Producto B', 1, '\$300.00'),
                    _buildProductRow('Producto C', 3, '\$450.00'),
                  ]),
                ],
              ),
            ),
          ),

          // Action buttons
          Row(
            children: [
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: () => _confirmDelivery(context, false),
                  icon: const Icon(Icons.close),
                  label: const Text('Rechazar'),
                  style: OutlinedButton.styleFrom(
                    foregroundColor: AppPalette.error,
                  ),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: ElevatedButton.icon(
                  onPressed: () => _confirmDelivery(context, true),
                  icon: const Icon(Icons.check),
                  label: const Text('Entregar'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppPalette.success,
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildInfoSection(String title, List<Widget> children) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w600,
            color: AppPalette.primary,
          ),
        ),
        const SizedBox(height: 8),
        ...children,
        const SizedBox(height: 20),
      ],
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          SizedBox(
            width: 80,
            child: Text(
              label,
              style: const TextStyle(
                fontSize: 14,
                color: AppPalette.textSecondary,
              ),
            ),
          ),
          Text(
            value,
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildProductRow(String name, int qty, String total) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Expanded(
            child: Text(
              name,
              style: const TextStyle(fontSize: 14),
            ),
          ),
          Text(
            'x$qty',
            style: const TextStyle(
              fontSize: 14,
              color: AppPalette.textSecondary,
            ),
          ),
          const SizedBox(width: 16),
          Text(
            total,
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }

  void _confirmDelivery(BuildContext context, bool delivered) {
    Navigator.of(context).pop();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(delivered ? 'Confirmar Entrega' : 'Rechazar Entrega'),
        content: Text(delivered
            ? '¿Confirmas que se entregaron todos los productos?'
            : '¿Estás seguro de rechazar esta entrega?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancelar'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              // TODO: Implement delivery confirmation
            },
            style: ElevatedButton.styleFrom(
              backgroundColor:
                  delivered ? AppPalette.success : AppPalette.error,
            ),
            child: Text(delivered ? 'Confirmar' : 'Rechazar'),
          ),
        ],
      ),
    );
  }
}


===== lib/features/deliveries/bloc/deliveries_cubit.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../../data/repositories/deliveries_repository.dart';
import '../../../data/models/sales/order.dart';
import '../../../config/logger.dart';

part 'deliveries_state.dart';
part 'deliveries_cubit.freezed.dart';

class DeliveriesCubit extends Cubit<DeliveriesState> {
  final DeliveriesRepository _repository;

  DeliveriesCubit(this._repository) : super(const DeliveriesState.initial());

  Future<void> loadDeliveries({bool forceSync = false}) async {
    emit(const DeliveriesState.loading());

    try {
      final deliveries = await _repository.getDeliveries(forceSync: forceSync);
      emit(DeliveriesState.loaded(deliveries));
    } catch (e) {
      logger.e('Load deliveries error: $e');
      emit(DeliveriesState.error(e.toString()));
    }
  }

  Future<void> confirmDelivery({
    required String deliveryId,
    required bool delivered,
    String? notes,
    List<String>? photoUrls,
    String? signatureUrl,
  }) async {
    try {
      final currentState = state;
      if (currentState is DeliveriesLoaded) {
        emit(const DeliveriesState.processing());

        final status =
            delivered ? DeliveryStatus.delivered : DeliveryStatus.rejected;

        final updatedDelivery = await _repository.confirmDelivery(
          deliveryId,
          status,
          notes,
        );

        // Update the delivery in the list
        final updatedDeliveries = currentState.deliveries.map((delivery) {
          if (delivery.id == deliveryId) {
            return updatedDelivery;
          }
          return delivery;
        }).toList();

        emit(DeliveriesState.loaded(updatedDeliveries));

        // Show success message
        emit(DeliveriesState.deliveryConfirmed(
          updatedDelivery,
          delivered ? 'Entrega confirmada exitosamente' : 'Entrega rechazada',
        ));

        // Return to loaded state
        emit(DeliveriesState.loaded(updatedDeliveries));
      }
    } catch (e) {
      logger.e('Confirm delivery error: $e');
      emit(DeliveriesState.error(e.toString()));
    }
  }

  Future<void> markPartialDelivery({
    required String deliveryId,
    required List<Map<String, dynamic>> deliveredItems,
    String? notes,
  }) async {
    try {
      final currentState = state;
      if (currentState is DeliveriesLoaded) {
        emit(const DeliveriesState.processing());

        final updatedDelivery = await _repository.confirmDelivery(
          deliveryId,
          DeliveryStatus.partial,
          notes,
        );

        // Update the delivery in the list
        final updatedDeliveries = currentState.deliveries.map((delivery) {
          if (delivery.id == deliveryId) {
            return updatedDelivery;
          }
          return delivery;
        }).toList();

        emit(DeliveriesState.loaded(updatedDeliveries));
      }
    } catch (e) {
      logger.e('Mark partial delivery error: $e');
      emit(DeliveriesState.error(e.toString()));
    }
  }

  Future<void> startDeliveryRoute() async {
    try {
      // Start delivery route - could involve GPS tracking
      logger.i('Starting delivery route');

      // Load pending deliveries
      await loadDeliveries();
    } catch (e) {
      logger.e('Start delivery route error: $e');
      emit(DeliveriesState.error(e.toString()));
    }
  }

  Future<void> completeDeliveryRoute() async {
    try {
      // Complete delivery route
      logger.i('Completing delivery route');

      // Generate delivery summary
      final currentState = state;
      if (currentState is DeliveriesLoaded) {
        final completed = currentState.deliveries
            .where((d) => d.status == DeliveryStatus.delivered)
            .length;
        final total = currentState.deliveries.length;

        emit(DeliveriesState.routeCompleted(
          'Ruta completada: $completed de $total entregas realizadas',
        ));
      }
    } catch (e) {
      logger.e('Complete delivery route error: $e');
      emit(DeliveriesState.error(e.toString()));
    }
  }

  void filterDeliveries(DeliveryStatus status) {
    final currentState = state;
    if (currentState is DeliveriesLoaded) {
      final filteredDeliveries = currentState.deliveries
          .where((delivery) => delivery.status == status)
          .toList();

      emit(DeliveriesState.filtered(filteredDeliveries, status));
    }
  }

  void clearFilter() {
    final currentState = state;
    if (currentState is DeliveriesFiltered) {
      emit(DeliveriesState.loaded(currentState.allDeliveries));
    }
  }

  void searchDeliveries(String query) {
    final currentState = state;
    if (currentState is DeliveriesLoaded) {
      if (query.isEmpty) {
        // Show all deliveries
        return;
      }

      final filteredDeliveries = currentState.deliveries.where((delivery) {
        // Search in order ID, customer name, etc.
        final searchFields = [
          delivery.orderId,
          delivery.order?.customer?.name ?? '',
          delivery.order?.id ?? '',
        ];

        return searchFields
            .any((field) => field.toLowerCase().contains(query.toLowerCase()));
      }).toList();

      emit(DeliveriesState.searched(filteredDeliveries, query));
    }
  }

  Future<void> generateDeliveryReport({
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      emit(const DeliveriesState.generatingReport());

      // Generate delivery report
      final currentState = state;
      if (currentState is DeliveriesLoaded) {
        final report = DeliveryReport(
          period: '${_formatDate(startDate)} - ${_formatDate(endDate)}',
          totalDeliveries: currentState.deliveries.length,
          successfulDeliveries: currentState.deliveries
              .where((d) => d.status == DeliveryStatus.delivered)
              .length,
          rejectedDeliveries: currentState.deliveries
              .where((d) => d.status == DeliveryStatus.rejected)
              .length,
          partialDeliveries: currentState.deliveries
              .where((d) => d.status == DeliveryStatus.partial)
              .length,
          averageDeliveryTime: 25, // Mock data
          deliveryRate: 0.85, // Mock data
        );

        emit(DeliveriesState.reportGenerated(report));
      }
    } catch (e) {
      logger.e('Generate delivery report error: $e');
      emit(DeliveriesState.error(e.toString()));
    }
  }

  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }
}

@freezed
class DeliveriesState with _$DeliveriesState {
  const factory DeliveriesState.initial() = _Initial;
  const factory DeliveriesState.loading() = _Loading;
  const factory DeliveriesState.loaded(List<DeliveryModel> deliveries) =
      DeliveriesLoaded;
  const factory DeliveriesState.filtered(
    List<DeliveryModel> deliveries,
    DeliveryStatus filter,
  ) = DeliveriesFiltered;
  const factory DeliveriesState.searched(
    List<DeliveryModel> deliveries,
    String query,
  ) = DeliveriesSearched;
  const factory DeliveriesState.processing() = _Processing;
  const factory DeliveriesState.deliveryConfirmed(
    DeliveryModel delivery,
    String message,
  ) = _DeliveryConfirmed;
  const factory DeliveriesState.routeCompleted(String message) =
      _RouteCompleted;
  const factory DeliveriesState.generatingReport() = _GeneratingReport;
  const factory DeliveriesState.reportGenerated(DeliveryReport report) =
      _ReportGenerated;
  const factory DeliveriesState.error(String message) = _Error;
}

// Extension to get all deliveries from filtered state
extension DeliveriesStateX on DeliveriesState {
  List<DeliveryModel> get allDeliveries {
    return when(
      loaded: (deliveries) => deliveries,
      filtered: (_, __) => [], // Would need to store original list
      searched: (_, __) => [], // Would need to store original list
      deliveryConfirmed: (_, __) => [],
      initial: () => [],
      loading: () => [],
      processing: () => [],
      routeCompleted: (_) => [],
      generatingReport: () => [],
      reportGenerated: (_) => [],
      error: (_) => [],
    );
  }
}

@freezed
class DeliveryReport with _$DeliveryReport {
  const factory DeliveryReport({
    required String period,
    required int totalDeliveries,
    required int successfulDeliveries,
    required int rejectedDeliveries,
    required int partialDeliveries,
    required int averageDeliveryTime,
    required double deliveryRate,
  }) = _DeliveryReport;
}


===== lib/main.dart =====
import 'package:flutter/material.dart';
import 'bootstrap.dart';

void main() {
  bootstrap();
}


===== lib/routing/app_router.dart =====
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../features/auth/pages/sign_in_page.dart';
import '../features/auth/bloc/auth_cubit.dart';
import '../features/map/pages/live_map_page.dart';
import '../features/customers/pages/customers_list_page.dart';
import '../features/customers/pages/customer_detail_page.dart';
import '../features/customers/pages/customer_form_page.dart';
import '../features/visits/pages/visit_checkin_page.dart';
import '../features/visits/pages/visit_forms_page.dart';
import '../features/visits/pages/visit_photos_page.dart';
import '../features/visits/pages/visit_signature_page.dart';
import '../features/orders/pages/cart_page.dart';
import '../features/deliveries/pages/deliveries_page.dart';
import '../features/payments/pages/payments_page.dart';
import '../features/supervisor/pages/supervisor_dashboard_page.dart';
import '../core/widgets/app_scaffold.dart';

class AppRouter {
  static final _rootNavigatorKey = GlobalKey<NavigatorState>();
  static final _shellNavigatorKey = GlobalKey<NavigatorState>();

  static GoRouter get router => _router;

  static final _router = GoRouter(
    navigatorKey: _rootNavigatorKey,
    initialLocation: '/dashboard',
    redirect: (context, state) {
      final authState = context.read<AuthCubit>().state;
      final isAuthenticated = authState is Authenticated;
      final isGoingToSignIn = state.matchedLocation == '/sign-in';

      if (!isAuthenticated && !isGoingToSignIn) {
        return '/sign-in';
      }
      if (isAuthenticated && isGoingToSignIn) {
        return '/dashboard';
      }
      return null;
    },
    routes: [
      // Auth routes
      GoRoute(
        path: '/sign-in',
        builder: (context, state) => const SignInPage(),
      ),

      // Main app shell
      ShellRoute(
        navigatorKey: _shellNavigatorKey,
        builder: (context, state, child) => AppScaffold(child: child),
        routes: [
          // Dashboard/Map
          GoRoute(
            path: '/dashboard',
            builder: (context, state) => const LiveMapPage(),
          ),

          // Customers
          GoRoute(
            path: '/customers',
            builder: (context, state) => const CustomersListPage(),
          ),
          GoRoute(
            path: '/customers/new',
            builder: (context, state) => const CustomerFormPage(),
          ),
          GoRoute(
            path: '/customers/:id',
            builder: (context, state) => CustomerDetailPage(
              customerId: state.pathParameters['id']!,
            ),
          ),

          // Visits
          GoRoute(
            path: '/visit/checkin/:customerId',
            builder: (context, state) => VisitCheckinPage(
              customerId: state.pathParameters['customerId']!,
              purpose: state.uri.queryParameters['purpose'],
            ),
          ),
          GoRoute(
            path: '/visit/forms/:visitId',
            builder: (context, state) => VisitFormsPage(
              visitId: state.pathParameters['visitId']!,
            ),
          ),
          GoRoute(
            path: '/visit/photos/:visitId',
            builder: (context, state) => VisitPhotosPage(
              visitId: state.pathParameters['visitId']!,
            ),
          ),
          GoRoute(
            path: '/visit/signature/:visitId',
            builder: (context, state) => VisitSignaturePage(
              visitId: state.pathParameters['visitId']!,
            ),
          ),

          // Orders
          GoRoute(
            path: '/orders/cart/:customerId',
            builder: (context, state) => CartPage(
              customerId: state.pathParameters['customerId']!,
            ),
          ),

          // Deliveries
          GoRoute(
            path: '/deliveries',
            builder: (context, state) => const DeliveriesPage(),
          ),

          // Payments
          GoRoute(
            path: '/payments',
            builder: (context, state) => const PaymentsPage(),
          ),

          // Supervisor
          GoRoute(
            path: '/supervisor',
            builder: (context, state) => const SupervisorDashboardPage(),
          ),
        ],
      ),
    ],
  );
}


===== lib/routing/guards.dart =====
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../features/auth/bloc/auth_cubit.dart';
import '../data/models/auth/user_profile.dart';
import '../config/logger.dart';

class AuthGuard {
  static String? redirectIfUnauthenticated(
    BuildContext context,
    GoRouterState state,
  ) {
    final authState = context.read<AuthCubit>().state;
    final isAuthenticated = authState is Authenticated;
    final isGoingToSignIn = state.matchedLocation == '/sign-in';

    logger.d(
        'Auth guard: isAuthenticated=$isAuthenticated, location=${state.matchedLocation}');

    if (!isAuthenticated && !isGoingToSignIn) {
      return '/sign-in';
    }

    if (isAuthenticated && isGoingToSignIn) {
      return '/dashboard';
    }

    return null;
  }
}

class RoleGuard {
  /// Check if user has required role for accessing a route
  static String? checkRole(
    BuildContext context,
    GoRouterState state,
    List<UserRole> allowedRoles,
  ) {
    final authState = context.read<AuthCubit>().state;

    if (authState is! Authenticated) {
      return '/sign-in';
    }

    final userRole = authState.user.role;

    if (!allowedRoles.contains(userRole)) {
      logger.w('Access denied for role $userRole to ${state.matchedLocation}');
      return '/dashboard'; // Redirect to dashboard if role not allowed
    }

    return null;
  }

  /// Supervisor and Admin only routes
  static String? supervisorOrAdminOnly(
    BuildContext context,
    GoRouterState state,
  ) {
    return checkRole(context, state, [UserRole.supervisor, UserRole.admin]);
  }

  /// Admin only routes
  static String? adminOnly(
    BuildContext context,
    GoRouterState state,
  ) {
    return checkRole(context, state, [UserRole.admin]);
  }

  /// Vendedor routes (also allow supervisors and admins)
  static String? vendedorAccess(
    BuildContext context,
    GoRouterState state,
  ) {
    return checkRole(context, state, [
      UserRole.vendedor,
      UserRole.supervisor,
      UserRole.admin,
    ]);
  }

  /// Repartidor routes (also allow supervisors and admins)
  static String? repartidorAccess(
    BuildContext context,
    GoRouterState state,
  ) {
    return checkRole(context, state, [
      UserRole.repartidor,
      UserRole.supervisor,
      UserRole.admin,
    ]);
  }

  /// Routes accessible by field workers (vendedor + repartidor)
  static String? fieldWorkerAccess(
    BuildContext context,
    GoRouterState state,
  ) {
    return checkRole(context, state, [
      UserRole.vendedor,
      UserRole.repartidor,
      UserRole.supervisor,
      UserRole.admin,
    ]);
  }
}

class FeatureGuard {
  /// Check if user's company has access to specific features
  static String? checkFeatureAccess(
    BuildContext context,
    GoRouterState state,
    String featureKey,
  ) {
    final authState = context.read<AuthCubit>().state;

    if (authState is! Authenticated) {
      return '/sign-in';
    }

    // TODO: Implement feature flags based on company subscription
    // For now, allow all features
    return null;
  }

  /// Check if orders feature is available
  static String? ordersFeatureGuard(
    BuildContext context,
    GoRouterState state,
  ) {
    return checkFeatureAccess(context, state, 'orders');
  }

  /// Check if payments feature is available
  static String? paymentsFeatureGuard(
    BuildContext context,
    GoRouterState state,
  ) {
    return checkFeatureAccess(context, state, 'payments');
  }

  /// Check if deliveries feature is available
  static String? deliveriesFeatureGuard(
    BuildContext context,
    GoRouterState state,
  ) {
    return checkFeatureAccess(context, state, 'deliveries');
  }

  /// Check if supervisor dashboard is available
  static String? supervisorFeatureGuard(
    BuildContext context,
    GoRouterState state,
  ) {
    return checkFeatureAccess(context, state, 'supervisor_dashboard');
  }
}

class LocationGuard {
  /// Check if location permissions are granted for location-dependent routes
  static String? checkLocationPermission(
    BuildContext context,
    GoRouterState state,
  ) {
    // TODO: Implement location permission check
    // For routes that require location (visits, tracking, etc.)
    return null;
  }
}

class OnboardingGuard {
  /// Check if user has completed onboarding
  static String? checkOnboardingCompleted(
    BuildContext context,
    GoRouterState state,
  ) {
    final authState = context.read<AuthCubit>().state;

    if (authState is! Authenticated) {
      return '/sign-in';
    }

    // TODO: Check if user has completed onboarding
    // This could be stored in user profile or preferences
    final hasCompletedOnboarding = true; // Mock for now

    if (!hasCompletedOnboarding) {
      return '/onboarding';
    }

    return null;
  }
}

class VisitGuard {
  /// Check if user can start a new visit (no active visit)
  static String? checkCanStartVisit(
    BuildContext context,
    GoRouterState state,
  ) {
    // TODO: Check if user has an active visit
    // If there's an active visit, redirect to that visit
    return null;
  }

  /// Check if user has an active visit for visit-related routes
  static String? requireActiveVisit(
    BuildContext context,
    GoRouterState state,
  ) {
    // TODO: Check if user has an active visit
    // If no active visit, redirect to dashboard
    return null;
  }
}

class NetworkGuard {
  /// Check network connectivity for online-only features
  static String? checkOnlineRequired(
    BuildContext context,
    GoRouterState state,
  ) {
    // TODO: Check network connectivity
    // Show offline page if required feature needs internet
    return null;
  }
}

class CompanyGuard {
  /// Check if user belongs to a company
  static String? requireCompanyMembership(
    BuildContext context,
    GoRouterState state,
  ) {
    final authState = context.read<AuthCubit>().state;

    if (authState is! Authenticated) {
      return '/sign-in';
    }

    if (authState.user.companyId == null) {
      logger.w('User has no company assigned');
      return '/no-company'; // Would need to create this page
    }

    return null;
  }
}

/// Utility class to combine multiple guards
class GuardCombiner {
  static String? combineGuards(
    BuildContext context,
    GoRouterState state,
    List<String? Function(BuildContext, GoRouterState)> guards,
  ) {
    for (final guard in guards) {
      final redirect = guard(context, state);
      if (redirect != null) {
        return redirect;
      }
    }
    return null;
  }

  /// Common guard combination for authenticated routes
  static String? authenticatedRoute(
    BuildContext context,
    GoRouterState state,
  ) {
    return combineGuards(context, state, [
      AuthGuard.redirectIfUnauthenticated,
      CompanyGuard.requireCompanyMembership,
      OnboardingGuard.checkOnboardingCompleted,
    ]);
  }

  /// Common guard combination for supervisor routes
  static String? supervisorRoute(
    BuildContext context,
    GoRouterState state,
  ) {
    return combineGuards(context, state, [
      authenticatedRoute,
      RoleGuard.supervisorOrAdminOnly,
      FeatureGuard.supervisorFeatureGuard,
    ]);
  }

  /// Common guard combination for field worker routes
  static String? fieldWorkerRoute(
    BuildContext context,
    GoRouterState state,
  ) {
    return combineGuards(context, state, [
      authenticatedRoute,
      RoleGuard.fieldWorkerAccess,
      LocationGuard.checkLocationPermission,
    ]);
  }

  /// Common guard combination for visit routes
  static String? visitRoute(
    BuildContext context,
    GoRouterState state,
  ) {
    return combineGuards(context, state, [
      fieldWorkerRoute,
      VisitGuard.checkCanStartVisit,
    ]);
  }

  /// Common guard combination for order routes
  static String? orderRoute(
    BuildContext context,
    GoRouterState state,
  ) {
    return combineGuards(context, state, [
      authenticatedRoute,
      RoleGuard.vendedorAccess,
      FeatureGuard.ordersFeatureGuard,
    ]);
  }

  /// Common guard combination for delivery routes
  static String? deliveryRoute(
    BuildContext context,
    GoRouterState state,
  ) {
    return combineGuards(context, state, [
      authenticatedRoute,
      RoleGuard.repartidorAccess,
      FeatureGuard.deliveriesFeatureGuard,
    ]);
  }
}

/// Helper extension for role checking
extension UserRoleExtension on UserRole {
  bool get isAdmin => this == UserRole.admin;
  bool get isSupervisor => this == UserRole.supervisor;
  bool get isVendedor => this == UserRole.vendedor;
  bool get isRepartidor => this == UserRole.repartidor;

  bool get canAccessSupervisorFeatures => isAdmin || isSupervisor;
  bool get canAccessAllFeatures => isAdmin;
  bool get isFieldWorker => isVendedor || isRepartidor;
}


===== lib/data/repositories/orders_repository.dart =====
import 'package:connectivity_plus/connectivity_plus.dart';
import '../models/sales/order.dart';
import '../models/sales/product.dart';
import '../local/drift/db.dart';
import '../remote/supabase_client.dart';
import '../../config/logger.dart';

class OrdersRepository {
  final DatabaseHelper _db = DatabaseHelper.instance;
  final SupabaseService _supabase = SupabaseService();

  Future<List<Order>> getOrders({bool forceSync = false}) async {
    try {
      final connectivity = await Connectivity().checkConnectivity();
      final isOnline = connectivity != ConnectivityResult.none;

      if (isOnline && forceSync) {
        await _syncOrdersFromServer();
      }

      final entities = await _db.getAllOrders();
      return entities.map(_entityToModel).toList();
    } catch (e) {
      logger.e('Get orders error: $e');
      rethrow;
    }
  }

  Future<Order> createOrder(Order order) async {
    try {
      // Save locally first
      final entity = _modelToEntity(order.copyWith(needsSync: true));
      await _db.insertOrder(entity);

      // Save order items
      final itemEntities = order.items
          .map((item) => OrderItemEntity(
                id: item.id,
                orderId: order.id,
                productId: item.productId,
                qty: item.qty,
                price: item.price,
                discount: item.discount,
                total: item.total,
              ))
          .toList();

      await _db.insertOrderItems(itemEntities);

      // Try to sync immediately if online
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        await _syncOrderToServer(order);
      }

      return order;
    } catch (e) {
      logger.e('Create order error: $e');
      rethrow;
    }
  }

  Future<List<Product>> getProducts() async {
    try {
      final entities = await _db.getAllProducts();
      return entities
          .map((entity) => Product(
                id: entity.id,
                companyId: entity.companyId,
                sku: entity.sku,
                name: entity.name,
                unit: entity.unit,
                tax: entity.tax,
                active: entity.active,
                createdAt: entity.createdAt,
              ))
          .toList();
    } catch (e) {
      logger.e('Get products error: $e');
      return [];
    }
  }

  Future<void> syncPendingOrders() async {
    try {
      final pendingOrders = await _db.getPendingSyncOrders();

      for (final entity in pendingOrders) {
        final order = _entityToModel(entity);
        await _syncOrderToServer(order);
        await _db.markOrderSynced(order.id);
      }
    } catch (e) {
      logger.e('Sync pending orders error: $e');
    }
  }

  Future<void> _syncOrdersFromServer() async {
    try {
      final orders = await _supabase.getOrders();
      final entities = orders.map(_modelToEntity).toList();
      await _db.insertOrders(entities);
    } catch (e) {
      logger.e('Sync orders from server error: $e');
    }
  }

  Future<void> _syncOrderToServer(Order order) async {
    try {
      await _supabase.createOrder(order);
      // Mark as synced in local DB
      final entity = _modelToEntity(order.copyWith(needsSync: false));
      await _db.insertOrder(entity);
    } catch (e) {
      logger.e('Sync order to server error: $e');
    }
  }

  Order _entityToModel(OrderEntity entity) {
    return Order(
      id: entity.id,
      companyId: entity.companyId,
      customerId: entity.customerId,
      userId: entity.userId,
      priceListId: entity.priceListId,
      status: _stringToOrderStatus(entity.status),
      subtotal: entity.subtotal,
      taxTotal: entity.taxTotal,
      discountTotal: entity.discountTotal,
      grandTotal: entity.grandTotal,
      createdAt: entity.createdAt,
    );
  }

  OrderEntity _modelToEntity(Order model) {
    return OrderEntity(
      id: model.id,
      companyId: model.companyId,
      customerId: model.customerId,
      userId: model.userId,
      priceListId: model.priceListId,
      status: model.status.name.toUpperCase(),
      subtotal: model.subtotal,
      taxTotal: model.taxTotal,
      discountTotal: model.discountTotal,
      grandTotal: model.grandTotal,
      createdAt: model.createdAt,
      needsSync: false,
    );
  }

  OrderStatus _stringToOrderStatus(String status) {
    switch (status.toUpperCase()) {
      case 'DRAFT':
        return OrderStatus.draft;
      case 'SENT':
        return OrderStatus.sent;
      case 'APPROVED':
        return OrderStatus.approved;
      case 'REJECTED':
        return OrderStatus.rejected;
      case 'DELIVERED':
        return OrderStatus.delivered;
      case 'CANCELLED':
        return OrderStatus.cancelled;
      default:
        return OrderStatus.draft;
    }
  }
}


===== lib/data/repositories/tracking_repository.dart =====
import 'package:connectivity_plus/connectivity_plus.dart';
import '../models/geo/location_sample.dart';
import '../local/drift/db.dart';
import '../remote/supabase_client.dart';
import '../../config/logger.dart';

class TrackingRepository {
  final DatabaseHelper _db = DatabaseHelper.instance;
  final SupabaseService _supabase = SupabaseService();

  Future<void> saveLocationSample(LocationSample sample) async {
    try {
      final entity = TrackingEntity(
        id: sample.id,
        companyId: sample.companyId,
        userId: sample.userId,
        at: sample.at,
        latitude: sample.latitude,
        longitude: sample.longitude,
        speedMs: sample.speedMs,
        accuracyM: sample.accuracyM,
        needsSync: true,
      );

      await _db.insertTrackingLocation(entity);

      // Try to sync immediately if online
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        await syncPendingLocations();
      }
    } catch (e) {
      logger.e('Save location sample error: $e');
    }
  }

  Future<void> syncPendingLocations() async {
    try {
      final pendingLocations = await _db.getPendingSyncTracking();

      if (pendingLocations.isNotEmpty) {
        final samples = pendingLocations
            .map((entity) => LocationSample(
                  id: entity.id,
                  companyId: entity.companyId,
                  userId: entity.userId,
                  at: entity.at,
                  latitude: entity.latitude,
                  longitude: entity.longitude,
                  speedMs: entity.speedMs,
                  accuracyM: entity.accuracyM,
                ))
            .toList();

        await _supabase.uploadTrackingLocations(samples);

        final ids = pendingLocations.map((e) => e.id).toList();
        await _db.markTrackingSynced(ids);
      }
    } catch (e) {
      logger.e('Sync pending locations error: $e');
    }
  }

  Future<List<LocationSample>> getRealtimeLocations() async {
    try {
      return await _supabase.getRealtimeLocations();
    } catch (e) {
      logger.e('Get realtime locations error: $e');
      return [];
    }
  }

  Future<void> cleanupOldData() async {
    try {
      await _db.cleanupOldTracking();
    } catch (e) {
      logger.e('Cleanup old data error: $e');
    }
  }
}


===== lib/data/repositories/customers_repository.dart =====
import 'package:connectivity_plus/connectivity_plus.dart';
import '../models/customers/customer.dart';
import '../local/drift/db.dart';
import '../remote/supabase_client.dart';
import '../../config/logger.dart';

class CustomersRepository {
  final DatabaseHelper _db = DatabaseHelper.instance;
  final SupabaseService _supabase = SupabaseService();

  Future<List<Customer>> getCustomers({bool forceSync = false}) async {
    try {
      final connectivity = await Connectivity().checkConnectivity();
      final isOnline = connectivity != ConnectivityResult.none;

      if (isOnline && forceSync) {
        await _syncCustomersFromServer();
      }

      final entities = await _db.getAllCustomers();
      return entities.map(_entityToModel).toList();
    } catch (e) {
      logger.e('Get customers error: $e');
      rethrow;
    }
  }

  Future<Customer?> getCustomerById(String id) async {
    try {
      final entity = await _db.getCustomerById(id);
      return entity != null ? _entityToModel(entity) : null;
    } catch (e) {
      logger.e('Get customer by id error: $e');
      return null;
    }
  }

  Future<Customer> createCustomer(Customer customer) async {
    try {
      final entity = _modelToEntity(customer.copyWith(needsSync: true));
      await _db.insertCustomer(entity);

      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        await _syncCustomerToServer(customer);
      }

      return customer;
    } catch (e) {
      logger.e('Create customer error: $e');
      rethrow;
    }
  }

  Future<void> _syncCustomersFromServer() async {
    try {
      final customers = await _supabase.getCustomers();
      final entities = customers.map(_modelToEntity).toList();
      await _db.insertCustomers(entities);
    } catch (e) {
      logger.e('Sync customers from server error: $e');
    }
  }

  Future<void> _syncCustomerToServer(Customer customer) async {
    try {
      await _supabase.createCustomer(customer);
      // Mark as synced in local DB
      final entity = _modelToEntity(customer.copyWith(needsSync: false));
      await _db.insertCustomer(entity);
    } catch (e) {
      logger.e('Sync customer to server error: $e');
    }
  }

  Customer _entityToModel(CustomerEntity entity) {
    return Customer(
      id: entity.id,
      companyId: entity.companyId,
      code: entity.code,
      name: entity.name,
      email: entity.email,
      phone: entity.phone,
      address: entity.address,
      latitude: entity.latitude,
      longitude: entity.longitude,
      geoAccuracyM: entity.geoAccuracyM,
      createdBy: entity.createdBy,
      createdAt: entity.createdAt,
      updatedAt: entity.updatedAt,
    );
  }

  CustomerEntity _modelToEntity(Customer model) {
    return CustomerEntity(
      id: model.id,
      companyId: model.companyId,
      code: model.code,
      name: model.name,
      email: model.email,
      phone: model.phone,
      address: model.address,
      latitude: model.latitude,
      longitude: model.longitude,
      geoAccuracyM: model.geoAccuracyM,
      createdBy: model.createdBy,
      createdAt: model.createdAt,
      updatedAt: model.updatedAt,
      needsSync: false,
    );
  }
}


===== lib/data/repositories/auth_repository.dart =====
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/auth/user_profile.dart';
import '../local/preferences.dart';
import '../../config/logger.dart';

class AuthRepository {
  final SupabaseClient _supabase = Supabase.instance.client;

  Future<UserProfile?> signIn(String email, String password) async {
    try {
      final response = await _supabase.auth.signInWithPassword(
        email: email,
        password: password,
      );

      if (response.user != null) {
        final profile = await _fetchUserProfile(response.user!.id);
        if (profile != null) {
          await AppPreferences.setUserId(profile.id);
          await AppPreferences.setUserRole(profile.role.name);
        }
        return profile;
      }
      return null;
    } catch (e) {
      logger.e('Sign in error: $e');
      rethrow;
    }
  }

  Future<void> signOut() async {
    try {
      await _supabase.auth.signOut();
      await AppPreferences.clear();
    } catch (e) {
      logger.e('Sign out error: $e');
      rethrow;
    }
  }

  Future<UserProfile?> getCurrentUser() async {
    try {
      final user = _supabase.auth.currentUser;
      if (user != null) {
        return await _fetchUserProfile(user.id);
      }
      return null;
    } catch (e) {
      logger.e('Get current user error: $e');
      return null;
    }
  }

  Future<UserProfile?> _fetchUserProfile(String userId) async {
    try {
      final response = await _supabase
          .from('profiles')
          .select()
          .eq('id', userId)
          .maybeSingle();

      if (response != null) {
        return UserProfile.fromJson({
          ...response,
          'email': _supabase.auth.currentUser?.email,
        });
      }
      return null;
    } catch (e) {
      logger.e('Fetch user profile error: $e');
      return null;
    }
  }

  Stream<AuthState> get authStateChanges => _supabase.auth.onAuthStateChange;
}


===== lib/data/repositories/inventory_repository.dart =====
import '../models/sales/product.dart';
import '../local/drift/db.dart';
import '../remote/supabase_client.dart';
import '../../config/logger.dart';

class InventoryItem {
  final String id;
  final String productId;
  final String warehouseId;
  final double quantity;
  final double reservedQuantity;
  final DateTime updatedAt;
  final Product? product;

  InventoryItem({
    required this.id,
    required this.productId,
    required this.warehouseId,
    required this.quantity,
    required this.reservedQuantity,
    required this.updatedAt,
    this.product,
  });
}

class InventoryRepository {
  final DatabaseHelper _db = DatabaseHelper.instance;
  final SupabaseService _supabase = SupabaseService();

  Future<List<InventoryItem>> getInventory({String? warehouseId}) async {
    try {
      // TODO: Implement get inventory
      return [];
    } catch (e) {
      logger.e('Get inventory error: $e');
      return [];
    }
  }

  Future<double> getAvailableQuantity(
      String productId, String warehouseId) async {
    try {
      // TODO: Implement get available quantity
      return 0.0;
    } catch (e) {
      logger.e('Get available quantity error: $e');
      return 0.0;
    }
  }

  Future<void> reserveInventory(
      String productId, String warehouseId, double quantity) async {
    try {
      // TODO: Implement reserve inventory
    } catch (e) {
      logger.e('Reserve inventory error: $e');
      rethrow;
    }
  }

  Future<void> releaseInventory(
      String productId, String warehouseId, double quantity) async {
    try {
      // TODO: Implement release inventory
    } catch (e) {
      logger.e('Release inventory error: $e');
      rethrow;
    }
  }

  Future<void> updateInventory(
      String productId, String warehouseId, double newQuantity) async {
    try {
      // TODO: Implement update inventory
    } catch (e) {
      logger.e('Update inventory error: $e');
      rethrow;
    }
  }
}


===== lib/data/repositories/visits_repository.dart =====
import 'package:connectivity_plus/connectivity_plus.dart';
import '../models/visits/visit.dart';
import '../local/drift/db.dart';
import '../remote/supabase_client.dart';
import '../../config/logger.dart';

class VisitsRepository {
  final DatabaseHelper _db = DatabaseHelper.instance;
  final SupabaseService _supabase = SupabaseService();

  Future<List<Visit>> getVisitsByCustomer(String customerId) async {
    try {
      final entities = await _db.getVisitsByCustomer(customerId);
      return entities.map(_entityToModel).toList();
    } catch (e) {
      logger.e('Get visits by customer error: $e');
      return [];
    }
  }

  Future<Visit> startVisit(Visit visit) async {
    try {
      final entity = _modelToEntity(visit.copyWith(isSynced: false));
      await _db.insertVisit(entity);

      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        await _syncVisitToServer(visit);
      }

      return visit;
    } catch (e) {
      logger.e('Start visit error: $e');
      rethrow;
    }
  }

  Future<Visit> finishVisit(Visit visit) async {
    try {
      final entity = _modelToEntity(visit.copyWith(isSynced: false));
      await _db.insertVisit(entity);

      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        await _syncVisitToServer(visit);
      }

      return visit;
    } catch (e) {
      logger.e('Finish visit error: $e');
      rethrow;
    }
  }

  Future<void> syncPendingVisits() async {
    try {
      final pendingVisits = await _db.getPendingSyncVisits();

      for (final entity in pendingVisits) {
        final visit = _entityToModel(entity);
        await _syncVisitToServer(visit);
        await _db.markVisitSynced(visit.id);
      }
    } catch (e) {
      logger.e('Sync pending visits error: $e');
    }
  }

  Future<void> _syncVisitToServer(Visit visit) async {
    try {
      await _supabase.createVisit(visit);
    } catch (e) {
      logger.e('Sync visit to server error: $e');
    }
  }

  Visit _entityToModel(VisitEntity entity) {
    return Visit(
      id: entity.id,
      companyId: entity.companyId,
      customerId: entity.customerId,
      userId: entity.userId,
      purpose: _stringToVisitPurpose(entity.purpose),
      startedAt: entity.startedAt,
      finishedAt: entity.finishedAt,
      checkinLatitude: entity.checkinLatitude,
      checkinLongitude: entity.checkinLongitude,
      checkoutLatitude: entity.checkoutLatitude,
      checkoutLongitude: entity.checkoutLongitude,
      checkinAccuracyM: entity.checkinAccuracyM,
      checkoutAccuracyM: entity.checkoutAccuracyM,
      distanceM: entity.distanceM,
      notes: entity.notes,
      isSynced: entity.isSynced,
    );
  }

  VisitEntity _modelToEntity(Visit model) {
    return VisitEntity(
      id: model.id,
      companyId: model.companyId,
      customerId: model.customerId,
      userId: model.userId,
      purpose: model.purpose.name.toUpperCase(),
      startedAt: model.startedAt,
      finishedAt: model.finishedAt,
      checkinLatitude: model.checkinLatitude,
      checkinLongitude: model.checkinLongitude,
      checkoutLatitude: model.checkoutLatitude,
      checkoutLongitude: model.checkoutLongitude,
      checkinAccuracyM: model.checkinAccuracyM,
      checkoutAccuracyM: model.checkoutAccuracyM,
      distanceM: model.distanceM,
      notes: model.notes,
      isSynced: model.isSynced,
    );
  }

  VisitPurpose _stringToVisitPurpose(String purpose) {
    switch (purpose.toUpperCase()) {
      case 'VENTA':
        return VisitPurpose.venta;
      case 'COBRO':
        return VisitPurpose.cobro;
      case 'ENTREGA':
        return VisitPurpose.entrega;
      case 'VISITA':
        return VisitPurpose.visita;
      case 'AUDITORIA':
        return VisitPurpose.auditoria;
      case 'DEVOLUCION':
        return VisitPurpose.devolucion;
      default:
        return VisitPurpose.otro;
    }
  }
}


===== lib/data/repositories/deliveries_repository.dart =====
import 'package:connectivity_plus/connectivity_plus.dart';
import '../models/sales/order.dart';
import '../local/drift/db.dart';
import '../remote/supabase_client.dart';
import '../../config/logger.dart';

enum DeliveryStatus { pending, partial, delivered, rejected }

class DeliveryModel {
  final String id;
  final String orderId;
  final DeliveryStatus status;
  final DateTime? deliveredAt;
  final String? notes;
  final Order? order;

  DeliveryModel({
    required this.id,
    required this.orderId,
    required this.status,
    this.deliveredAt,
    this.notes,
    this.order,
  });
}

class DeliveriesRepository {
  final DatabaseHelper _db = DatabaseHelper.instance;
  final SupabaseService _supabase = SupabaseService();

  Future<List<DeliveryModel>> getDeliveries({bool forceSync = false}) async {
    try {
      final connectivity = await Connectivity().checkConnectivity();
      final isOnline = connectivity != ConnectivityResult.none;

      if (isOnline && forceSync) {
        await _syncDeliveriesFromServer();
      }

      // For now, return mock data
      return [
        DeliveryModel(
          id: '1',
          orderId: 'order_1',
          status: DeliveryStatus.pending,
        ),
        DeliveryModel(
          id: '2',
          orderId: 'order_2',
          status: DeliveryStatus.delivered,
          deliveredAt: DateTime.now().subtract(const Duration(hours: 2)),
        ),
      ];
    } catch (e) {
      logger.e('Get deliveries error: $e');
      return [];
    }
  }

  Future<DeliveryModel> confirmDelivery(
    String deliveryId,
    DeliveryStatus status,
    String? notes,
  ) async {
    try {
      // TODO: Implement delivery confirmation
      final delivery = DeliveryModel(
        id: deliveryId,
        orderId: 'order_id',
        status: status,
        deliveredAt: status == DeliveryStatus.delivered ? DateTime.now() : null,
        notes: notes,
      );

      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        await _syncDeliveryToServer(delivery);
      }

      return delivery;
    } catch (e) {
      logger.e('Confirm delivery error: $e');
      rethrow;
    }
  }

  Future<void> _syncDeliveriesFromServer() async {
    try {
      // TODO: Implement sync from server
    } catch (e) {
      logger.e('Sync deliveries from server error: $e');
    }
  }

  Future<void> _syncDeliveryToServer(DeliveryModel delivery) async {
    try {
      // TODO: Implement sync to server
    } catch (e) {
      logger.e('Sync delivery to server error: $e');
    }
  }
}


===== lib/data/repositories/forms_repository.dart =====
import 'package:connectivity_plus/connectivity_plus.dart';
import '../remote/supabase_client.dart';
import '../../config/logger.dart';

class FormTemplate {
  final String id;
  final String companyId;
  final String name;
  final Map<String, dynamic> schema;
  final DateTime createdAt;

  FormTemplate({
    required this.id,
    required this.companyId,
    required this.name,
    required this.schema,
    required this.createdAt,
  });
}

class FormResponse {
  final String id;
  final String? templateId;
  final String? customerId;
  final String? visitId;
  final String? userId;
  final Map<String, dynamic> answers;
  final DateTime createdAt;

  FormResponse({
    required this.id,
    this.templateId,
    this.customerId,
    this.visitId,
    this.userId,
    required this.answers,
    required this.createdAt,
  });
}

class FormsRepository {
  final SupabaseService _supabase = SupabaseService();

  Future<List<FormTemplate>> getFormTemplates() async {
    try {
      // TODO: Implement get form templates
      return [];
    } catch (e) {
      logger.e('Get form templates error: $e');
      return [];
    }
  }

  Future<FormResponse> submitFormResponse(FormResponse response) async {
    try {
      // TODO: Implement submit form response
      return response;
    } catch (e) {
      logger.e('Submit form response error: $e');
      rethrow;
    }
  }

  Future<List<FormResponse>> getFormResponses({
    String? templateId,
    String? customerId,
    String? visitId,
  }) async {
    try {
      // TODO: Implement get form responses
      return [];
    } catch (e) {
      logger.e('Get form responses error: $e');
      return [];
    }
  }
}


===== lib/data/repositories/payments_repository.dart =====
import 'package:connectivity_plus/connectivity_plus.dart';
import '../models/customers/customer.dart';
import '../local/drift/db.dart';
import '../remote/supabase_client.dart';
import '../../config/logger.dart';

class PaymentModel {
  final String id;
  final String? orderId;
  final String? customerId;
  final String? userId;
  final double amount;
  final String? method;
  final DateTime paidAt;
  final String? notes;
  final String status;
  final Customer? customer;

  PaymentModel({
    required this.id,
    this.orderId,
    this.customerId,
    this.userId,
    required this.amount,
    this.method,
    required this.paidAt,
    this.notes,
    required this.status,
    this.customer,
  });
}

class PaymentsRepository {
  final DatabaseHelper _db = DatabaseHelper.instance;
  final SupabaseService _supabase = SupabaseService();

  Future<List<PaymentModel>> getPayments({bool forceSync = false}) async {
    try {
      final connectivity = await Connectivity().checkConnectivity();
      final isOnline = connectivity != ConnectivityResult.none;

      if (isOnline && forceSync) {
        await _syncPaymentsFromServer();
      }

      // For now, return mock data
      return [
        PaymentModel(
          id: '1',
          customerId: 'customer_1',
          amount: 2500.00,
          method: 'EFECTIVO',
          paidAt: DateTime.now().subtract(const Duration(hours: 1)),
          status: 'PENDING',
          customer: Customer(
            id: 'customer_1',
            companyId: 'company_id',
            name: 'Cliente Ejemplo 1',
          ),
        ),
        PaymentModel(
          id: '2',
          customerId: 'customer_2',
          amount: 1800.00,
          method: 'TARJETA',
          paidAt: DateTime.now().subtract(const Duration(days: 1)),
          status: 'COMPLETED',
          customer: Customer(
            id: 'customer_2',
            companyId: 'company_id',
            name: 'Cliente Ejemplo 2',
          ),
        ),
      ];
    } catch (e) {
      logger.e('Get payments error: $e');
      return [];
    }
  }

  Future<PaymentModel> registerPayment(PaymentModel payment) async {
    try {
      // TODO: Save locally first, then sync

      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none) {
        await _syncPaymentToServer(payment);
      }

      return payment;
    } catch (e) {
      logger.e('Register payment error: $e');
      rethrow;
    }
  }

  Future<List<PaymentModel>> getPendingPayments() async {
    try {
      final payments = await getPayments();
      return payments.where((p) => p.status == 'PENDING').toList();
    } catch (e) {
      logger.e('Get pending payments error: $e');
      return [];
    }
  }

  Future<void> _syncPaymentsFromServer() async {
    try {
      // TODO: Implement sync from server
    } catch (e) {
      logger.e('Sync payments from server error: $e');
    }
  }

  Future<void> _syncPaymentToServer(PaymentModel payment) async {
    try {
      // TODO: Implement sync to server
    } catch (e) {
      logger.e('Sync payment to server error: $e');
    }
  }
}


===== lib/data/models/customers/customer.dart =====
import 'package:freezed_annotation/freezed_annotation.dart';

part 'customer.freezed.dart';
part 'customer.g.dart';

@freezed
class Customer with _$Customer {
  const factory Customer({
    required String id,
    required String companyId,
    String? code,
    required String name,
    String? email,
    String? phone,
    String? address,
    double? latitude,
    double? longitude,
    double? geoAccuracyM,
    String? createdBy,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) = _Customer;

  factory Customer.fromJson(Map<String, dynamic> json) =>
      _$CustomerFromJson(json);
}

@freezed
class Address with _$Address {
  const factory Address({
    required String street,
    required String city,
    required String state,
    required String zipCode,
    String? country,
    double? latitude,
    double? longitude,
  }) = _Address;

  factory Address.fromJson(Map<String, dynamic> json) =>
      _$AddressFromJson(json);
}


===== lib/data/models/sales/product.dart =====
import 'package:freezed_annotation/freezed_annotation.dart';

part 'product.freezed.dart';
part 'product.g.dart';

@freezed
class Product with _$Product {
  const factory Product({
    required String id,
    required String companyId,
    String? sku,
    required String name,
    String? unit,
    @Default(0.0) double tax,
    @Default(true) bool active,
    DateTime? createdAt,
  }) = _Product;

  factory Product.fromJson(Map<String, dynamic> json) =>
      _$ProductFromJson(json);
}

@freezed
class PriceList with _$PriceList {
  const factory PriceList({
    required String id,
    required String companyId,
    required String name,
    @Default('USD') String currency,
    DateTime? createdAt,
    @Default([]) List<Price> prices,
  }) = _PriceList;

  factory PriceList.fromJson(Map<String, dynamic> json) =>
      _$PriceListFromJson(json);
}

@freezed
class Price with _$Price {
  const factory Price({
    required String id,
    required String priceListId,
    required String productId,
    required double price,
    Product? product,
  }) = _Price;

  factory Price.fromJson(Map<String, dynamic> json) => _$PriceFromJson(json);
}


===== lib/data/models/sales/order.dart =====
import 'package:freezed_annotation/freezed_annotation.dart';
import 'product.dart';

part 'order.freezed.dart';
part 'order.g.dart';

enum OrderStatus {
  @JsonValue('DRAFT')
  draft,
  @JsonValue('SENT')
  sent,
  @JsonValue('APPROVED')
  approved,
  @JsonValue('REJECTED')
  rejected,
  @JsonValue('DELIVERED')
  delivered,
  @JsonValue('CANCELLED')
  cancelled,
}

@freezed
class Order with _$Order {
  const factory Order({
    required String id,
    required String companyId,
    String? customerId,
    String? userId,
    String? priceListId,
    @Default(OrderStatus.draft) OrderStatus status,
    @Default(0.0) double subtotal,
    @Default(0.0) double taxTotal,
    @Default(0.0) double discountTotal,
    @Default(0.0) double grandTotal,
    DateTime? createdAt,
    // Relations
    Customer? customer,
    @Default([]) List<OrderItem> items,
  }) = _Order;

  factory Order.fromJson(Map<String, dynamic> json) => _$OrderFromJson(json);
}

@freezed
class OrderItem with _$OrderItem {
  const factory OrderItem({
    required String id,
    required String orderId,
    required String productId,
    required double qty,
    required double price,
    @Default(0.0) double discount,
    required double total,
    Product? product,
  }) = _OrderItem;

  factory OrderItem.fromJson(Map<String, dynamic> json) =>
      _$OrderItemFromJson(json);
}


===== lib/data/models/sales/promotion.dart =====
import 'package:freezed_annotation/freezed_annotation.dart';
import 'product.dart';

part 'promotion.freezed.dart';
part 'promotion.g.dart';

@freezed
class Promotion with _$Promotion {
  const factory Promotion({
    required String id,
    required String companyId,
    required String name,
    String? description,
    required PromotionType type,
    required Map<String, dynamic> rules,
    required DateTime startsAt,
    required DateTime endsAt,
    @Default(true) bool active,
    @Default(0) int priority,
    @Default(0) int usageLimit,
    @Default(0) int usageCount,
    @Default([]) List<String> applicableProducts,
    @Default([]) List<String> applicableCategories,
    @Default([]) List<String> applicableCustomers,
    @Default([]) List<String> excludedProducts,
    @Default([]) List<String> excludedCustomers,
    double? minimumOrderAmount,
    double? maximumDiscount,
    @Default([]) List<DayOfWeek> applicableDays,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    DateTime? createdAt,
    String? createdBy,
  }) = _Promotion;

  factory Promotion.fromJson(Map<String, dynamic> json) =>
      _$PromotionFromJson(json);
}

@freezed
class PromotionResult with _$PromotionResult {
  const factory PromotionResult({
    required String promotionId,
    required String promotionName,
    required PromotionType type,
    required double discountAmount,
    double? discountPercentage,
    @Default([]) List<String> affectedProducts,
    @Default([]) List<PromotionItem> freeItems,
    String? description,
  }) = _PromotionResult;

  factory PromotionResult.fromJson(Map<String, dynamic> json) =>
      _$PromotionResultFromJson(json);
}

@freezed
class PromotionItem with _$PromotionItem {
  const factory PromotionItem({
    required String productId,
    required double quantity,
    Product? product,
  }) = _PromotionItem;

  factory PromotionItem.fromJson(Map<String, dynamic> json) =>
      _$PromotionItemFromJson(json);
}

enum PromotionType {
  @JsonValue('PERCENTAGE_DISCOUNT')
  percentageDiscount,
  @JsonValue('FIXED_DISCOUNT')
  fixedDiscount,
  @JsonValue('BUY_X_GET_Y')
  buyXGetY,
  @JsonValue('FREE_SHIPPING')
  freeShipping,
  @JsonValue('BUNDLE_DISCOUNT')
  bundleDiscount,
  @JsonValue('VOLUME_DISCOUNT')
  volumeDiscount,
  @JsonValue('FIRST_TIME_BUYER')
  firstTimeBuyer,
  @JsonValue('LOYALTY_DISCOUNT')
  loyaltyDiscount,
}

enum DayOfWeek {
  @JsonValue(1)
  monday,
  @JsonValue(2)
  tuesday,
  @JsonValue(3)
  wednesday,
  @JsonValue(4)
  thursday,
  @JsonValue(5)
  friday,
  @JsonValue(6)
  saturday,
  @JsonValue(7)
  sunday,
}

@freezed
class TimeOfDay with _$TimeOfDay {
  const factory TimeOfDay({
    required int hour,
    required int minute,
  }) = _TimeOfDay;

  factory TimeOfDay.fromJson(Map<String, dynamic> json) =>
      _$TimeOfDayFromJson(json);
}

// Extensions for easier usage
extension PromotionX on Promotion {
  /// Check if promotion is currently active
  bool get isCurrentlyActive {
    if (!active) return false;

    final now = DateTime.now();
    if (now.isBefore(startsAt) || now.isAfter(endsAt)) {
      return false;
    }

    // Check usage limit
    if (usageLimit > 0 && usageCount >= usageLimit) {
      return false;
    }

    // Check day of week
    if (applicableDays.isNotEmpty) {
      final currentDay = DayOfWeek.values[now.weekday - 1];
      if (!applicableDays.contains(currentDay)) {
        return false;
      }
    }

    // Check time range
    if (startTime != null && endTime != null) {
      final currentTime = TimeOfDay(hour: now.hour, minute: now.minute);
      if (!_isTimeInRange(currentTime, startTime!, endTime!)) {
        return false;
      }
    }

    return true;
  }

  /// Check if product is applicable for this promotion
  bool isProductApplicable(String productId) {
    // Check excluded products first
    if (excludedProducts.contains(productId)) {
      return false;
    }

    // If specific products are defined, check inclusion
    if (applicableProducts.isNotEmpty) {
      return applicableProducts.contains(productId);
    }

    // If categories are defined, would need to check product category
    // This would require product information

    return true;
  }

  /// Check if customer is applicable for this promotion
  bool isCustomerApplicable(String customerId) {
    // Check excluded customers first
    if (excludedCustomers.contains(customerId)) {
      return false;
    }

    // If specific customers are defined, check inclusion
    if (applicableCustomers.isNotEmpty) {
      return applicableCustomers.contains(customerId);
    }

    return true;
  }

  /// Check if order meets minimum amount requirement
  bool meetsMinimumAmount(double orderAmount) {
    return minimumOrderAmount == null || orderAmount >= minimumOrderAmount!;
  }

  /// Get promotion description for display
  String get displayDescription {
    switch (type) {
      case PromotionType.percentageDiscount:
        final percentage = rules['percentage'] ?? 0;
        return '$percentage% de descuento';
      case PromotionType.fixedDiscount:
        final amount = rules['amount'] ?? 0;
        return '\$$amount de descuento';
      case PromotionType.buyXGetY:
        final buyQty = rules['buyQuantity'] ?? 1;
        final getQty = rules['getQuantity'] ?? 1;
        return 'Compra $buyQty lleva $getQty gratis';
      case PromotionType.freeShipping:
        return 'Envío gratis';
      case PromotionType.bundleDiscount:
        return 'Descuento por paquete';
      case PromotionType.volumeDiscount:
        return 'Descuento por volumen';
      case PromotionType.firstTimeBuyer:
        return 'Descuento primera compra';
      case PromotionType.loyaltyDiscount:
        return 'Descuento por lealtad';
    }
  }

  bool _isTimeInRange(TimeOfDay current, TimeOfDay start, TimeOfDay end) {
    final currentMinutes = current.hour * 60 + current.minute;
    final startMinutes = start.hour * 60 + start.minute;
    final endMinutes = end.hour * 60 + end.minute;

    if (startMinutes <= endMinutes) {
      // Same day range
      return currentMinutes >= startMinutes && currentMinutes <= endMinutes;
    } else {
      // Overnight range
      return currentMinutes >= startMinutes || currentMinutes <= endMinutes;
    }
  }
}

extension PromotionTypeX on PromotionType {
  String get displayName {
    switch (this) {
      case PromotionType.percentageDiscount:
        return 'Descuento por Porcentaje';
      case PromotionType.fixedDiscount:
        return 'Descuento Fijo';
      case PromotionType.buyXGetY:
        return 'Compra X Lleva Y';
      case PromotionType.freeShipping:
        return 'Envío Gratis';
      case PromotionType.bundleDiscount:
        return 'Descuento por Paquete';
      case PromotionType.volumeDiscount:
        return 'Descuento por Volumen';
      case PromotionType.firstTimeBuyer:
        return 'Primera Compra';
      case PromotionType.loyaltyDiscount:
        return 'Descuento por Lealtad';
    }
  }

  IconData get icon {
    switch (this) {
      case PromotionType.percentageDiscount:
        return Icons.percent;
      case PromotionType.fixedDiscount:
        return Icons.money_off;
      case PromotionType.buyXGetY:
        return Icons.add_shopping_cart;
      case PromotionType.freeShipping:
        return Icons.local_shipping;
      case PromotionType.bundleDiscount:
        return Icons.inventory;
      case PromotionType.volumeDiscount:
        return Icons.scale;
      case PromotionType.firstTimeBuyer:
        return Icons.new_releases;
      case PromotionType.loyaltyDiscount:
        return Icons.star;
    }
  }
}

extension DayOfWeekX on DayOfWeek {
  String get displayName {
    switch (this) {
      case DayOfWeek.monday:
        return 'Lunes';
      case DayOfWeek.tuesday:
        return 'Martes';
      case DayOfWeek.wednesday:
        return 'Miércoles';
      case DayOfWeek.thursday:
        return 'Jueves';
      case DayOfWeek.friday:
        return 'Viernes';
      case DayOfWeek.saturday:
        return 'Sábado';
      case DayOfWeek.sunday:
        return 'Domingo';
    }
  }

  String get shortName {
    switch (this) {
      case DayOfWeek.monday:
        return 'Lun';
      case DayOfWeek.tuesday:
        return 'Mar';
      case DayOfWeek.wednesday:
        return 'Mié';
      case DayOfWeek.thursday:
        return 'Jue';
      case DayOfWeek.friday:
        return 'Vie';
      case DayOfWeek.saturday:
        return 'Sáb';
      case DayOfWeek.sunday:
        return 'Dom';
    }
  }
}

// Promotion Engine for applying promotions
class PromotionEngine {
  /// Apply promotions to an order
  static List<PromotionResult> applyPromotions({
    required List<Promotion> promotions,
    required List<OrderItemModel> orderItems,
    required String customerId,
    required double orderTotal,
  }) {
    final results = <PromotionResult>[];

    // Sort promotions by priority (higher priority first)
    final sortedPromotions = List<Promotion>.from(promotions)
      ..sort((a, b) => b.priority.compareTo(a.priority));

    for (final promotion in sortedPromotions) {
      if (!promotion.isCurrentlyActive) continue;
      if (!promotion.isCustomerApplicable(customerId)) continue;
      if (!promotion.meetsMinimumAmount(orderTotal)) continue;

      final result = _applyPromotion(promotion, orderItems, orderTotal);
      if (result != null) {
        results.add(result);
      }
    }

    return results;
  }

  static PromotionResult? _applyPromotion(
    Promotion promotion,
    List<OrderItemModel> orderItems,
    double orderTotal,
  ) {
    switch (promotion.type) {
      case PromotionType.percentageDiscount:
        return _applyPercentageDiscount(promotion, orderItems, orderTotal);
      case PromotionType.fixedDiscount:
        return _applyFixedDiscount(promotion, orderTotal);
      case PromotionType.buyXGetY:
        return _applyBuyXGetY(promotion, orderItems);
      case PromotionType.volumeDiscount:
        return _applyVolumeDiscount(promotion, orderItems);
      default:
        return null;
    }
  }

  static PromotionResult? _applyPercentageDiscount(
    Promotion promotion,
    List<OrderItemModel> orderItems,
    double orderTotal,
  ) {
    final percentage = promotion.rules['percentage']?.toDouble() ?? 0;
    if (percentage <= 0) return null;

    final applicableItems = orderItems
        .where((item) => promotion.isProductApplicable(item.productId))
        .toList();

    if (applicableItems.isEmpty) return null;

    final applicableTotal =
        applicableItems.fold<double>(0, (sum, item) => sum + item.total);

    double discountAmount = applicableTotal * (percentage / 100);

    // Apply maximum discount limit
    if (promotion.maximumDiscount != null &&
        discountAmount > promotion.maximumDiscount!) {
      discountAmount = promotion.maximumDiscount!;
    }

    return PromotionResult(
      promotionId: promotion.id,
      promotionName: promotion.name,
      type: promotion.type,
      discountAmount: discountAmount,
      discountPercentage: percentage,
      affectedProducts: applicableItems.map((item) => item.productId).toList(),
      description: '${percentage.toStringAsFixed(1)}% de descuento',
    );
  }

  static PromotionResult? _applyFixedDiscount(
    Promotion promotion,
    double orderTotal,
  ) {
    final amount = promotion.rules['amount']?.toDouble() ?? 0;
    if (amount <= 0) return null;

    final discountAmount = amount > orderTotal ? orderTotal : amount;

    return PromotionResult(
      promotionId: promotion.id,
      promotionName: promotion.name,
      type: promotion.type,
      discountAmount: discountAmount,
      description: '\$${amount.toStringAsFixed(2)} de descuento',
    );
  }

  static PromotionResult? _applyBuyXGetY(
    Promotion promotion,
    List<OrderItemModel> orderItems,
  ) {
    final buyQuantity = promotion.rules['buyQuantity']?.toInt() ?? 1;
    final getQuantity = promotion.rules['getQuantity']?.toInt() ?? 1;
    final buyProductId = promotion.rules['buyProductId'] as String?;
    final getProductId = promotion.rules['getProductId'] as String?;

    if (buyProductId == null || getProductId == null) return null;

    final buyItem = orderItems.firstWhere(
      (item) => item.productId == buyProductId,
      orElse: () => null,
    );

    if (buyItem == null || buyItem.qty < buyQuantity) return null;

    final sets = (buyItem.qty / buyQuantity).floor();
    final freeQuantity = sets * getQuantity;

    final freeItems = [
      PromotionItem(
        productId: getProductId,
        quantity: freeQuantity.toDouble(),
      ),
    ];

    return PromotionResult(
      promotionId: promotion.id,
      promotionName: promotion.name,
      type: promotion.type,
      discountAmount: 0, // Free items, no direct discount
      freeItems: freeItems,
      description: 'Compra $buyQuantity lleva $getQuantity gratis',
    );
  }

  static PromotionResult? _applyVolumeDiscount(
    Promotion promotion,
    List<OrderItemModel> orderItems,
  ) {
    final tiers = promotion.rules['tiers'] as List<dynamic>? ?? [];
    if (tiers.isEmpty) return null;

    final totalQuantity =
        orderItems.fold<double>(0, (sum, item) => sum + item.qty);

    // Find applicable tier
    Map<String, dynamic>? applicableTier;
    for (final tier in tiers) {
      final minQty = tier['minQuantity']?.toDouble() ?? 0;
      if (totalQuantity >= minQty) {
        applicableTier = tier;
      }
    }

    if (applicableTier == null) return null;

    final discountPercentage =
        applicableTier['discountPercentage']?.toDouble() ?? 0;
    if (discountPercentage <= 0) return null;

    final orderTotal =
        orderItems.fold<double>(0, (sum, item) => sum + item.total);
    final discountAmount = orderTotal * (discountPercentage / 100);

    return PromotionResult(
      promotionId: promotion.id,
      promotionName: promotion.name,
      type: promotion.type,
      discountAmount: discountAmount,
      discountPercentage: discountPercentage,
      affectedProducts: orderItems.map((item) => item.productId).toList(),
      description:
          '${discountPercentage.toStringAsFixed(1)}% descuento por volumen',
    );
  }
}

// Mock OrderItemModel for the promotion engine
class OrderItemModel {
  final String productId;
  final double qty;
  final double price;
  final double total;

  OrderItemModel({
    required this.productId,
    required this.qty,
    required this.price,
    required this.total,
  });
}


===== lib/data/models/sales/price_list.dart =====
import 'package:freezed_annotation/freezed_annotation.dart';
import 'product.dart';

part 'price_list.freezed.dart';
part 'price_list.g.dart';

@freezed
class PriceListModel with _$PriceListModel {
  const factory PriceListModel({
    required String id,
    required String companyId,
    required String name,
    String? description,
    @Default('USD') String currency,
    @Default(true) bool isActive,
    @Default(false) bool isDefault,
    DateTime? validFrom,
    DateTime? validTo,
    DateTime? createdAt,
    DateTime? updatedAt,
    @Default([]) List<PriceModel> prices,
    CustomerSegment? targetSegment,
    PriceListType? type,
  }) = _PriceListModel;

  factory PriceListModel.fromJson(Map<String, dynamic> json) =>
      _$PriceListModelFromJson(json);
}

@freezed
class PriceModel with _$PriceModel {
  const factory PriceModel({
    required String id,
    required String priceListId,
    required String productId,
    required double price,
    double? costPrice,
    double? margin,
    double? minQuantity,
    double? maxQuantity,
    DateTime? validFrom,
    DateTime? validTo,
    @Default(true) bool isActive,
    Product? product,
    PriceUnit? unit,
    @Default([]) List<PriceTier> tiers,
  }) = _PriceModel;

  factory PriceModel.fromJson(Map<String, dynamic> json) =>
      _$PriceModelFromJson(json);
}

@freezed
class PriceTier with _$PriceTier {
  const factory PriceTier({
    required double minQuantity,
    required double price,
    double? maxQuantity,
    double? discountPercentage,
  }) = _PriceTier;

  factory PriceTier.fromJson(Map<String, dynamic> json) =>
      _$PriceTierFromJson(json);
}

enum PriceListType {
  @JsonValue('STANDARD')
  standard,
  @JsonValue('WHOLESALE')
  wholesale,
  @JsonValue('RETAIL')
  retail,
  @JsonValue('PROMOTIONAL')
  promotional,
  @JsonValue('SEASONAL')
  seasonal,
  @JsonValue('VOLUME')
  volume,
  @JsonValue('CUSTOMER_SPECIFIC')
  customerSpecific,
}

enum CustomerSegment {
  @JsonValue('GENERAL')
  general,
  @JsonValue('VIP')
  vip,
  @JsonValue('WHOLESALE')
  wholesale,
  @JsonValue('RETAIL')
  retail,
  @JsonValue('DISTRIBUTOR')
  distributor,
  @JsonValue('CORPORATE')
  corporate,
}

enum PriceUnit {
  @JsonValue('UNIT')
  unit,
  @JsonValue('KILOGRAM')
  kilogram,
  @JsonValue('LITER')
  liter,
  @JsonValue('METER')
  meter,
  @JsonValue('SQUARE_METER')
  squareMeter,
  @JsonValue('BOX')
  box,
  @JsonValue('DOZEN')
  dozen,
  @JsonValue('CASE')
  case,
}

// Helper extensions
extension PriceListModelX on PriceListModel {
  /// Check if price list is currently valid
  bool get isCurrentlyValid {
    final now = DateTime.now();
    
    if (validFrom != null && now.isBefore(validFrom!)) {
      return false;
    }
    
    if (validTo != null && now.isAfter(validTo!)) {
      return false;
    }
    
    return isActive;
  }

  /// Get price for a specific product
  PriceModel? getPriceForProduct(String productId) {
    try {
      return prices.firstWhere((price) => 
          price.productId == productId && price.isActive);
    } catch (e) {
      return null;
    }
  }

  /// Get all active prices
  List<PriceModel> get activePrices {
    return prices.where((price) => price.isActive).toList();
  }

  /// Get price count
  int get priceCount => activePrices.length;

  /// Get average price
  double get averagePrice {
    final active = activePrices;
    if (active.isEmpty) return 0;
    
    return active.fold<double>(0, (sum, price) => sum + price.price) / 
           active.length;
  }

  /// Get price range
  PriceRange get priceRange {
    final active = activePrices;
    if (active.isEmpty) {
      return const PriceRange(min: 0, max: 0);
    }
    
    double min = active.first.price;
    double max = active.first.price;
    
    for (final price in active) {
      if (price.price < min) min = price.price;
      if (price.price > max) max = price.price;
    }
    
    return PriceRange(min: min, max: max);
  }

  /// Format currency
  String formatPrice(double amount) {
    return '$currency ${amount.toStringAsFixed(2)}';
  }
}

extension PriceModelX on PriceModel {
  /// Check if price is currently valid
  bool get isCurrentlyValid {
    final now = DateTime.now();
    
    if (validFrom != null && now.isBefore(validFrom!)) {
      return false;
    }
    
    if (validTo != null && now.isAfter(validTo!)) {
      return false;
    }
    
    return isActive;
  }

  /// Get price for specific quantity
  double getPriceForQuantity(double quantity) {
    if (tiers.isEmpty) return price;
    
    // Find applicable tier
    PriceTier? applicableTier;
    
    for (final tier in tiers) {
      if (quantity >= tier.minQuantity) {
        if (tier.maxQuantity == null || quantity <= tier.maxQuantity!) {
          applicableTier = tier;
          break;
        }
      }
    }
    
    return applicableTier?.price ?? price;
  }

  /// Get discount percentage for quantity
  double getDiscountForQuantity(double quantity) {
    if (tiers.isEmpty) return 0;
    
    for (final tier in tiers) {
      if (quantity >= tier.minQuantity) {
        if (tier.maxQuantity == null || quantity <= tier.maxQuantity!) {
          return tier.discountPercentage ?? 0;
        }
      }
    }
    
    return 0;
  }

  /// Calculate profit margin
  double get profitMargin {
    if (costPrice == null || costPrice == 0) return 0;
    return ((price - costPrice!) / price) * 100;
  }

  /// Check if quantity is within valid range
  bool isQuantityValid(double quantity) {
    if (minQuantity != null && quantity < minQuantity!) return false;
    if (maxQuantity != null && quantity > maxQuantity!) return false;
    return true;
  }
}

extension PriceListTypeX on PriceListType {
  String get displayName {
    switch (this) {
      case PriceListType.standard:
        return 'Estándar';
      case PriceListType.wholesale:
        return 'Mayoreo';
      case PriceListType.retail:
        return 'Menudeo';
      case PriceListType.promotional:
        return 'Promocional';
      case PriceListType.seasonal:
        return 'Temporal';
      case PriceListType.volume:
        return 'Por Volumen';
      case PriceListType.customerSpecific:
        return 'Cliente Específico';
    }
  }

  int get priority {
    switch (this) {
      case PriceListType.customerSpecific:
        return 1;
      case PriceListType.promotional:
        return 2;
      case PriceListType.seasonal:
        return 3;
      case PriceListType.volume:
        return 4;
      case PriceListType.wholesale:
        return 5;
      case PriceListType.retail:
        return 6;
      case PriceListType.standard:
        return 7;
    }
  }
}

extension CustomerSegmentX on CustomerSegment {
  String get displayName {
    switch (this) {
      case CustomerSegment.general:
        return 'General';
      case CustomerSegment.vip:
        return 'VIP';
      case CustomerSegment.wholesale:
        return 'Mayorista';
      case CustomerSegment.retail:
        return 'Detallista';
      case CustomerSegment.distributor:
        return 'Distribuidor';
      case CustomerSegment.corporate:
        return 'Corporativo';
    }
  }
}

extension PriceUnitX on PriceUnit {
  String get displayName {
    switch (this) {
      case PriceUnit.unit:
        return 'Unidad';
      case PriceUnit.kilogram:
        return 'Kilogramo';
      case PriceUnit.liter:
        return 'Litro';
      case PriceUnit.meter:
        return 'Metro';
      case PriceUnit.squareMeter:
        return 'Metro²';
      case PriceUnit.box:
        return 'Caja';
      case PriceUnit.dozen:
        return 'Docena';
      case PriceUnit.case:
        return 'Estuche';
    }
  }

  String get abbreviation {
    switch (this) {
      case PriceUnit.unit:
        return 'ud';
      case PriceUnit.kilogram:
        return 'kg';
      case PriceUnit.liter:
        return 'l';
      case PriceUnit.meter:
        return 'm';
      case PriceUnit.squareMeter:
        return 'm²';
      case PriceUnit.box:
        return 'cja';
      case PriceUnit.dozen:
        return 'doc';
      case PriceUnit.case:
        return 'est';
    }
  }
}

@freezed
class PriceRange with _$PriceRange {
  const factory PriceRange({
    required double min,
    required double max,
  }) = _PriceRange;
  
  factory PriceRange.fromJson(Map<String, dynamic> json) =>
      _$PriceRangeFromJson(json);
}

// Price calculation utilities
class PriceCalculator {
  /// Calculate final price with discounts and taxes
  static double calculateFinalPrice({
    required double basePrice,
    double discountPercentage = 0,
    double discountAmount = 0,
    double taxPercentage = 0,
    double quantity = 1,
  }) {
    double price = basePrice * quantity;
    
    // Apply percentage discount
    if (discountPercentage > 0) {
      price = price * (1 - discountPercentage / 100);
    }
    
    // Apply fixed discount
    if (discountAmount > 0) {
      price = price - discountAmount;
    }
    
    // Apply tax
    if (taxPercentage > 0) {
      price = price * (1 + taxPercentage / 100);
    }
    
    return price < 0 ? 0 : price;
  }

  /// Calculate discount amount
  static double calculateDiscountAmount({
    required double basePrice,
    required double discountPercentage,
    double quantity = 1,
  }) {
    return basePrice * quantity * (discountPercentage / 100);
  }

  /// Calculate tax amount
  static double calculateTaxAmount({
    required double netPrice,
    required double taxPercentage,
  }) {
    return netPrice * (taxPercentage / 100);
  }

  /// Calculate profit margin
  static double calculateMargin({
    required double sellingPrice,
    required double costPrice,
  }) {
    if (sellingPrice == 0) return 0;
    return ((sellingPrice - costPrice) / sellingPrice) * 100;
  }

  /// Calculate markup
  static double calculateMarkup({
    required double sellingPrice,
    required double costPrice,
  }) {
    if (costPrice == 0) return 0;
    return ((sellingPrice - costPrice) / costPrice) * 100;
  }
}

===== lib/data/models/auth/user_profile.dart =====
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_profile.freezed.dart';
part 'user_profile.g.dart';

enum UserRole {
  @JsonValue('ADMIN')
  admin,
  @JsonValue('SUPERVISOR')
  supervisor,
  @JsonValue('VENDEDOR')
  vendedor,
  @JsonValue('REPARTIDOR')
  repartidor
}

@freezed
class UserProfile with _$UserProfile {
  const factory UserProfile({
    required String id,
    String? companyId,
    String? fullName,
    String? phone,
    String? email,
    @Default(UserRole.vendedor) UserRole role,
    @Default(true) bool isActive,
    DateTime? createdAt,
  }) = _UserProfile;

  factory UserProfile.fromJson(Map<String, dynamic> json) =>
      _$UserProfileFromJson(json);
}


===== lib/data/models/visits/visit.dart =====
import 'package:freezed_annotation/freezed_annotation.dart';

part 'visit.freezed.dart';
part 'visit.g.dart';

enum VisitPurpose {
  @JsonValue('VENTA')
  venta,
  @JsonValue('COBRO')
  cobro,
  @JsonValue('ENTREGA')
  entrega,
  @JsonValue('VISITA')
  visita,
  @JsonValue('AUDITORIA')
  auditoria,
  @JsonValue('DEVOLUCION')
  devolucion,
  @JsonValue('OTRO')
  otro,
}

@freezed
class Visit with _$Visit {
  const factory Visit({
    required String id,
    required String companyId,
    required String customerId,
    String? userId,
    required VisitPurpose purpose,
    DateTime? startedAt,
    DateTime? finishedAt,
    double? checkinLatitude,
    double? checkinLongitude,
    double? checkoutLatitude,
    double? checkoutLongitude,
    double? checkinAccuracyM,
    double? checkoutAccuracyM,
    double? distanceM,
    String? notes,
    @Default(false) bool isSynced,
    // Relations
    Customer? customer,
    @Default([]) List<VisitPhoto> photos,
    VisitSignature? signature,
  }) = _Visit;

  factory Visit.fromJson(Map<String, dynamic> json) => _$VisitFromJson(json);
}

@freezed
class VisitPhoto with _$VisitPhoto {
  const factory VisitPhoto({
    required String id,
    required String visitId,
    required String storagePath,
    DateTime? createdAt,
  }) = _VisitPhoto;

  factory VisitPhoto.fromJson(Map<String, dynamic> json) =>
      _$VisitPhotoFromJson(json);
}

@freezed
class VisitSignature with _$VisitSignature {
  const factory VisitSignature({
    required String id,
    required String visitId,
    required String storagePath,
    String? signedBy,
    DateTime? createdAt,
  }) = _VisitSignature;

  factory VisitSignature.fromJson(Map<String, dynamic> json) =>
      _$VisitSignatureFromJson(json);
}


===== lib/data/models/geo/location_sample.dart =====
import 'package:freezed_annotation/freezed_annotation.dart';

part 'location_sample.freezed.dart';
part 'location_sample.g.dart';

@freezed
class LocationSample with _$LocationSample {
  const factory LocationSample({
    required int id,
    required String companyId,
    required String userId,
    required DateTime at,
    required double latitude,
    required double longitude,
    double? speedMs,
    double? accuracyM,
  }) = _LocationSample;

  factory LocationSample.fromJson(Map<String, dynamic> json) =>
      _$LocationSampleFromJson(json);
}

@freezed
class Geofence with _$Geofence {
  const factory Geofence({
    required String id,
    required String companyId,
    required String ownerId,
    @Default(10) int radiusM,
    required double centerLatitude,
    required double centerLongitude,
    DateTime? createdAt,
  }) = _Geofence;

  factory Geofence.fromJson(Map<String, dynamic> json) =>
      _$GeofenceFromJson(json);
}


===== lib/data/models/routes/route_plan.dart =====
import 'package:freezed_annotation/freezed_annotation.dart';
import '../customers/customer.dart';

part 'route_plan.freezed.dart';
part 'route_plan.g.dart';

@freezed
class RoutePlan with _$RoutePlan {
  const factory RoutePlan({
    required String id,
    required String companyId,
    required String name,
    required DateTime date,
    String? ownerId,
    DateTime? createdAt,
    @Default([]) List<RouteStop> stops,
  }) = _RoutePlan;

  factory RoutePlan.fromJson(Map<String, dynamic> json) =>
      _$RoutePlanFromJson(json);
}

@freezed
class RouteStop with _$RouteStop {
  const factory RouteStop({
    required String id,
    required String routeId,
    required String customerId,
    DateTime? plannedTime,
    int? sequence,
    String? notes,
    Customer? customer,
  }) = _RouteStop;

  factory RouteStop.fromJson(Map<String, dynamic> json) =>
      _$RouteStopFromJson(json);
}


===== lib/data/models/reports/kpi.dart =====
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'kpi.freezed.dart';
part 'kpi.g.dart';

@freezed
class KPI with _$KPI {
  const factory KPI({
    required String id,
    required String name,
    required String description,
    required KPIType type,
    required double value,
    required double target,
    String? unit,
    required DateTime period,
    String? userId,
    String? companyId,
    DateTime? createdAt,
    KPITrend? trend,
    double? previousValue,
    @Default([]) List<KPIDataPoint> dataPoints,
  }) = _KPI;

  factory KPI.fromJson(Map<String, dynamic> json) => _$KPIFromJson(json);
}

@freezed
class KPIDataPoint with _$KPIDataPoint {
  const factory KPIDataPoint({
    required DateTime date,
    required double value,
    String? label,
    Map<String, dynamic>? metadata,
  }) = _KPIDataPoint;

  factory KPIDataPoint.fromJson(Map<String, dynamic> json) =>
      _$KPIDataPointFromJson(json);
}

@freezed
class KPIDashboard with _$KPIDashboard {
  const factory KPIDashboard({
    required String userId,
    required DateTime period,
    required List<KPI> kpis,
    required KPISummary summary,
    @Default([]) List<KPIAlert> alerts,
    DateTime? lastUpdated,
  }) = _KPIDashboard;

  factory KPIDashboard.fromJson(Map<String, dynamic> json) =>
      _$KPIDashboardFromJson(json);
}

@freezed
class KPISummary with _$KPISummary {
  const factory KPISummary({
    required int totalKPIs,
    required int kpisOnTarget,
    required int kpisAboveTarget,
    required int kpisBelowTarget,
    required double overallPerformance,
    KPITrend? overallTrend,
  }) = _KPISummary;

  factory KPISummary.fromJson(Map<String, dynamic> json) =>
      _$KPISummaryFromJson(json);
}

@freezed
class KPIAlert with _$KPIAlert {
  const factory KPIAlert({
    required String kpiId,
    required String kpiName,
    required KPIAlertType type,
    required String message,
    required KPIAlertSeverity severity,
    DateTime? createdAt,
    bool? acknowledged,
  }) = _KPIAlert;

  factory KPIAlert.fromJson(Map<String, dynamic> json) =>
      _$KPIAlertFromJson(json);
}

enum KPIType {
  @JsonValue('VISITS_COUNT')
  visitsCount,
  @JsonValue('VISITS_COMPLETION_RATE')
  visitsCompletionRate,
  @JsonValue('AVERAGE_VISIT_DURATION')
  averageVisitDuration,
  @JsonValue('SALES_AMOUNT')
  salesAmount,
  @JsonValue('ORDERS_COUNT')
  ordersCount,
  @JsonValue('AVERAGE_ORDER_VALUE')
  averageOrderValue,
  @JsonValue('CUSTOMER_SATISFACTION')
  customerSatisfaction,
  @JsonValue('ROUTE_EFFICIENCY')
  routeEfficiency,
  @JsonValue('COLLECTION_RATE')
  collectionRate,
  @JsonValue('NEW_CUSTOMERS')
  newCustomers,
  @JsonValue('CUSTOMER_RETENTION')
  customerRetention,
  @JsonValue('DELIVERY_ON_TIME')
  deliveryOnTime,
  @JsonValue('INVENTORY_TURNOVER')
  inventoryTurnover,
  @JsonValue('PROFIT_MARGIN')
  profitMargin,
  @JsonValue('CONVERSION_RATE')
  conversionRate,
}

enum KPITrend {
  @JsonValue('UP')
  up,
  @JsonValue('DOWN')
  down,
  @JsonValue('STABLE')
  stable,
}

enum KPIAlertType {
  @JsonValue('TARGET_MISSED')
  targetMissed,
  @JsonValue('PERFORMANCE_DROP')
  performanceDrop,
  @JsonValue('UNUSUAL_ACTIVITY')
  unusualActivity,
  @JsonValue('THRESHOLD_EXCEEDED')
  thresholdExceeded,
}

enum KPIAlertSeverity {
  @JsonValue('LOW')
  low,
  @JsonValue('MEDIUM')
  medium,
  @JsonValue('HIGH')
  high,
  @JsonValue('CRITICAL')
  critical,
}

// Extensions for easier usage
extension KPIX on KPI {
  /// Calculate performance percentage against target
  double get performancePercentage {
    if (target == 0) return 0;
    return (value / target) * 100;
  }

  /// Check if KPI is on target (within 5% tolerance)
  bool get isOnTarget {
    const tolerance = 5.0; // 5% tolerance
    final performance = performancePercentage;
    return performance >= (100 - tolerance) && performance <= (100 + tolerance);
  }

  /// Check if KPI is above target
  bool get isAboveTarget => performancePercentage > 105;

  /// Check if KPI is below target
  bool get isBelowTarget => performancePercentage < 95;

  /// Get KPI status
  KPIStatus get status {
    if (isAboveTarget) return KPIStatus.aboveTarget;
    if (isBelowTarget) return KPIStatus.belowTarget;
    return KPIStatus.onTarget;
  }

  /// Calculate trend percentage
  double? get trendPercentage {
    if (previousValue == null || previousValue == 0) return null;
    return ((value - previousValue!) / previousValue!) * 100;
  }

  /// Get formatted value with unit
  String get formattedValue {
    switch (type) {
      case KPIType.salesAmount:
      case KPIType.averageOrderValue:
        return '\$${value.toStringAsFixed(2)}';
      case KPIType.visitsCompletionRate:
      case KPIType.collectionRate:
      case KPIType.customerRetention:
      case KPIType.deliveryOnTime:
      case KPIType.profitMargin:
      case KPIType.conversionRate:
        return '${value.toStringAsFixed(1)}%';
      case KPIType.averageVisitDuration:
        return '${value.toStringAsFixed(0)} min';
      default:
        return value.toStringAsFixed(0) + (unit ?? '');
    }
  }

  /// Get formatted target with unit
  String get formattedTarget {
    switch (type) {
      case KPIType.salesAmount:
      case KPIType.averageOrderValue:
        return '\$${target.toStringAsFixed(2)}';
      case KPIType.visitsCompletionRate:
      case KPIType.collectionRate:
      case KPIType.customerRetention:
      case KPIType.deliveryOnTime:
      case KPIType.profitMargin:
      case KPIType.conversionRate:
        return '${target.toStringAsFixed(1)}%';
      case KPIType.averageVisitDuration:
        return '${target.toStringAsFixed(0)} min';
      default:
        return target.toStringAsFixed(0) + (unit ?? '');
    }
  }
}

extension KPITypeX on KPIType {
  String get displayName {
    switch (this) {
      case KPIType.visitsCount:
        return 'Número de Visitas';
      case KPIType.visitsCompletionRate:
        return 'Tasa de Finalización de Visitas';
      case KPIType.averageVisitDuration:
        return 'Duración Promedio de Visita';
      case KPIType.salesAmount:
        return 'Monto de Ventas';
      case KPIType.ordersCount:
        return 'Número de Pedidos';
      case KPIType.averageOrderValue:
        return 'Valor Promedio de Pedido';
      case KPIType.customerSatisfaction:
        return 'Satisfacción del Cliente';
      case KPIType.routeEfficiency:
        return 'Eficiencia de Ruta';
      case KPIType.collectionRate:
        return 'Tasa de Cobranza';
      case KPIType.newCustomers:
        return 'Nuevos Clientes';
      case KPIType.customerRetention:
        return 'Retención de Clientes';
      case KPIType.deliveryOnTime:
        return 'Entregas a Tiempo';
      case KPIType.inventoryTurnover:
        return 'Rotación de Inventario';
      case KPIType.profitMargin:
        return 'Margen de Ganancia';
      case KPIType.conversionRate:
        return 'Tasa de Conversión';
    }
  }

  String get description {
    switch (this) {
      case KPIType.visitsCount:
        return 'Total de visitas realizadas';
      case KPIType.visitsCompletionRate:
        return 'Porcentaje de visitas completadas';
      case KPIType.averageVisitDuration:
        return 'Tiempo promedio por visita';
      case KPIType.salesAmount:
        return 'Monto total de ventas';
      case KPIType.ordersCount:
        return 'Cantidad de pedidos generados';
      case KPIType.averageOrderValue:
        return 'Valor promedio por pedido';
      case KPIType.customerSatisfaction:
        return 'Calificación promedio de satisfacción';
      case KPIType.routeEfficiency:
        return 'Eficiencia en recorrido de rutas';
      case KPIType.collectionRate:
        return 'Porcentaje de cobranza exitosa';
      case KPIType.newCustomers:
        return 'Cantidad de clientes nuevos';
      case KPIType.customerRetention:
        return 'Porcentaje de retención de clientes';
      case KPIType.deliveryOnTime:
        return 'Porcentaje de entregas puntuales';
      case KPIType.inventoryTurnover:
        return 'Rotación de inventario';
      case KPIType.profitMargin:
        return 'Margen de ganancia porcentual';
      case KPIType.conversionRate:
        return 'Tasa de conversión de visitas a ventas';
    }
  }

  IconData get icon {
    switch (this) {
      case KPIType.visitsCount:
        return Icons.location_on;
      case KPIType.visitsCompletionRate:
        return Icons.check_circle;
      case KPIType.averageVisitDuration:
        return Icons.timer;
      case KPIType.salesAmount:
        return Icons.attach_money;
      case KPIType.ordersCount:
        return Icons.shopping_cart;
      case KPIType.averageOrderValue:
        return Icons.receipt_long;
      case KPIType.customerSatisfaction:
        return Icons.sentiment_satisfied;
      case KPIType.routeEfficiency:
        return Icons.route;
      case KPIType.collectionRate:
        return Icons.payment;
      case KPIType.newCustomers:
        return Icons.person_add;
      case KPIType.customerRetention:
        return Icons.favorite;
      case KPIType.deliveryOnTime:
        return Icons.local_shipping;
      case KPIType.inventoryTurnover:
        return Icons.inventory;
      case KPIType.profitMargin:
        return Icons.trending_up;
      case KPIType.conversionRate:
        return Icons.transform;
    }
  }

  Color get color {
    switch (this) {
      case KPIType.visitsCount:
      case KPIType.visitsCompletionRate:
        return Colors.blue;
      case KPIType.salesAmount:
      case KPIType.averageOrderValue:
      case KPIType.profitMargin:
        return Colors.green;
      case KPIType.ordersCount:
      case KPIType.conversionRate:
        return Colors.orange;
      case KPIType.customerSatisfaction:
      case KPIType.customerRetention:
        return Colors.purple;
      case KPIType.deliveryOnTime:
      case KPIType.routeEfficiency:
        return Colors.teal;
      case KPIType.collectionRate:
        return Colors.indigo;
      case KPIType.newCustomers:
        return Colors.cyan;
      default:
        return Colors.grey;
    }
  }
}

extension KPITrendX on KPITrend {
  String get displayName {
    switch (this) {
      case KPITrend.up:
        return 'Al Alza';
      case KPITrend.down:
        return 'A la Baja';
      case KPITrend.stable:
        return 'Estable';
    }
  }

  IconData get icon {
    switch (this) {
      case KPITrend.up:
        return Icons.trending_up;
      case KPITrend.down:
        return Icons.trending_down;
      case KPITrend.stable:
        return Icons.trending_flat;
    }
  }

  Color get color {
    switch (this) {
      case KPITrend.up:
        return Colors.green;
      case KPITrend.down:
        return Colors.red;
      case KPITrend.stable:
        return Colors.orange;
    }
  }
}

extension KPIAlertSeverityX on KPIAlertSeverity {
  String get displayName {
    switch (this) {
      case KPIAlertSeverity.low:
        return 'Baja';
      case KPIAlertSeverity.medium:
        return 'Media';
      case KPIAlertSeverity.high:
        return 'Alta';
      case KPIAlertSeverity.critical:
        return 'Crítica';
    }
  }

  Color get color {
    switch (this) {
      case KPIAlertSeverity.low:
        return Colors.yellow;
      case KPIAlertSeverity.medium:
        return Colors.orange;
      case KPIAlertSeverity.high:
        return Colors.red;
      case KPIAlertSeverity.critical:
        return Colors.purple;
    }
  }

  IconData get icon {
    switch (this) {
      case KPIAlertSeverity.low:
        return Icons.info;
      case KPIAlertSeverity.medium:
        return Icons.warning;
      case KPIAlertSeverity.high:
        return Icons.error;
      case KPIAlertSeverity.critical:
        return Icons.crisis_alert;
    }
  }
}

enum KPIStatus { onTarget, aboveTarget, belowTarget }

extension KPIStatusX on KPIStatus {
  String get displayName {
    switch (this) {
      case KPIStatus.onTarget:
        return 'En Meta';
      case KPIStatus.aboveTarget:
        return 'Sobre Meta';
      case KPIStatus.belowTarget:
        return 'Bajo Meta';
    }
  }

  Color get color {
    switch (this) {
      case KPIStatus.onTarget:
        return Colors.green;
      case KPIStatus.aboveTarget:
        return Colors.blue;
      case KPIStatus.belowTarget:
        return Colors.red;
    }
  }

  IconData get icon {
    switch (this) {
      case KPIStatus.onTarget:
        return Icons.check_circle;
      case KPIStatus.aboveTarget:
        return Icons.trending_up;
      case KPIStatus.belowTarget:
        return Icons.trending_down;
    }
  }
}

// KPI Calculator utilities
class KPICalculator {
  /// Calculate visits completion rate
  static double calculateVisitsCompletionRate({
    required int completedVisits,
    required int totalVisits,
  }) {
    if (totalVisits == 0) return 0;
    return (completedVisits / totalVisits) * 100;
  }

  /// Calculate average order value
  static double calculateAverageOrderValue({
    required double totalSales,
    required int totalOrders,
  }) {
    if (totalOrders == 0) return 0;
    return totalSales / totalOrders;
  }

  /// Calculate conversion rate
  static double calculateConversionRate({
    required int orders,
    required int visits,
  }) {
    if (visits == 0) return 0;
    return (orders / visits) * 100;
  }

  /// Calculate route efficiency
  static double calculateRouteEfficiency({
    required double plannedDistance,
    required double actualDistance,
    required double plannedTime,
    required double actualTime,
  }) {
    if (actualDistance == 0 || actualTime == 0) return 0;

    final distanceEfficiency = plannedDistance / actualDistance;
    final timeEfficiency = plannedTime / actualTime;

    return ((distanceEfficiency + timeEfficiency) / 2) * 100;
  }

  /// Calculate collection rate
  static double calculateCollectionRate({
    required double collectedAmount,
    required double totalDue,
  }) {
    if (totalDue == 0) return 0;
    return (collectedAmount / totalDue) * 100;
  }

  /// Calculate customer retention rate
  static double calculateCustomerRetentionRate({
    required int customersAtStart,
    required int customersAtEnd,
    required int newCustomers,
  }) {
    if (customersAtStart == 0) return 0;
    final retainedCustomers = customersAtEnd - newCustomers;
    return (retainedCustomers / customersAtStart) * 100;
  }

  /// Calculate trend based on current and previous values
  static KPITrend calculateTrend({
    required double currentValue,
    required double previousValue,
    double threshold = 5.0, // 5% threshold for trend detection
  }) {
    if (previousValue == 0) return KPITrend.stable;

    final changePercentage =
        ((currentValue - previousValue) / previousValue) * 100;

    if (changePercentage > threshold) {
      return KPITrend.up;
    } else if (changePercentage < -threshold) {
      return KPITrend.down;
    } else {
      return KPITrend.stable;
    }
  }
}


===== lib/data/local/preferences.dart =====
import 'package:shared_preferences/shared_preferences.dart';

class AppPreferences {
  static const String _keyIsFirstRun = 'is_first_run';
  static const String _keyUserId = 'user_id';
  static const String _keyUserRole = 'user_role';
  static const String _keyLocationEnabled = 'location_enabled';
  static const String _keyBackgroundLocationEnabled =
      'background_location_enabled';
  static const String _keyLastSyncAt = 'last_sync_at';

  static SharedPreferences? _prefs;

  static Future<void> init() async {
    _prefs ??= await SharedPreferences.getInstance();
  }

  static SharedPreferences get prefs {
    if (_prefs == null) {
      throw Exception(
          'Preferences not initialized. Call AppPreferences.init() first.');
    }
    return _prefs!;
  }

  // Getters
  static bool get isFirstRun => prefs.getBool(_keyIsFirstRun) ?? true;
  static String? get userId => prefs.getString(_keyUserId);
  static String? get userRole => prefs.getString(_keyUserRole);
  static bool get isLocationEnabled =>
      prefs.getBool(_keyLocationEnabled) ?? false;
  static bool get isBackgroundLocationEnabled =>
      prefs.getBool(_keyBackgroundLocationEnabled) ?? false;
  static DateTime? get lastSyncAt {
    final timestamp = prefs.getInt(_keyLastSyncAt);
    return timestamp != null
        ? DateTime.fromMillisecondsSinceEpoch(timestamp)
        : null;
  }

  // Setters
  static Future<void> setIsFirstRun(bool value) =>
      prefs.setBool(_keyIsFirstRun, value);
  static Future<void> setUserId(String? value) => value != null
      ? prefs.setString(_keyUserId, value)
      : prefs.remove(_keyUserId);
  static Future<void> setUserRole(String? value) => value != null
      ? prefs.setString(_keyUserRole, value)
      : prefs.remove(_keyUserRole);
  static Future<void> setLocationEnabled(bool value) =>
      prefs.setBool(_keyLocationEnabled, value);
  static Future<void> setBackgroundLocationEnabled(bool value) =>
      prefs.setBool(_keyBackgroundLocationEnabled, value);
  static Future<void> setLastSyncAt(DateTime? value) => value != null
      ? prefs.setInt(_keyLastSyncAt, value.millisecondsSinceEpoch)
      : prefs.remove(_keyLastSyncAt);

  static Future<void> clear() => prefs.clear();
}


===== lib/data/local/drift/tables.dart =====
import 'package:drift/drift.dart';

@DataClassName('CustomerEntity')
class Customers extends Table {
  TextColumn get id => text()();
  TextColumn get companyId => text()();
  TextColumn get code => text().nullable()();
  TextColumn get name => text()();
  TextColumn get email => text().nullable()();
  TextColumn get phone => text().nullable()();
  TextColumn get address => text().nullable()();
  RealColumn get latitude => real().nullable()();
  RealColumn get longitude => real().nullable()();
  RealColumn get geoAccuracyM => real().nullable()();
  TextColumn get createdBy => text().nullable()();
  DateTimeColumn get createdAt => dateTime().nullable()();
  DateTimeColumn get updatedAt => dateTime().nullable()();
  BoolColumn get needsSync => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

@DataClassName('VisitEntity')
class Visits extends Table {
  TextColumn get id => text()();
  TextColumn get companyId => text()();
  TextColumn get customerId => text()();
  TextColumn get userId => text().nullable()();
  TextColumn get purpose => text()();
  DateTimeColumn get startedAt => dateTime().nullable()();
  DateTimeColumn get finishedAt => dateTime().nullable()();
  RealColumn get checkinLatitude => real().nullable()();
  RealColumn get checkinLongitude => real().nullable()();
  RealColumn get checkoutLatitude => real().nullable()();
  RealColumn get checkoutLongitude => real().nullable()();
  RealColumn get checkinAccuracyM => real().nullable()();
  RealColumn get checkoutAccuracyM => real().nullable()();
  RealColumn get distanceM => real().nullable()();
  TextColumn get notes => text().nullable()();
  BoolColumn get isSynced => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

@DataClassName('ProductEntity')
class Products extends Table {
  TextColumn get id => text()();
  TextColumn get companyId => text()();
  TextColumn get sku => text().nullable()();
  TextColumn get name => text()();
  TextColumn get unit => text().nullable()();
  RealColumn get tax => real().withDefault(const Constant(0.0))();
  BoolColumn get active => boolean().withDefault(const Constant(true))();
  DateTimeColumn get createdAt => dateTime().nullable()();

  @override
  Set<Column> get primaryKey => {id};
}

@DataClassName('OrderEntity')
class Orders extends Table {
  TextColumn get id => text()();
  TextColumn get companyId => text()();
  TextColumn get customerId => text().nullable()();
  TextColumn get userId => text().nullable()();
  TextColumn get priceListId => text().nullable()();
  TextColumn get status => text()();
  RealColumn get subtotal => real().withDefault(const Constant(0.0))();
  RealColumn get taxTotal => real().withDefault(const Constant(0.0))();
  RealColumn get discountTotal => real().withDefault(const Constant(0.0))();
  RealColumn get grandTotal => real().withDefault(const Constant(0.0))();
  DateTimeColumn get createdAt => dateTime().nullable()();
  BoolColumn get needsSync => boolean().withDefault(const Constant(false))();

  @override
  Set<Column> get primaryKey => {id};
}

@DataClassName('OrderItemEntity')
class OrderItems extends Table {
  TextColumn get id => text()();
  TextColumn get orderId => text()();
  TextColumn get productId => text()();
  RealColumn get qty => real()();
  RealColumn get price => real()();
  RealColumn get discount => real().withDefault(const Constant(0.0))();
  RealColumn get total => real()();

  @override
  Set<Column> get primaryKey => {id};
}

@DataClassName('TrackingEntity')
class TrackingLocations extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get companyId => text()();
  TextColumn get userId => text()();
  DateTimeColumn get at => dateTime()();
  RealColumn get latitude => real()();
  RealColumn get longitude => real()();
  RealColumn get speedMs => real().nullable()();
  RealColumn get accuracyM => real().nullable()();
  BoolColumn get needsSync => boolean().withDefault(const Constant(false))();
}


===== lib/data/local/drift/db.dart =====
import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:sqlite3/sqlite3.dart';
import 'package:sqlite3_flutter_libs/sqlite3_flutter_libs.dart';

import 'tables.dart';

part 'db.g.dart';

@DriftDatabase(tables: [
  Customers,
  Visits,
  Products,
  Orders,
  OrderItems,
  TrackingLocations,
])
class DatabaseHelper extends _$DatabaseHelper {
  DatabaseHelper._internal() : super(_openConnection());

  static final DatabaseHelper _instance = DatabaseHelper._internal();
  static DatabaseHelper get instance => _instance;

  @override
  int get schemaVersion => 1;

  @override
  MigrationStrategy get migration => MigrationStrategy(
        onCreate: (Migrator m) async {
          await m.createAll();

          // Create indexes
          await customStatement('''
        CREATE INDEX IF NOT EXISTS customers_company_idx 
        ON customers(company_id);
      ''');

          await customStatement('''
        CREATE INDEX IF NOT EXISTS visits_customer_idx 
        ON visits(customer_id, started_at DESC);
      ''');

          await customStatement('''
        CREATE INDEX IF NOT EXISTS tracking_user_time_idx 
        ON tracking_locations(user_id, at DESC);
      ''');
        },
        beforeOpen: (details) async {
          if (Platform.isAndroid) {
            await applyWorkaroundToOpenSqlite3OnOldAndroidVersions();
          }

          // Enable foreign keys
          await customStatement('PRAGMA foreign_keys = ON');
        },
      );

  // Customers
  Future<List<CustomerEntity>> getAllCustomers() => select(customers).get();

  Future<CustomerEntity?> getCustomerById(String id) =>
      (select(customers)..where((c) => c.id.equals(id))).getSingleOrNull();

  Future<void> insertCustomer(CustomerEntity customer) =>
      into(customers).insertOnConflictUpdate(customer);

  Future<void> insertCustomers(List<CustomerEntity> customerList) =>
      batch((batch) {
        batch.insertAllOnConflictUpdate(customers, customerList);
      });

  // Visits
  Future<List<VisitEntity>> getVisitsByCustomer(String customerId) =>
      (select(visits)..where((v) => v.customerId.equals(customerId))).get();

  Future<List<VisitEntity>> getPendingSyncVisits() =>
      (select(visits)..where((v) => v.isSynced.equals(false))).get();

  Future<void> insertVisit(VisitEntity visit) =>
      into(visits).insertOnConflictUpdate(visit);

  Future<void> markVisitSynced(String visitId) =>
      (update(visits)..where((v) => v.id.equals(visitId)))
          .write(const VisitsCompanion(isSynced: Value(true)));

  // Products
  Future<List<ProductEntity>> getAllProducts() => select(products).get();

  Future<void> insertProducts(List<ProductEntity> productList) =>
      batch((batch) {
        batch.insertAllOnConflictUpdate(products, productList);
      });

  // Orders
  Future<List<OrderEntity>> getPendingSyncOrders() =>
      (select(orders)..where((o) => o.needsSync.equals(true))).get();

  Future<void> insertOrder(OrderEntity order) =>
      into(orders).insertOnConflictUpdate(order);

  Future<void> insertOrderItems(List<OrderItemEntity> items) => batch((batch) {
        batch.insertAllOnConflictUpdate(orderItems, items);
      });

  // Tracking
  Future<void> insertTrackingLocation(TrackingEntity location) =>
      into(trackingLocations).insert(location);

  Future<List<TrackingEntity>> getPendingSyncTracking() =>
      (select(trackingLocations)..where((t) => t.needsSync.equals(true))).get();

  Future<void> markTrackingSynced(List<int> ids) =>
      (update(trackingLocations)..where((t) => t.id.isIn(ids)))
          .write(const TrackingLocationsCompanion(needsSync: Value(false)));

  // Cleanup old data
  Future<void> cleanupOldTracking() async {
    final cutoff = DateTime.now().subtract(const Duration(days: 7));
    await (delete(trackingLocations)
          ..where((t) => t.at.isSmallerThanValue(cutoff)))
        .go();
  }
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'arsenal_sell.db'));

    if (Platform.isAndroid) {
      await applyWorkaroundToOpenSqlite3OnOldAndroidVersions();
    }

    final cachebase = (await getTemporaryDirectory()).path;
    sqlite3.tempDirectory = cachebase;

    return NativeDatabase.createInBackground(file);
  });
}


===== lib/data/local/hive/boxes.dart =====
import 'package:hive_flutter/hive_flutter.dart';

class HiveBoxes {
  static const String settings = 'settings';
  static const String syncQueue = 'sync_queue';
  static const String cache = 'cache';

  static late Box<dynamic> settingsBox;
  static late Box<Map<dynamic, dynamic>> syncQueueBox;
  static late Box<dynamic> cacheBox;

  static Future<void> init() async {
    settingsBox = await Hive.openBox(settings);
    syncQueueBox = await Hive.openBox<Map<dynamic, dynamic>>(syncQueue);
    cacheBox = await Hive.openBox(cache);
  }

  static Future<void> close() async {
    await settingsBox.close();
    await syncQueueBox.close();
    await cacheBox.close();
  }
}


===== lib/data/remote/edge_functions.dart =====
import 'package:supabase_flutter/supabase_flutter.dart';
import '../../config/logger.dart';
import '../models/visits/visit.dart';
import '../models/customers/customer.dart';

class EdgeFunctionsService {
  final SupabaseClient _client = Supabase.instance.client;

  /// Send visit summary email
  Future<bool> sendVisitEmail({
    required String visitId,
    required String customerEmail,
    required String customerName,
    required String userFullName,
    required DateTime visitDate,
    String? notes,
    List<String>? photoUrls,
    String? signatureUrl,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'send-email',
        body: {
          'type': 'visit_summary',
          'data': {
            'visitId': visitId,
            'customerEmail': customerEmail,
            'customerName': customerName,
            'userFullName': userFullName,
            'visitDate': visitDate.toIso8601String(),
            'notes': notes,
            'photoUrls': photoUrls,
            'signatureUrl': signatureUrl,
          }
        },
      );

      return response.status == 200;
    } catch (e) {
      logger.e('Send visit email error: $e');
      return false;
    }
  }

  /// Send order confirmation email
  Future<bool> sendOrderConfirmationEmail({
    required String orderId,
    required String customerEmail,
    required String customerName,
    required double total,
    required List<Map<String, dynamic>> items,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'send-email',
        body: {
          'type': 'order_confirmation',
          'data': {
            'orderId': orderId,
            'customerEmail': customerEmail,
            'customerName': customerName,
            'total': total,
            'items': items,
          }
        },
      );

      return response.status == 200;
    } catch (e) {
      logger.e('Send order confirmation email error: $e');
      return false;
    }
  }

  /// Send payment receipt email
  Future<bool> sendPaymentReceiptEmail({
    required String paymentId,
    required String customerEmail,
    required String customerName,
    required double amount,
    required String method,
    required DateTime paidAt,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'send-email',
        body: {
          'type': 'payment_receipt',
          'data': {
            'paymentId': paymentId,
            'customerEmail': customerEmail,
            'customerName': customerName,
            'amount': amount,
            'method': method,
            'paidAt': paidAt.toIso8601String(),
          }
        },
      );

      return response.status == 200;
    } catch (e) {
      logger.e('Send payment receipt email error: $e');
      return false;
    }
  }

  /// Generate daily activity report
  Future<Map<String, dynamic>?> generateDailyReport({
    required String userId,
    required DateTime date,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'generate-report',
        body: {
          'type': 'daily_activity',
          'userId': userId,
          'date': date.toIso8601String(),
        },
      );

      if (response.status == 200) {
        return response.data as Map<String, dynamic>;
      }
      return null;
    } catch (e) {
      logger.e('Generate daily report error: $e');
      return null;
    }
  }

  /// Generate weekly report
  Future<Map<String, dynamic>?> generateWeeklyReport({
    required String userId,
    required DateTime weekStart,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'generate-report',
        body: {
          'type': 'weekly_activity',
          'userId': userId,
          'weekStart': weekStart.toIso8601String(),
        },
      );

      if (response.status == 200) {
        return response.data as Map<String, dynamic>;
      }
      return null;
    } catch (e) {
      logger.e('Generate weekly report error: $e');
      return null;
    }
  }

  /// Generate team performance report
  Future<Map<String, dynamic>?> generateTeamReport({
    required String companyId,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'generate-report',
        body: {
          'type': 'team_performance',
          'companyId': companyId,
          'startDate': startDate.toIso8601String(),
          'endDate': endDate.toIso8601String(),
        },
      );

      if (response.status == 200) {
        return response.data as Map<String, dynamic>;
      }
      return null;
    } catch (e) {
      logger.e('Generate team report error: $e');
      return null;
    }
  }

  /// Validate geofence
  Future<bool> validateGeofence({
    required double currentLat,
    required double currentLng,
    required double targetLat,
    required double targetLng,
    required double radiusM,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'validate-geofence',
        body: {
          'currentLat': currentLat,
          'currentLng': currentLng,
          'targetLat': targetLat,
          'targetLng': targetLng,
          'radiusM': radiusM,
        },
      );

      if (response.status == 200) {
        return response.data['isWithinGeofence'] ?? false;
      }
      return false;
    } catch (e) {
      logger.e('Validate geofence error: $e');
      return false;
    }
  }

  /// Calculate route distance and time
  Future<Map<String, dynamic>?> calculateRouteDistance({
    required List<Map<String, double>> waypoints,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'calculate-distance',
        body: {
          'waypoints': waypoints,
        },
      );

      if (response.status == 200) {
        return response.data as Map<String, dynamic>;
      }
      return null;
    } catch (e) {
      logger.e('Calculate route distance error: $e');
      return null;
    }
  }

  /// Sync offline data
  Future<bool> syncOfflineData({
    required Map<String, dynamic> data,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'sync-data',
        body: data,
      );

      return response.status == 200;
    } catch (e) {
      logger.e('Sync offline data error: $e');
      return false;
    }
  }

  /// Apply promotions to order
  Future<Map<String, dynamic>?> applyPromotions({
    required String orderId,
    required List<Map<String, dynamic>> items,
    String? customerCode,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'apply-promotions',
        body: {
          'orderId': orderId,
          'items': items,
          'customerCode': customerCode,
        },
      );

      if (response.status == 200) {
        return response.data as Map<String, dynamic>;
      }
      return null;
    } catch (e) {
      logger.e('Apply promotions error: $e');
      return null;
    }
  }

  /// Validate customer credit
  Future<Map<String, dynamic>?> validateCustomerCredit({
    required String customerId,
    required double orderAmount,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'validate-credit',
        body: {
          'customerId': customerId,
          'orderAmount': orderAmount,
        },
      );

      if (response.status == 200) {
        return response.data as Map<String, dynamic>;
      }
      return null;
    } catch (e) {
      logger.e('Validate customer credit error: $e');
      return null;
    }
  }

  /// Send notification to team
  Future<bool> sendTeamNotification({
    required String companyId,
    required String title,
    required String message,
    String? targetRole,
    List<String>? targetUserIds,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'send-notification',
        body: {
          'companyId': companyId,
          'title': title,
          'message': message,
          'targetRole': targetRole,
          'targetUserIds': targetUserIds,
        },
      );

      return response.status == 200;
    } catch (e) {
      logger.e('Send team notification error: $e');
      return false;
    }
  }

  /// Generate invoice PDF
  Future<String?> generateInvoicePdf({
    required String orderId,
    required Map<String, dynamic> orderData,
    required Map<String, dynamic> customerData,
    required Map<String, dynamic> companyData,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'generate-invoice',
        body: {
          'orderId': orderId,
          'orderData': orderData,
          'customerData': customerData,
          'companyData': companyData,
        },
      );

      if (response.status == 200) {
        return response.data['pdfUrl'] as String?;
      }
      return null;
    } catch (e) {
      logger.e('Generate invoice PDF error: $e');
      return null;
    }
  }

  /// Process bulk data import
  Future<Map<String, dynamic>?> importBulkData({
    required String dataType,
    required List<Map<String, dynamic>> data,
    required String companyId,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'import-data',
        body: {
          'dataType': dataType,
          'data': data,
          'companyId': companyId,
        },
      );

      if (response.status == 200) {
        return response.data as Map<String, dynamic>;
      }
      return null;
    } catch (e) {
      logger.e('Import bulk data error: $e');
      return null;
    }
  }

  /// Backup user data
  Future<bool> backupUserData({
    required String userId,
    required String companyId,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'backup-data',
        body: {
          'userId': userId,
          'companyId': companyId,
        },
      );

      return response.status == 200;
    } catch (e) {
      logger.e('Backup user data error: $e');
      return false;
    }
  }

  /// Clean up old data
  Future<bool> cleanupOldData({
    required String companyId,
    int retentionDays = 90,
  }) async {
    try {
      final response = await _client.functions.invoke(
        'cleanup-data',
        body: {
          'companyId': companyId,
          'retentionDays': retentionDays,
        },
      );

      return response.status == 200;
    } catch (e) {
      logger.e('Cleanup old data error: $e');
      return false;
    }
  }
}


===== lib/data/remote/upload_service.dart =====
import 'dart:io';
import 'dart:typed_data';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:path/path.dart' as path;
import 'package:crypto/crypto.dart';
import 'dart:convert';
import '../../config/logger.dart';
import '../../config/app_constants.dart';
import '../models/auth/user_profile.dart';

enum UploadBucket {
  evidencePhotos('evidence-photos'),
  signatures('signatures'),
  documents('documents');

  const UploadBucket(this.name);
  final String name;
}

class UploadResult {
  final String path;
  final String publicUrl;
  final int size;
  final String mimeType;

  UploadResult({
    required this.path,
    required this.publicUrl,
    required this.size,
    required this.mimeType,
  });
}

class UploadService {
  final SupabaseClient _client = Supabase.instance.client;

  /// Upload a photo file
  Future<UploadResult> uploadPhoto({
    required File file,
    required String companyId,
    required String userId,
    String? visitId,
    String? customerId,
  }) async {
    try {
      // Validate file
      _validateImageFile(file);

      final fileName = _generateFileName(
        userId: userId,
        visitId: visitId,
        customerId: customerId,
        extension: path.extension(file.path),
      );

      final filePath = '$companyId/$userId/$fileName';

      final response = await _client.storage
          .from(UploadBucket.evidencePhotos.name)
          .upload(filePath, file);

      final publicUrl = _client.storage
          .from(UploadBucket.evidencePhotos.name)
          .getPublicUrl(filePath);

      final fileSize = await file.length();

      return UploadResult(
        path: filePath,
        publicUrl: publicUrl,
        size: fileSize,
        mimeType: _getMimeType(file.path),
      );
    } catch (e) {
      logger.e('Upload photo error: $e');
      rethrow;
    }
  }

  /// Upload signature data
  Future<UploadResult> uploadSignature({
    required Uint8List signatureData,
    required String companyId,
    required String userId,
    required String visitId,
    String? signedBy,
  }) async {
    try {
      // Validate signature data
      if (signatureData.isEmpty) {
        throw Exception('Signature data is empty');
      }

      if (signatureData.length > AppConstants.maxPhotoSize) {
        throw Exception('Signature file too large');
      }

      final fileName = _generateSignatureFileName(
        userId: userId,
        visitId: visitId,
        signedBy: signedBy,
      );

      final filePath = '$companyId/$userId/signatures/$fileName';

      final response = await _client.storage
          .from(UploadBucket.signatures.name)
          .uploadBinary(filePath, signatureData);

      final publicUrl = _client.storage
          .from(UploadBucket.signatures.name)
          .getPublicUrl(filePath);

      return UploadResult(
        path: filePath,
        publicUrl: publicUrl,
        size: signatureData.length,
        mimeType: 'image/png',
      );
    } catch (e) {
      logger.e('Upload signature error: $e');
      rethrow;
    }
  }

  /// Upload document file
  Future<UploadResult> uploadDocument({
    required File file,
    required String companyId,
    required String userId,
    String? category,
  }) async {
    try {
      // Validate file
      _validateDocumentFile(file);

      final fileName = _generateDocumentFileName(
        userId: userId,
        originalName: path.basename(file.path),
        category: category,
      );

      final filePath = '$companyId/$userId/documents/$fileName';

      final response = await _client.storage
          .from(UploadBucket.documents.name)
          .upload(filePath, file);

      final publicUrl = _client.storage
          .from(UploadBucket.documents.name)
          .getPublicUrl(filePath);

      final fileSize = await file.length();

      return UploadResult(
        path: filePath,
        publicUrl: publicUrl,
        size: fileSize,
        mimeType: _getMimeType(file.path),
      );
    } catch (e) {
      logger.e('Upload document error: $e');
      rethrow;
    }
  }

  /// Upload multiple photos
  Future<List<UploadResult>> uploadMultiplePhotos({
    required List<File> files,
    required String companyId,
    required String userId,
    String? visitId,
    String? customerId,
  }) async {
    final results = <UploadResult>[];

    for (final file in files) {
      try {
        final result = await uploadPhoto(
          file: file,
          companyId: companyId,
          userId: userId,
          visitId: visitId,
          customerId: customerId,
        );
        results.add(result);
      } catch (e) {
        logger.e('Failed to upload photo ${file.path}: $e');
        // Continue with other files
      }
    }

    return results;
  }

  /// Delete file from storage
  Future<void> deleteFile(UploadBucket bucket, String filePath) async {
    try {
      await _client.storage.from(bucket.name).remove([filePath]);
    } catch (e) {
      logger.e('Delete file error: $e');
      rethrow;
    }
  }

  /// Get file download URL
  Future<String> getDownloadUrl(UploadBucket bucket, String filePath) async {
    try {
      return _client.storage.from(bucket.name).getPublicUrl(filePath);
    } catch (e) {
      logger.e('Get download URL error: $e');
      rethrow;
    }
  }

  /// Create signed URL for temporary access
  Future<String> createSignedUrl({
    required UploadBucket bucket,
    required String filePath,
    int expiresInMinutes = 60,
  }) async {
    try {
      return await _client.storage
          .from(bucket.name)
          .createSignedUrl(filePath, expiresInMinutes * 60);
    } catch (e) {
      logger.e('Create signed URL error: $e');
      rethrow;
    }
  }

  /// List files in a directory
  Future<List<FileObject>> listFiles({
    required UploadBucket bucket,
    required String directory,
    int limit = 100,
  }) async {
    try {
      return await _client.storage
          .from(bucket.name)
          .list(path: directory, limit: limit);
    } catch (e) {
      logger.e('List files error: $e');
      rethrow;
    }
  }

  /// Get file metadata
  Future<FileObject?> getFileMetadata(
      UploadBucket bucket, String filePath) async {
    try {
      final files = await _client.storage
          .from(bucket.name)
          .list(path: path.dirname(filePath));

      final fileName = path.basename(filePath);
      return files.firstWhere(
        (file) => file.name == fileName,
        orElse: () => throw Exception('File not found'),
      );
    } catch (e) {
      logger.e('Get file metadata error: $e');
      return null;
    }
  }

  // Private helper methods
  String _generateFileName({
    required String userId,
    String? visitId,
    String? customerId,
    required String extension,
  }) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final hash = _generateHash('$userId$visitId$customerId$timestamp');

    String prefix = 'photo';
    if (visitId != null) prefix = 'visit_$visitId';
    if (customerId != null) prefix += '_customer_$customerId';

    return '${prefix}_${timestamp}_$hash$extension';
  }

  String _generateSignatureFileName({
    required String userId,
    required String visitId,
    String? signedBy,
  }) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final hash = _generateHash('$userId$visitId$signedBy$timestamp');

    return 'signature_visit_${visitId}_${timestamp}_$hash.png';
  }

  String _generateDocumentFileName({
    required String userId,
    required String originalName,
    String? category,
  }) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final extension = path.extension(originalName);
    final nameWithoutExt = path.basenameWithoutExtension(originalName);
    final sanitizedName = _sanitizeFileName(nameWithoutExt);

    String prefix = category ?? 'document';
    return '${prefix}_${timestamp}_$sanitizedName$extension';
  }

  String _generateHash(String input) {
    final bytes = utf8.encode(input);
    final digest = md5.convert(bytes);
    return digest.toString().substring(0, 8);
  }

  String _sanitizeFileName(String fileName) {
    return fileName
        .replaceAll(RegExp(r'[^\w\-_.]'), '_')
        .replaceAll(RegExp(r'_+'), '_')
        .toLowerCase();
  }

  void _validateImageFile(File file) {
    final extension = path.extension(file.path).toLowerCase();
    if (!AppConstants.allowedImageTypes.contains(extension.substring(1))) {
      throw Exception(
          'Invalid image file type. Allowed: ${AppConstants.allowedImageTypes.join(', ')}');
    }
  }

  void _validateDocumentFile(File file) {
    final fileSize = file.lengthSync();
    if (fileSize > AppConstants.maxPhotoSize * 2) {
      // Documents can be larger
      throw Exception(
          'Document file too large. Max size: ${(AppConstants.maxPhotoSize * 2) / (1024 * 1024)}MB');
    }
  }

  String _getMimeType(String filePath) {
    final extension = path.extension(filePath).toLowerCase();
    switch (extension) {
      case '.jpg':
      case '.jpeg':
        return 'image/jpeg';
      case '.png':
        return 'image/png';
      case '.gif':
        return 'image/gif';
      case '.webp':
        return 'image/webp';
      case '.pdf':
        return 'application/pdf';
      case '.doc':
        return 'application/msword';
      case '.docx':
        return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
      case '.txt':
        return 'text/plain';
      default:
        return 'application/octet-stream';
    }
  }

  /// Compress image before upload (optional)
  Future<File> compressImage(File file, {int quality = 80}) async {
    // This would require image compression library
    // For now, return the original file
    return file;
  }

  /// Generate thumbnail (optional)
  Future<Uint8List?> generateThumbnail(File imageFile, {int size = 200}) async {
    // This would require image processing library
    // For now, return null
    return null;
  }

  /// Batch upload with progress tracking
  Future<List<UploadResult>> batchUpload({
    required List<File> files,
    required String companyId,
    required String userId,
    Function(int uploaded, int total)? onProgress,
  }) async {
    final results = <UploadResult>[];

    for (int i = 0; i < files.length; i++) {
      try {
        final result = await uploadPhoto(
          file: files[i],
          companyId: companyId,
          userId: userId,
        );
        results.add(result);
        onProgress?.call(i + 1, files.length);
      } catch (e) {
        logger.e('Batch upload failed for file ${files[i].path}: $e');
      }
    }

    return results;
  }
}


===== lib/data/remote/supabase_client.dart =====
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/customers/customer.dart';
import '../models/visits/visit.dart';
import '../models/sales/order.dart';
import '../models/geo/location_sample.dart';
import '../../config/logger.dart';

class SupabaseService {
  final SupabaseClient _client = Supabase.instance.client;

  // Customers
  Future<List<Customer>> getCustomers() async {
    try {
      final response = await _client.from('customers').select();
      return (response as List).map((e) => Customer.fromJson(e)).toList();
    } catch (e) {
      logger.e('Get customers error: $e');
      rethrow;
    }
  }

  Future<Customer> createCustomer(Customer customer) async {
    try {
      final response = await _client
          .from('customers')
          .insert(customer.toJson())
          .select()
          .single();
      return Customer.fromJson(response);
    } catch (e) {
      logger.e('Create customer error: $e');
      rethrow;
    }
  }

  // Visits
  Future<Visit> createVisit(Visit visit) async {
    try {
      final response =
          await _client.from('visits').insert(visit.toJson()).select().single();
      return Visit.fromJson(response);
    } catch (e) {
      logger.e('Create visit error: $e');
      rethrow;
    }
  }

  Future<void> updateVisit(Visit visit) async {
    try {
      await _client.from('visits').update(visit.toJson()).eq('id', visit.id);
    } catch (e) {
      logger.e('Update visit error: $e');
      rethrow;
    }
  }

  // Orders
  Future<Order> createOrder(Order order) async {
    try {
      final response =
          await _client.from('orders').insert(order.toJson()).select().single();
      return Order.fromJson(response);
    } catch (e) {
      logger.e('Create order error: $e');
      rethrow;
    }
  }

  // Tracking
  Future<void> uploadTrackingLocations(List<LocationSample> locations) async {
    try {
      final data = locations.map((l) => l.toJson()).toList();
      await _client.from('tracking_locations').insert(data);
    } catch (e) {
      logger.e('Upload tracking locations error: $e');
      rethrow;
    }
  }

  Future<List<LocationSample>> getRealtimeLocations() async {
    try {
      final response = await _client
          .from('tracking_locations')
          .select()
          .gte(
              'at',
              DateTime.now()
                  .subtract(const Duration(minutes: 30))
                  .toIso8601String())
          .order('at', ascending: false);

      return (response as List).map((e) => LocationSample.fromJson(e)).toList();
    } catch (e) {
      logger.e('Get realtime locations error: $e');
      return [];
    }
  }

  // File Upload
  Future<String> uploadPhoto(
      String path, String bucketName, String fileName) async {
    try {
      final response =
          await _client.storage.from(bucketName).upload(fileName, File(path));
      return response;
    } catch (e) {
      logger.e('Upload photo error: $e');
      rethrow;
    }
  }

  Future<String> uploadSignature(
      Uint8List signatureData, String bucketName, String fileName) async {
    try {
      final response = await _client.storage
          .from(bucketName)
          .uploadBinary(fileName, signatureData);
      return response;
    } catch (e) {
      logger.e('Upload signature error: $e');
      rethrow;
    }
  }
}


===== lib/data/remote/api_routes.dart =====
class ApiRoutes {
  // Base endpoints
  static const String auth = '/auth/v1';
  static const String rest = '/rest/v1';
  static const String storage = '/storage/v1';
  static const String functions = '/functions/v1';

  // Auth endpoints
  static const String signIn = '$auth/token?grant_type=password';
  static const String signUp = '$auth/signup';
  static const String signOut = '$auth/logout';
  static const String refreshToken = '$auth/token?grant_type=refresh_token';
  static const String resetPassword = '$auth/recover';

  // User profile
  static const String profiles = '$rest/profiles';
  static String profile(String userId) => '$profiles?id=eq.$userId';

  // Companies and warehouses
  static const String companies = '$rest/companies';
  static const String warehouses = '$rest/warehouses';
  static String companyWarehouses(String companyId) =>
      '$warehouses?company_id=eq.$companyId';

  // Customers
  static const String customers = '$rest/customers';
  static String customerById(String id) => '$customers?id=eq.$id';
  static String customersByCompany(String companyId) =>
      '$customers?company_id=eq.$companyId';
  static String customersNearby(double lat, double lng, double radiusKm) =>
      '$customers?location=ov.CIRCLE(POINT($lng $lat),$radiusKm)';

  // Visits
  static const String visits = '$rest/visits';
  static String visitById(String id) => '$visits?id=eq.$id';
  static String visitsByCustomer(String customerId) =>
      '$visits?customer_id=eq.$customerId&order=started_at.desc';
  static String visitsByUser(String userId) =>
      '$visits?user_id=eq.$userId&order=started_at.desc';
  static String pendingVisits() => '$visits?finished_at=is.null';
  static String visitsByDateRange(String startDate, String endDate) =>
      '$visits?started_at=gte.$startDate&started_at=lte.$endDate';

  // Visit photos and signatures
  static const String visitPhotos = '$rest/visit_photos';
  static const String visitSignatures = '$rest/visit_signatures';
  static String visitPhotosByVisit(String visitId) =>
      '$visitPhotos?visit_id=eq.$visitId';
  static String visitSignatureByVisit(String visitId) =>
      '$visitSignatures?visit_id=eq.$visitId';

  // Products and pricing
  static const String products = '$rest/products';
  static const String priceLists = '$rest/price_lists';
  static const String prices = '$rest/prices';
  static String productsByCompany(String companyId) =>
      '$products?company_id=eq.$companyId&active=eq.true';
  static String pricesByList(String priceListId) =>
      '$prices?price_list_id=eq.$priceListId&select=*,product:products(*)';

  // Orders
  static const String orders = '$rest/orders';
  static const String orderItems = '$rest/order_items';
  static String orderById(String id) =>
      '$orders?id=eq.$id&select=*,customer:customers(*),items:order_items(*,product:products(*))';
  static String ordersByCustomer(String customerId) =>
      '$orders?customer_id=eq.$customerId&order=created_at.desc';
  static String ordersByUser(String userId) =>
      '$orders?user_id=eq.$userId&order=created_at.desc';
  static String orderItemsByOrder(String orderId) =>
      '$orderItems?order_id=eq.$orderId&select=*,product:products(*)';

  // Deliveries
  static const String deliveries = '$rest/deliveries';
  static String deliveriesByOrder(String orderId) =>
      '$deliveries?order_id=eq.$orderId';
  static String pendingDeliveries() =>
      '$deliveries?status=neq.DELIVERED&select=*,order:orders(*,customer:customers(*))';

  // Payments
  static const String payments = '$rest/payments';
  static String paymentsByCustomer(String customerId) =>
      '$payments?customer_id=eq.$customerId&order=paid_at.desc';
  static String paymentsByUser(String userId) =>
      '$payments?user_id=eq.$userId&order=paid_at.desc';

  // Returns
  static const String returns = '$rest/returns';
  static String returnsByOrder(String orderId) =>
      '$returns?order_id=eq.$orderId';

  // Routes and planning
  static const String routes = '$rest/routes';
  static const String routeStops = '$rest/route_stops';
  static String routeById(String id) =>
      '$routes?id=eq.$id&select=*,stops:route_stops(*,customer:customers(*))';
  static String routesByUser(String userId) =>
      '$routes?owner_id=eq.$userId&order=date.desc';
  static String routesByDate(String date) => '$routes?date=eq.$date';
  static String routeStopsByRoute(String routeId) =>
      '$routeStops?route_id=eq.$routeId&order=sequence&select=*,customer:customers(*)';

  // Tracking and geolocation
  static const String trackingLocations = '$rest/tracking_locations';
  static String trackingByUser(String userId, String? since) {
    String url = '$trackingLocations?user_id=eq.$userId&order=at.desc';
    if (since != null) {
      url += '&at=gte.$since';
    }
    return url;
  }

  static String realtimeLocations() =>
      '$trackingLocations?at=gte.${DateTime.now().subtract(const Duration(minutes: 30)).toIso8601String()}&order=at.desc';

  // Geofences
  static const String geofences = '$rest/geofences';
  static String geofencesByOwner(String ownerId) =>
      '$geofences?owner_id=eq.$ownerId';

  // Forms and surveys
  static const String formTemplates = '$rest/form_templates';
  static const String formResponses = '$rest/form_responses';
  static String formTemplatesByCompany(String companyId) =>
      '$formTemplates?company_id=eq.$companyId';
  static String formResponsesByTemplate(String templateId) =>
      '$formResponses?template_id=eq.$templateId';
  static String formResponsesByVisit(String visitId) =>
      '$formResponses?visit_id=eq.$visitId';

  // Promotions
  static const String promotions = '$rest/promotions';
  static String activePromotions() =>
      '$promotions?active=eq.true&starts_at=lte.${DateTime.now().toIso8601String()}&ends_at=gte.${DateTime.now().toIso8601String()}';

  // Audit logs
  static const String auditLogs = '$rest/audit_logs';
  static String auditLogsByEntity(String entity, String entityId) =>
      '$auditLogs?entity=eq.$entity&entity_id=eq.$entityId&order=created_at.desc';

  // Email queue
  static const String emailQueue = '$rest/email_queue';
  static String pendingEmails() => '$emailQueue?sent_at=is.null';

  // Storage endpoints
  static const String evidencePhotos = '$storage/object/evidence-photos';
  static const String signatures = '$storage/object/signatures';
  static const String documents = '$storage/object/documents';

  // File upload
  static String uploadFile(String bucket, String fileName) =>
      '$storage/object/$bucket/$fileName';
  static String downloadFile(String bucket, String fileName) =>
      '$storage/object/public/$bucket/$fileName';

  // Edge Functions
  static const String sendEmail = '$functions/send-email';
  static const String generateReport = '$functions/generate-report';
  static const String syncData = '$functions/sync-data';
  static const String calculateDistance = '$functions/calculate-distance';
  static const String validateGeofence = '$functions/validate-geofence';

  // RPC Functions
  static const String recalcOrderTotals = '$rest/rpc/recalc_order_totals';
  static const String enqueueVisitEmail = '$rest/rpc/enqueue_visit_email';

  // Query builders
  static String withSelect(String baseUrl, String select) {
    final separator = baseUrl.contains('?') ? '&' : '?';
    return '$baseUrl${separator}select=$select';
  }

  static String withFilter(String baseUrl, String filter) {
    final separator = baseUrl.contains('?') ? '&' : '?';
    return '$baseUrl$separator$filter';
  }

  static String withOrder(String baseUrl, String order) {
    final separator = baseUrl.contains('?') ? '&' : '?';
    return '$baseUrl${separator}order=$order';
  }

  static String withLimit(String baseUrl, int limit) {
    final separator = baseUrl.contains('?') ? '&' : '?';
    return '$baseUrl${separator}limit=$limit';
  }

  static String withRange(String baseUrl, int from, int to) {
    final separator = baseUrl.contains('?') ? '&' : '?';
    return '$baseUrl${separator}offset=$from&limit=${to - from + 1}';
  }

  // Real-time subscriptions
  static String realtimeChannel(String table) => 'realtime:$table';
  static String realtimeFilter(String column, String operator, String value) =>
      '$column=$operator.$value';
}


===== lib/app.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'core/theme/theme.dart';
import 'features/auth/bloc/auth_cubit.dart';
import 'features/map/bloc/map_cubit.dart';
import 'features/customers/bloc/customers_cubit.dart';
import 'features/visits/bloc/visits_cubit.dart';
import 'features/orders/bloc/order_cubit.dart';
import 'features/deliveries/bloc/deliveries_cubit.dart';
import 'features/payments/bloc/payments_cubit.dart';
import 'features/supervisor/bloc/supervisor_cubit.dart';
import 'routing/app_router.dart';
import 'data/repositories/auth_repository.dart';
import 'data/repositories/customers_repository.dart';
import 'data/repositories/visits_repository.dart';
import 'data/repositories/orders_repository.dart';
import 'data/repositories/deliveries_repository.dart';
import 'data/repositories/payments_repository.dart';
import 'data/repositories/tracking_repository.dart';
import 'services/location/location_service.dart';
import 'services/sync/sync_queue.dart';

class ArsenalSellApp extends StatelessWidget {
  const ArsenalSellApp({super.key});

  @override
  Widget build(BuildContext context) => MultiRepositoryProvider(
        providers: [
          RepositoryProvider(create: (_) => AuthRepository()),
          RepositoryProvider(create: (_) => CustomersRepository()),
          RepositoryProvider(create: (_) => VisitsRepository()),
          RepositoryProvider(create: (_) => OrdersRepository()),
          RepositoryProvider(create: (_) => DeliveriesRepository()),
          RepositoryProvider(create: (_) => PaymentsRepository()),
          RepositoryProvider(create: (_) => TrackingRepository()),
          RepositoryProvider(create: (_) => LocationService()),
          RepositoryProvider(create: (_) => SyncQueue()),
        ],
        child: MultiBlocProvider(
          providers: [
            BlocProvider(
              create: (context) => AuthCubit(
                context.read<AuthRepository>(),
              )..checkAuthStatus(),
            ),
            BlocProvider(
              create: (context) => MapCubit(
                context.read<LocationService>(),
                context.read<TrackingRepository>(),
              ),
            ),
            BlocProvider(
              create: (context) => CustomersCubit(
                context.read<CustomersRepository>(),
              ),
            ),
            BlocProvider(
              create: (context) => VisitsCubit(
                context.read<VisitsRepository>(),
                context.read<LocationService>(),
              ),
            ),
            BlocProvider(
              create: (context) => OrderCubit(
                context.read<OrdersRepository>(),
              ),
            ),
            BlocProvider(
              create: (context) => DeliveriesCubit(
                context.read<DeliveriesRepository>(),
              ),
            ),
            BlocProvider(
              create: (context) => PaymentsCubit(
                context.read<PaymentsRepository>(),
              ),
            ),
            BlocProvider(
              create: (context) => SupervisorCubit(
                  context.read<TrackingRepository>(),
                  context.read<CustomersRepository>()),
            ),
          ],
          child: MaterialApp.router(
            title: 'Arsenal Sell App',
            theme: AppTheme.lightTheme,
            darkTheme: AppTheme.darkTheme,
            routerConfig: AppRouter.router,
            debugShowCheckedModeBanner: false,
          ),
        ),
      );
}


===== lib/services/location/location_service.dart =====
import 'dart:async';
import 'package:geolocator/geolocator.dart';
import 'package:permission_handler/permission_handler.dart';
import '../../config/logger.dart';
import '../../config/app_constants.dart';

class LocationService {
  static final LocationService _instance = LocationService._internal();
  factory LocationService() => _instance;
  LocationService._internal();

  StreamController<Position>? _locationController;
  StreamSubscription<Position>? _locationSubscription;

  Stream<Position> get locationStream {
    _locationController ??= StreamController<Position>.broadcast();
    return _locationController!.stream;
  }

  Future<bool> requestPermissions() async {
    try {
      final status = await Permission.location.request();
      if (status.isGranted) {
        final backgroundStatus = await Permission.locationAlways.request();
        return backgroundStatus.isGranted;
      }
      return false;
    } catch (e) {
      logger.e('Request permissions error: $e');
      return false;
    }
  }

  Future<Position?> getCurrentLocation() async {
    try {
      final hasPermission = await _checkLocationPermission();
      if (!hasPermission) return null;

      return await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10),
      );
    } catch (e) {
      logger.e('Get current location error: $e');
      return null;
    }
  }

  Future<void> startLocationTracking() async {
    try {
      final hasPermission = await _checkLocationPermission();
      if (!hasPermission) {
        logger.w('Location permission not granted');
        return;
      }

      const locationSettings = LocationSettings(
        accuracy: LocationAccuracy.high,
        distanceFilter: 5, // meters
        timeLimit: Duration(seconds: 30),
      );

      _locationSubscription = Geolocator.getPositionStream(
        locationSettings: locationSettings,
      ).listen(
        (position) {
          _locationController?.add(position);
        },
        onError: (error) {
          logger.e('Location stream error: $error');
        },
      );
    } catch (e) {
      logger.e('Start location tracking error: $e');
    }
  }

  Future<void> stopLocationTracking() async {
    await _locationSubscription?.cancel();
    _locationSubscription = null;
  }

  Future<bool> _checkLocationPermission() async {
    bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      logger.w('Location services are disabled');
      return false;
    }

    LocationPermission permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        logger.w('Location permissions are denied');
        return false;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      logger.w('Location permissions are permanently denied');
      return false;
    }

    return true;
  }

  double calculateDistance(
    double lat1,
    double lon1,
    double lat2,
    double lon2,
  ) {
    return Geolocator.distanceBetween(lat1, lon1, lat2, lon2);
  }

  bool isWithinGeofence(
    double currentLat,
    double currentLon,
    double targetLat,
    double targetLon,
    double radiusM,
  ) {
    final distance =
        calculateDistance(currentLat, currentLon, targetLat, targetLon);
    return distance <= radiusM;
  }

  void dispose() {
    stopLocationTracking();
    _locationController?.close();
  }
}


===== lib/services/location/background_location.dart =====
import 'dart:async';
import 'dart:isolate';
import 'dart:ui';
import 'package:flutter/foundation.dart';
import 'package:geolocator/geolocator.dart';
import '../../config/logger.dart';
import '../../config/app_constants.dart';
import '../../data/models/geo/location_sample.dart';
import '../../data/repositories/tracking_repository.dart';

class BackgroundLocationService {
  static const String _isolateName = 'LocationIsolate';
  static const String _portName = 'LocationPort';

  static ReceivePort? _receivePort;
  static SendPort? _sendPort;
  static StreamSubscription<Position>? _locationSubscription;
  static bool _isRunning = false;

  static Future<bool> start() async {
    if (_isRunning) return true;

    try {
      // Check permissions
      final permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied ||
          permission == LocationPermission.deniedForever) {
        logger.w('Location permission not granted for background tracking');
        return false;
      }

      // Initialize isolate communication
      _receivePort = ReceivePort();
      final isolateReady = Completer<bool>();

      _receivePort!.listen((dynamic data) {
        if (data is SendPort) {
          _sendPort = data;
          isolateReady.complete(true);
        } else if (data is Map) {
          _handleLocationUpdate(data);
        }
      });

      // Start isolate
      await Isolate.spawn(
        _locationIsolateEntryPoint,
        _receivePort!.sendPort,
        debugName: _isolateName,
      );

      await isolateReady.future;
      _isRunning = true;

      logger.i('Background location service started');
      return true;
    } catch (e) {
      logger.e('Failed to start background location service: $e');
      return false;
    }
  }

  static Future<void> stop() async {
    if (!_isRunning) return;

    try {
      _sendPort?.send({'command': 'stop'});
      _receivePort?.close();
      _locationSubscription?.cancel();

      _receivePort = null;
      _sendPort = null;
      _locationSubscription = null;
      _isRunning = false;

      logger.i('Background location service stopped');
    } catch (e) {
      logger.e('Error stopping background location service: $e');
    }
  }

  static void _locationIsolateEntryPoint(SendPort sendPort) {
    final receivePort = ReceivePort();
    sendPort.send(receivePort.sendPort);

    StreamSubscription<Position>? locationSubscription;

    receivePort.listen((dynamic data) async {
      if (data is Map && data['command'] == 'stop') {
        locationSubscription?.cancel();
        Isolate.exit();
      }
    });

    // Start location tracking in isolate
    const locationSettings = LocationSettings(
      accuracy: LocationAccuracy.high,
      distanceFilter: 10, // meters
      timeLimit: Duration(seconds: 30),
    );

    locationSubscription = Geolocator.getPositionStream(
      locationSettings: locationSettings,
    ).listen(
      (position) {
        sendPort.send({
          'latitude': position.latitude,
          'longitude': position.longitude,
          'accuracy': position.accuracy,
          'speed': position.speed,
          'timestamp': position.timestamp.millisecondsSinceEpoch,
        });
      },
      onError: (error) {
        sendPort.send({'error': error.toString()});
      },
    );
  }

  static void _handleLocationUpdate(Map<String, dynamic> data) {
    if (data.containsKey('error')) {
      logger.e('Background location error: ${data['error']}');
      return;
    }

    try {
      final locationSample = LocationSample(
        id: DateTime.now().millisecondsSinceEpoch,
        companyId: 'current_company_id', // TODO: Get from auth
        userId: 'current_user_id', // TODO: Get from auth
        at: DateTime.fromMillisecondsSinceEpoch(data['timestamp']),
        latitude: data['latitude'],
        longitude: data['longitude'],
        speedMs: data['speed'],
        accuracyM: data['accuracy'],
      );

      // Save to local database (this would need to be done through a service)
      // TrackingRepository().saveLocationSample(locationSample);
    } catch (e) {
      logger.e('Error handling location update: $e');
    }
  }

  static bool get isRunning => _isRunning;
}


===== lib/services/location/geofence_service.dart =====
import 'dart:async';
import 'package:geolocator/geolocator.dart';
import '../../config/logger.dart';
import '../../data/models/geo/geofence.dart';
import '../../data/models/customers/customer.dart';

enum GeofenceEvent { enter, exit, dwell }

class GeofenceService {
  static final GeofenceService _instance = GeofenceService._internal();
  factory GeofenceService() => _instance;
  GeofenceService._internal();

  final Map<String, Geofence> _activeGeofences = {};
  final Map<String, bool> _currentStatus = {}; // true = inside, false = outside
  final StreamController<GeofenceEventData> _eventController =
      StreamController<GeofenceEventData>.broadcast();

  Stream<GeofenceEventData> get eventStream => _eventController.stream;

  void addCustomerGeofence(Customer customer) {
    if (customer.latitude == null || customer.longitude == null) return;

    final geofence = Geofence(
      id: 'customer_${customer.id}',
      companyId: customer.companyId,
      ownerId: 'current_user_id', // TODO: Get from auth
      radiusM: 10, // Default radius
      centerLatitude: customer.latitude!,
      centerLongitude: customer.longitude!,
    );

    _activeGeofences[geofence.id] = geofence;
    _currentStatus[geofence.id] = false;
  }

  void addGeofence(Geofence geofence) {
    _activeGeofences[geofence.id] = geofence;
    _currentStatus[geofence.id] = false;
  }

  void removeGeofence(String geofenceId) {
    _activeGeofences.remove(geofenceId);
    _currentStatus.remove(geofenceId);
  }

  void clearAllGeofences() {
    _activeGeofences.clear();
    _currentStatus.clear();
  }

  void checkPosition(Position position) {
    for (final geofence in _activeGeofences.values) {
      final distance = Geolocator.distanceBetween(
        position.latitude,
        position.longitude,
        geofence.centerLatitude,
        geofence.centerLongitude,
      );

      final isInside = distance <= geofence.radiusM;
      final wasInside = _currentStatus[geofence.id] ?? false;

      if (isInside && !wasInside) {
        // Entered geofence
        _currentStatus[geofence.id] = true;
        _eventController.add(GeofenceEventData(
          geofence: geofence,
          event: GeofenceEvent.enter,
          position: position,
          distance: distance,
        ));
      } else if (!isInside && wasInside) {
        // Exited geofence
        _currentStatus[geofence.id] = false;
        _eventController.add(GeofenceEventData(
          geofence: geofence,
          event: GeofenceEvent.exit,
          position: position,
          distance: distance,
        ));
      }
    }
  }

  bool isInsideGeofence(String geofenceId) {
    return _currentStatus[geofenceId] ?? false;
  }

  List<String> getActiveGeofences() {
    return _currentStatus.entries
        .where((entry) => entry.value)
        .map((entry) => entry.key)
        .toList();
  }

  void dispose() {
    _eventController.close();
    _activeGeofences.clear();
    _currentStatus.clear();
  }
}

class GeofenceEventData {
  final Geofence geofence;
  final GeofenceEvent event;
  final Position position;
  final double distance;

  GeofenceEventData({
    required this.geofence,
    required this.event,
    required this.position,
    required this.distance,
  });
}


===== lib/services/sync/serializers.dart =====
import 'dart:convert';
import '../../config/logger.dart';
import '../../data/models/customers/customer.dart';
import '../../data/models/visits/visit.dart';
import '../../data/models/sales/order.dart';
import '../../data/models/sales/product.dart';
import '../../data/models/geo/location_sample.dart';
import '../../data/models/auth/user_profile.dart';
import '../../data/models/routes/route_plan.dart';
import '../../data/repositories/payments_repository.dart';

/// Service for serializing and deserializing data for sync operations
class SyncSerializers {
  /// Serialize customer data for sync
  static Map<String, dynamic> serializeCustomer(Customer customer) {
    try {
      final data = customer.toJson();

      // Add sync metadata
      data['sync_action'] = 'upsert';
      data['sync_timestamp'] = DateTime.now().toIso8601String();
      data['local_id'] = customer.id;

      // Handle coordinates for PostGIS
      if (customer.latitude != null && customer.longitude != null) {
        data['location'] = {
          'type': 'Point',
          'coordinates': [customer.longitude, customer.latitude],
        };
      }

      return data;
    } catch (e) {
      logger.e('Serialize customer error: $e');
      rethrow;
    }
  }

  /// Deserialize customer data from sync
  static Customer deserializeCustomer(Map<String, dynamic> data) {
    try {
      // Handle PostGIS coordinates
      if (data['location'] != null && data['location']['coordinates'] != null) {
        final coordinates = data['location']['coordinates'] as List;
        if (coordinates.length >= 2) {
          data['longitude'] = coordinates[0];
          data['latitude'] = coordinates[1];
        }
      }

      return Customer.fromJson(data);
    } catch (e) {
      logger.e('Deserialize customer error: $e');
      rethrow;
    }
  }

  /// Serialize visit data for sync
  static Map<String, dynamic> serializeVisit(Visit visit) {
    try {
      final data = visit.toJson();

      // Add sync metadata
      data['sync_action'] = 'upsert';
      data['sync_timestamp'] = DateTime.now().toIso8601String();
      data['local_id'] = visit.id;

      // Handle coordinates for PostGIS
      if (visit.checkinLatitude != null && visit.checkinLongitude != null) {
        data['checkin'] = {
          'type': 'Point',
          'coordinates': [visit.checkinLongitude, visit.checkinLatitude],
        };
      }

      if (visit.checkoutLatitude != null && visit.checkoutLongitude != null) {
        data['checkout'] = {
          'type': 'Point',
          'coordinates': [visit.checkoutLongitude, visit.checkoutLatitude],
        };
      }

      // Handle photos and signatures
      if (visit.photos.isNotEmpty) {
        data['photos'] = visit.photos
            .map((photo) => {
                  'storage_path': photo.storagePath,
                  'created_at': photo.createdAt?.toIso8601String(),
                })
            .toList();
      }

      if (visit.signature != null) {
        data['signature'] = {
          'storage_path': visit.signature!.storagePath,
          'signed_by': visit.signature!.signedBy,
          'created_at': visit.signature!.createdAt?.toIso8601String(),
        };
      }

      return data;
    } catch (e) {
      logger.e('Serialize visit error: $e');
      rethrow;
    }
  }

  /// Deserialize visit data from sync
  static Visit deserializeVisit(Map<String, dynamic> data) {
    try {
      // Handle PostGIS coordinates
      if (data['checkin'] != null && data['checkin']['coordinates'] != null) {
        final coordinates = data['checkin']['coordinates'] as List;
        if (coordinates.length >= 2) {
          data['checkinLongitude'] = coordinates[0];
          data['checkinLatitude'] = coordinates[1];
        }
      }

      if (data['checkout'] != null && data['checkout']['coordinates'] != null) {
        final coordinates = data['checkout']['coordinates'] as List;
        if (coordinates.length >= 2) {
          data['checkoutLongitude'] = coordinates[0];
          data['checkoutLatitude'] = coordinates[1];
        }
      }

      // Handle photos array
      if (data['photos'] != null) {
        final photos = (data['photos'] as List)
            .map((photo) => VisitPhoto(
                  id: photo['id'] ??
                      DateTime.now().millisecondsSinceEpoch.toString(),
                  visitId: data['id'],
                  storagePath: photo['storage_path'],
                  createdAt: photo['created_at'] != null
                      ? DateTime.parse(photo['created_at'])
                      : null,
                ))
            .toList();
        data['photos'] = photos.map((p) => p.toJson()).toList();
      }

      // Handle signature
      if (data['signature'] != null) {
        final signature = VisitSignature(
          id: data['signature']['id'] ??
              DateTime.now().millisecondsSinceEpoch.toString(),
          visitId: data['id'],
          storagePath: data['signature']['storage_path'],
          signedBy: data['signature']['signed_by'],
          createdAt: data['signature']['created_at'] != null
              ? DateTime.parse(data['signature']['created_at'])
              : null,
        );
        data['signature'] = signature.toJson();
      }

      return Visit.fromJson(data);
    } catch (e) {
      logger.e('Deserialize visit error: $e');
      rethrow;
    }
  }

  /// Serialize order data for sync
  static Map<String, dynamic> serializeOrder(Order order) {
    try {
      final data = order.toJson();

      // Add sync metadata
      data['sync_action'] = 'upsert';
      data['sync_timestamp'] = DateTime.now().toIso8601String();
      data['local_id'] = order.id;

      // Serialize order items separately for relational structure
      if (order.items.isNotEmpty) {
        data['items'] = order.items
            .map((item) => {
                  'id': item.id,
                  'order_id': order.id,
                  'product_id': item.productId,
                  'qty': item.qty,
                  'price': item.price,
                  'discount': item.discount,
                  'total': item.total,
                })
            .toList();
      }

      return data;
    } catch (e) {
      logger.e('Serialize order error: $e');
      rethrow;
    }
  }

  /// Deserialize order data from sync
  static Order deserializeOrder(Map<String, dynamic> data) {
    try {
      // Handle order items
      if (data['items'] != null) {
        final items = (data['items'] as List)
            .map((itemData) => OrderItem(
                  id: itemData['id'],
                  orderId: itemData['order_id'],
                  productId: itemData['product_id'],
                  qty: itemData['qty']?.toDouble() ?? 0,
                  price: itemData['price']?.toDouble() ?? 0,
                  discount: itemData['discount']?.toDouble() ?? 0,
                  total: itemData['total']?.toDouble() ?? 0,
                ))
            .toList();
        data['items'] = items.map((item) => item.toJson()).toList();
      }

      return Order.fromJson(data);
    } catch (e) {
      logger.e('Deserialize order error: $e');
      rethrow;
    }
  }

  /// Serialize location sample for sync
  static Map<String, dynamic> serializeLocationSample(LocationSample sample) {
    try {
      final data = sample.toJson();

      // Add sync metadata
      data['sync_action'] = 'insert';
      data['sync_timestamp'] = DateTime.now().toIso8601String();
      data['local_id'] = sample.id.toString();

      // Handle coordinates for PostGIS
      data['point'] = {
        'type': 'Point',
        'coordinates': [sample.longitude, sample.latitude],
      };

      return data;
    } catch (e) {
      logger.e('Serialize location sample error: $e');
      rethrow;
    }
  }

  /// Deserialize location sample from sync
  static LocationSample deserializeLocationSample(Map<String, dynamic> data) {
    try {
      // Handle PostGIS coordinates
      if (data['point'] != null && data['point']['coordinates'] != null) {
        final coordinates = data['point']['coordinates'] as List;
        if (coordinates.length >= 2) {
          data['longitude'] = coordinates[0];
          data['latitude'] = coordinates[1];
        }
      }

      return LocationSample.fromJson(data);
    } catch (e) {
      logger.e('Deserialize location sample error: $e');
      rethrow;
    }
  }

  /// Serialize payment data for sync
  static Map<String, dynamic> serializePayment(PaymentModel payment) {
    try {
      final data = {
        'id': payment.id,
        'order_id': payment.orderId,
        'customer_id': payment.customerId,
        'user_id': payment.userId,
        'amount': payment.amount,
        'method': payment.method,
        'paid_at': payment.paidAt.toIso8601String(),
        'notes': payment.notes,
        'status': payment.status,
      };

      // Add sync metadata
      data['sync_action'] = 'upsert';
      data['sync_timestamp'] = DateTime.now().toIso8601String();
      data['local_id'] = payment.id;

      return data;
    } catch (e) {
      logger.e('Serialize payment error: $e');
      rethrow;
    }
  }

  /// Deserialize payment data from sync
  static PaymentModel deserializePayment(Map<String, dynamic> data) {
    try {
      return PaymentModel(
        id: data['id'],
        orderId: data['order_id'],
        customerId: data['customer_id'],
        userId: data['user_id'],
        amount: data['amount']?.toDouble() ?? 0,
        method: data['method'],
        paidAt: DateTime.parse(data['paid_at']),
        notes: data['notes'],
        status: data['status'] ?? 'PENDING',
      );
    } catch (e) {
      logger.e('Deserialize payment error: $e');
      rethrow;
    }
  }

  /// Serialize route plan for sync
  static Map<String, dynamic> serializeRoutePlan(RoutePlan route) {
    try {
      final data = route.toJson();

      // Add sync metadata
      data['sync_action'] = 'upsert';
      data['sync_timestamp'] = DateTime.now().toIso8601String();
      data['local_id'] = route.id;

      // Serialize route stops separately for relational structure
      if (route.stops.isNotEmpty) {
        data['stops'] = route.stops
            .map((stop) => {
                  'id': stop.id,
                  'route_id': route.id,
                  'customer_id': stop.customerId,
                  'planned_time': stop.plannedTime?.toIso8601String(),
                  'sequence': stop.sequence,
                  'notes': stop.notes,
                })
            .toList();
      }

      return data;
    } catch (e) {
      logger.e('Serialize route plan error: $e');
      rethrow;
    }
  }

  /// Create batch sync payload
  static Map<String, dynamic> createBatchSyncPayload({
    List<Customer>? customers,
    List<Visit>? visits,
    List<Order>? orders,
    List<LocationSample>? locationSamples,
    List<PaymentModel>? payments,
    List<RoutePlan>? routes,
  }) {
    try {
      final payload = <String, dynamic>{
        'batch_id': DateTime.now().millisecondsSinceEpoch.toString(),
        'timestamp': DateTime.now().toIso8601String(),
        'data': <String, List<Map<String, dynamic>>>{},
      };

      if (customers != null && customers.isNotEmpty) {
        payload['data']['customers'] =
            customers.map((customer) => serializeCustomer(customer)).toList();
      }

      if (visits != null && visits.isNotEmpty) {
        payload['data']['visits'] =
            visits.map((visit) => serializeVisit(visit)).toList();
      }

      if (orders != null && orders.isNotEmpty) {
        payload['data']['orders'] =
            orders.map((order) => serializeOrder(order)).toList();
      }

      if (locationSamples != null && locationSamples.isNotEmpty) {
        payload['data']['tracking_locations'] = locationSamples
            .map((sample) => serializeLocationSample(sample))
            .toList();
      }

      if (payments != null && payments.isNotEmpty) {
        payload['data']['payments'] =
            payments.map((payment) => serializePayment(payment)).toList();
      }

      if (routes != null && routes.isNotEmpty) {
        payload['data']['routes'] =
            routes.map((route) => serializeRoutePlan(route)).toList();
      }

      return payload;
    } catch (e) {
      logger.e('Create batch sync payload error: $e');
      rethrow;
    }
  }

  /// Parse batch sync response
  static Map<String, List<dynamic>> parseBatchSyncResponse(
      Map<String, dynamic> response) {
    try {
      final result = <String, List<dynamic>>{};

      if (response['data'] != null) {
        final data = response['data'] as Map<String, dynamic>;

        if (data['customers'] != null) {
          result['customers'] = (data['customers'] as List)
              .map((item) => deserializeCustomer(item))
              .toList();
        }

        if (data['visits'] != null) {
          result['visits'] = (data['visits'] as List)
              .map((item) => deserializeVisit(item))
              .toList();
        }

        if (data['orders'] != null) {
          result['orders'] = (data['orders'] as List)
              .map((item) => deserializeOrder(item))
              .toList();
        }

        if (data['tracking_locations'] != null) {
          result['tracking_locations'] = (data['tracking_locations'] as List)
              .map((item) => deserializeLocationSample(item))
              .toList();
        }

        if (data['payments'] != null) {
          result['payments'] = (data['payments'] as List)
              .map((item) => deserializePayment(item))
              .toList();
        }
      }

      return result;
    } catch (e) {
      logger.e('Parse batch sync response error: $e');
      rethrow;
    }
  }

  /// Validate sync data integrity
  static bool validateSyncData(Map<String, dynamic> data, String dataType) {
    try {
      switch (dataType) {
        case 'customer':
          return data.containsKey('id') &&
              data.containsKey('name') &&
              data.containsKey('company_id');
        case 'visit':
          return data.containsKey('id') &&
              data.containsKey('customer_id') &&
              data.containsKey('purpose');
        case 'order':
          return data.containsKey('id') &&
              data.containsKey('customer_id') &&
              data.containsKey('status');
        case 'location_sample':
          return data.containsKey('user_id') &&
              data.containsKey('latitude') &&
              data.containsKey('longitude');
        case 'payment':
          return data.containsKey('id') &&
              data.containsKey('amount') &&
              data.containsKey('paid_at');
        default:
          return false;
      }
    } catch (e) {
      logger.e('Validate sync data error: $e');
      return false;
    }
  }

  /// Clean sync metadata from data
  static Map<String, dynamic> cleanSyncMetadata(Map<String, dynamic> data) {
    final cleanData = Map<String, dynamic>.from(data);
    cleanData.removeWhere((key, value) => key.startsWith('sync_'));
    cleanData.remove('local_id');
    return cleanData;
  }

  /// Generate sync diff
  static Map<String, dynamic> generateSyncDiff({
    required Map<String, dynamic> localData,
    required Map<String, dynamic> serverData,
  }) {
    final diff = <String, dynamic>{};

    localData.forEach((key, localValue) {
      final serverValue = serverData[key];

      if (serverValue == null) {
        diff[key] = {'action': 'add', 'value': localValue};
      } else if (localValue != serverValue) {
        diff[key] = {
          'action': 'update',
          'old_value': serverValue,
          'new_value': localValue,
        };
      }
    });

    serverData.forEach((key, serverValue) {
      if (!localData.containsKey(key)) {
        diff[key] = {'action': 'remove', 'value': serverValue};
      }
    });

    return diff;
  }

  /// Compress sync data for efficient transfer
  static String compressSyncData(Map<String, dynamic> data) {
    try {
      final jsonString = jsonEncode(data);
      // In a real implementation, you might use gzip compression
      return jsonString;
    } catch (e) {
      logger.e('Compress sync data error: $e');
      rethrow;
    }
  }

  /// Decompress sync data
  static Map<String, dynamic> decompressSyncData(String compressedData) {
    try {
      // In a real implementation, you might use gzip decompression
      return jsonDecode(compressedData) as Map<String, dynamic>;
    } catch (e) {
      logger.e('Decompress sync data error: $e');
      rethrow;
    }
  }
}


===== lib/services/sync/sync_queue.dart =====
import 'dart:async';
import 'dart:convert';
import 'package:connectivity_plus/connectivity_plus.dart';
import '../../data/local/hive/boxes.dart';
import '../../data/repositories/customers_repository.dart';
import '../../data/repositories/visits_repository.dart';
import '../../data/repositories/orders_repository.dart';
import '../../data/repositories/tracking_repository.dart';
import '../../config/logger.dart';
import '../../config/app_constants.dart';

enum SyncItemType { customer, visit, order, tracking }

class SyncItem {
  final String id;
  final SyncItemType type;
  final Map<String, dynamic> data;
  final DateTime createdAt;
  final int retryCount;

  SyncItem({
    required this.id,
    required this.type,
    required this.data,
    required this.createdAt,
    this.retryCount = 0,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'type': type.name,
        'data': data,
        'createdAt': createdAt.toIso8601String(),
        'retryCount': retryCount,
      };

  factory SyncItem.fromJson(Map<String, dynamic> json) => SyncItem(
        id: json['id'],
        type: SyncItemType.values.byName(json['type']),
        data: json['data'],
        createdAt: DateTime.parse(json['createdAt']),
        retryCount: json['retryCount'] ?? 0,
      );
}

class SyncQueue {
  static final SyncQueue _instance = SyncQueue._internal();
  factory SyncQueue() => _instance;
  SyncQueue._internal();

  Timer? _syncTimer;
  bool _isSyncing = false;

  // Repositories
  late CustomersRepository _customersRepo;
  late VisitsRepository _visitsRepo;
  late OrdersRepository _ordersRepo;
  late TrackingRepository _trackingRepo;

  void initialize({
    required CustomersRepository customersRepo,
    required VisitsRepository visitsRepo,
    required OrdersRepository ordersRepo,
    required TrackingRepository trackingRepo,
  }) {
    _customersRepo = customersRepo;
    _visitsRepo = visitsRepo;
    _ordersRepo = ordersRepo;
    _trackingRepo = trackingRepo;

    _startPeriodicSync();
  }

  Future<void> addToQueue(SyncItem item) async {
    try {
      final box = HiveBoxes.syncQueueBox;
      await box.put(item.id, item.toJson());

      // Try immediate sync if online
      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity != ConnectivityResult.none && !_isSyncing) {
        unawaited(_processQueue());
      }
    } catch (e) {
      logger.e('Add to sync queue error: $e');
    }
  }

  Future<void> _processQueue() async {
    if (_isSyncing) return;

    try {
      _isSyncing = true;

      final connectivity = await Connectivity().checkConnectivity();
      if (connectivity == ConnectivityResult.none) {
        logger.i('No internet connection, skipping sync');
        return;
      }

      final box = HiveBoxes.syncQueueBox;
      final keys = box.keys.toList();

      for (final key in keys) {
        final itemData = box.get(key);
        if (itemData == null) continue;

        try {
          final item = SyncItem.fromJson(Map<String, dynamic>.from(itemData));

          if (item.retryCount >= AppConstants.maxRetryAttempts) {
            logger.w('Max retry attempts reached for sync item ${item.id}');
            await box.delete(key);
            continue;
          }

          final success = await _syncItem(item);

          if (success) {
            await box.delete(key);
            logger.d('Synced item ${item.id} successfully');
          } else {
            // Increment retry count
            final updatedItem = SyncItem(
              id: item.id,
              type: item.type,
              data: item.data,
              createdAt: item.createdAt,
              retryCount: item.retryCount + 1,
            );
            await box.put(key, updatedItem.toJson());
          }
        } catch (e) {
          logger.e('Process sync item error: $e');
        }
      }
    } catch (e) {
      logger.e('Process sync queue error: $e');
    } finally {
      _isSyncing = false;
    }
  }

  Future<bool> _syncItem(SyncItem item) async {
    try {
      switch (item.type) {
        case SyncItemType.customer:
          // Handle customer sync
          break;
        case SyncItemType.visit:
          // Handle visit sync
          break;
        case SyncItemType.order:
          // Handle order sync
          break;
        case SyncItemType.tracking:
          await _trackingRepo.syncPendingLocations();
          break;
      }
      return true;
    } catch (e) {
      logger.e('Sync item ${item.id} error: $e');
      return false;
    }
  }

  void _startPeriodicSync() {
    _syncTimer?.cancel();
    _syncTimer = Timer.periodic(AppConstants.syncInterval, (_) {
      if (!_isSyncing) {
        unawaited(_processQueue());
      }
    });
  }

  Future<int> getPendingCount() async {
    return HiveBoxes.syncQueueBox.length;
  }

  void dispose() {
    _syncTimer?.cancel();
    _locationSubscription?.cancel();
  }
}


===== lib/services/sync/sync_worker.dart =====
import 'dart:async';
import 'dart:isolate';
import 'package:connectivity_plus/connectivity_plus.dart';
import '../../config/logger.dart';
import '../../config/app_constants.dart';
import '../../data/repositories/customers_repository.dart';
import '../../data/repositories/visits_repository.dart';
import '../../data/repositories/orders_repository.dart';
import '../../data/repositories/tracking_repository.dart';
import '../../data/repositories/payments_repository.dart';
import 'sync_queue.dart';

enum SyncStatus {
  idle,
  syncing,
  success,
  error,
  paused,
}

class SyncWorker {
  static final SyncWorker _instance = SyncWorker._internal();
  factory SyncWorker() => _instance;
  SyncWorker._internal();

  Timer? _syncTimer;
  StreamController<SyncStatus>? _statusController;
  StreamController<SyncProgress>? _progressController;

  bool _isInitialized = false;
  bool _isSyncing = false;
  SyncStatus _currentStatus = SyncStatus.idle;

  // Repositories
  late CustomersRepository _customersRepo;
  late VisitsRepository _visitsRepo;
  late OrdersRepository _ordersRepo;
  late TrackingRepository _trackingRepo;
  late PaymentsRepository _paymentsRepo;
  late SyncQueue _syncQueue;

  Stream<SyncStatus> get statusStream =>
      _statusController?.stream ?? const Stream.empty();
  Stream<SyncProgress> get progressStream =>
      _progressController?.stream ?? const Stream.empty();

  SyncStatus get currentStatus => _currentStatus;
  bool get isSyncing => _isSyncing;

  Future<void> initialize({
    required CustomersRepository customersRepo,
    required VisitsRepository visitsRepo,
    required OrdersRepository ordersRepo,
    required TrackingRepository trackingRepo,
    required PaymentsRepository paymentsRepo,
    required SyncQueue syncQueue,
  }) async {
    if (_isInitialized) return;

    _customersRepo = customersRepo;
    _visitsRepo = visitsRepo;
    _ordersRepo = ordersRepo;
    _trackingRepo = trackingRepo;
    _paymentsRepo = paymentsRepo;
    _syncQueue = syncQueue;

    _statusController = StreamController<SyncStatus>.broadcast();
    _progressController = StreamController<SyncProgress>.broadcast();

    _startPeriodicSync();
    _listenToConnectivityChanges();

    _isInitialized = true;
    logger.i('SyncWorker initialized');
  }

  void _startPeriodicSync() {
    _syncTimer?.cancel();
    _syncTimer = Timer.periodic(AppConstants.syncInterval, (_) {
      if (!_isSyncing) {
        syncNow();
      }
    });
  }

  void _listenToConnectivityChanges() {
    Connectivity().onConnectivityChanged.listen((connectivity) {
      if (connectivity != ConnectivityResult.none && !_isSyncing) {
        // Connection restored, try to sync
        syncNow();
      }
    });
  }

  Future<void> syncNow({bool force = false}) async {
    if (_isSyncing && !force) {
      logger.d('Sync already in progress');
      return;
    }

    if (!await _isOnline()) {
      _updateStatus(SyncStatus.paused);
      logger.d('No internet connection, sync paused');
      return;
    }

    try {
      _isSyncing = true;
      _updateStatus(SyncStatus.syncing);
      _updateProgress(SyncProgress(
          current: 0, total: 5, operation: 'Iniciando sincronización...'));

      logger.i('Starting sync process');

      // 1. Sync pending visits
      _updateProgress(SyncProgress(
          current: 1, total: 5, operation: 'Sincronizando visitas...'));
      await _visitsRepo.syncPendingVisits();

      // 2. Sync pending orders
      _updateProgress(SyncProgress(
          current: 2, total: 5, operation: 'Sincronizando pedidos...'));
      await _ordersRepo.syncPendingOrders();

      // 3. Sync tracking locations
      _updateProgress(SyncProgress(
          current: 3, total: 5, operation: 'Sincronizando ubicaciones...'));
      await _trackingRepo.syncPendingLocations();

      // 4. Sync payments
      _updateProgress(SyncProgress(
          current: 4, total: 5, operation: 'Sincronizando pagos...'));
      // await _paymentsRepo.syncPendingPayments();

      // 5. Process sync queue
      _updateProgress(
          SyncProgress(current: 5, total: 5, operation: 'Finalizando...'));
      // Additional sync queue processing if needed

      _updateStatus(SyncStatus.success);
      _updateProgress(SyncProgress(
          current: 5, total: 5, operation: 'Sincronización completada'));

      logger.i('Sync completed successfully');
    } catch (e) {
      logger.e('Sync error: $e');
      _updateStatus(SyncStatus.error);
      _updateProgress(SyncProgress(
          current: 0, total: 5, operation: 'Error en sincronización'));
    } finally {
      _isSyncing = false;
    }
  }

  Future<void> syncSpecificData(SyncDataType dataType) async {
    if (!await _isOnline()) {
      throw Exception('No internet connection');
    }

    try {
      _updateStatus(SyncStatus.syncing);

      switch (dataType) {
        case SyncDataType.visits:
          _updateProgress(SyncProgress(
              current: 1, total: 1, operation: 'Sincronizando visitas...'));
          await _visitsRepo.syncPendingVisits();
          break;
        case SyncDataType.orders:
          _updateProgress(SyncProgress(
              current: 1, total: 1, operation: 'Sincronizando pedidos...'));
          await _ordersRepo.syncPendingOrders();
          break;
        case SyncDataType.tracking:
          _updateProgress(SyncProgress(
              current: 1, total: 1, operation: 'Sincronizando ubicaciones...'));
          await _trackingRepo.syncPendingLocations();
          break;
        case SyncDataType.customers:
          _updateProgress(SyncProgress(
              current: 1, total: 1, operation: 'Sincronizando clientes...'));
          await _customersRepo.getCustomers(forceSync: true);
          break;
        case SyncDataType.payments:
          _updateProgress(SyncProgress(
              current: 1, total: 1, operation: 'Sincronizando pagos...'));
          // await _paymentsRepo.syncPendingPayments();
          break;
      }

      _updateStatus(SyncStatus.success);
    } catch (e) {
      logger.e('Sync specific data error: $e');
      _updateStatus(SyncStatus.error);
      rethrow;
    }
  }

  Future<SyncStatus> checkPendingSync() async {
    try {
      final pendingCount = await _syncQueue.getPendingCount();
      return pendingCount > 0 ? SyncStatus.paused : SyncStatus.idle;
    } catch (e) {
      logger.e('Check pending sync error: $e');
      return SyncStatus.error;
    }
  }

  Future<int> getPendingSyncCount() async {
    try {
      return await _syncQueue.getPendingCount();
    } catch (e) {
      logger.e('Get pending sync count error: $e');
      return 0;
    }
  }

  void pauseSync() {
    _syncTimer?.cancel();
    if (_currentStatus == SyncStatus.syncing) {
      _updateStatus(SyncStatus.paused);
    }
    logger.i('Sync paused');
  }

  void resumeSync() {
    _startPeriodicSync();
    if (_currentStatus == SyncStatus.paused) {
      _updateStatus(SyncStatus.idle);
    }
    logger.i('Sync resumed');
  }

  Future<void> forceSyncAll() async {
    await syncNow(force: true);
  }

  Future<bool> _isOnline() async {
    try {
      final connectivity = await Connectivity().checkConnectivity();
      return connectivity != ConnectivityResult.none;
    } catch (e) {
      logger.e('Check connectivity error: $e');
      return false;
    }
  }

  void _updateStatus(SyncStatus status) {
    _currentStatus = status;
    _statusController?.add(status);
  }

  void _updateProgress(SyncProgress progress) {
    _progressController?.add(progress);
  }

  Future<void> runInBackground() async {
    // This would be used for background sync
    // Could be implemented with workmanager or similar
    if (!await _isOnline()) return;

    try {
      await _trackingRepo.syncPendingLocations();
      await _visitsRepo.syncPendingVisits();
    } catch (e) {
      logger.e('Background sync error: $e');
    }
  }

  void dispose() {
    _syncTimer?.cancel();
    _statusController?.close();
    _progressController?.close();
    _isInitialized = false;
    logger.i('SyncWorker disposed');
  }
}

class SyncProgress {
  final int current;
  final int total;
  final String operation;
  final double? percentage;

  SyncProgress({
    required this.current,
    required this.total,
    required this.operation,
    this.percentage,
  });

  double get calculatedPercentage =>
      percentage ?? (total > 0 ? (current / total) * 100 : 0);

  @override
  String toString() {
    return 'SyncProgress(current: $current, total: $total, operation: $operation, percentage: ${calculatedPercentage.toStringAsFixed(1)}%)';
  }
}

enum SyncDataType {
  visits,
  orders,
  customers,
  tracking,
  payments,
}

// Background isolate for sync (if needed)
class BackgroundSyncIsolate {
  static void entryPoint(SendPort sendPort) {
    final receivePort = ReceivePort();
    sendPort.send(receivePort.sendPort);

    receivePort.listen((dynamic message) async {
      if (message is Map<String, dynamic>) {
        final command = message['command'] as String;

        switch (command) {
          case 'sync_tracking':
            // Perform tracking sync in background
            break;
          case 'sync_visits':
            // Perform visits sync in background
            break;
          case 'stop':
            Isolate.exit();
            break;
        }
      }
    });
  }
}


===== lib/services/notifications/fcm_service.dart =====
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import '../../config/logger.dart';

class FCMService {
  static final FlutterLocalNotificationsPlugin _localNotifications =
      FlutterLocalNotificationsPlugin();

  static Future<void> initialize() async {
    // Request permission
    await FirebaseMessaging.instance.requestPermission(
      alert: true,
      badge: true,
      sound: true,
    );

    // Get FCM token
    final token = await FirebaseMessaging.instance.getToken();
    logger.i('FCM Token: $token');

    // Handle foreground messages
    FirebaseMessaging.onMessage.listen(_handleForegroundMessage);

    // Handle notification taps
    FirebaseMessaging.onMessageOpenedApp.listen(_handleNotificationTap);

    // Handle initial message if app opened from notification
    final initialMessage = await FirebaseMessaging.instance.getInitialMessage();
    if (initialMessage != null) {
      _handleNotificationTap(initialMessage);
    }
  }

  static Future<void> _handleForegroundMessage(RemoteMessage message) async {
    logger.i('Foreground message: ${message.messageId}');

    // Show local notification
    const androidDetails = AndroidNotificationDetails(
      'default_channel',
      'Default Channel',
      importance: Importance.high,
      priority: Priority.high,
    );

    const iosDetails = DarwinNotificationDetails();

    const details = NotificationDetails(
      android: androidDetails,
      iOS: iosDetails,
    );

    await _localNotifications.show(
      message.hashCode,
      message.notification?.title ?? 'Arsenal Sell',
      message.notification?.body ?? '',
      details,
      payload: message.data.toString(),
    );
  }

  static Future<void> _handleNotificationTap(RemoteMessage message) async {
    logger.i('Notification tapped: ${message.messageId}');

    // Handle navigation based on message data
    final data = message.data;
    if (data.containsKey('route')) {
      // Navigate to specific route
      // AppRouter.navigateTo(data['route']);
    }
  }

  static Future<void> handleBackgroundMessage(RemoteMessage message) async {
    logger.i('Background message: ${message.messageId}');
    // Handle background processing if needed
  }

  static Future<void> showLocalNotification({
    required String title,
    required String body,
    String? payload,
  }) async {
    const androidDetails = AndroidNotificationDetails(
      'local_channel',
      'Local Notifications',
      importance: Importance.high,
      priority: Priority.high,
    );

    const iosDetails = DarwinNotificationDetails();

    const details = NotificationDetails(
      android: androidDetails,
      iOS: iosDetails,
    );

    await _localNotifications.show(
      DateTime.now().millisecondsSinceEpoch.remainder(100000),
      title,
      body,
      details,
      payload: payload,
    );
  }
}


===== lib/services/media/camera_service.dart =====
import 'dart:io';
import 'package:image_picker/image_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as path;
import '../../config/logger.dart';
import '../../config/app_constants.dart';

class CameraService {
  static final ImagePicker _picker = ImagePicker();

  static Future<File?> takePicture() async {
    try {
      final XFile? image = await _picker.pickImage(
        source: ImageSource.camera,
        imageQuality: 80,
        maxWidth: 1920,
        maxHeight: 1080,
      );

      if (image != null) {
        final file = File(image.path);

        // Check file size
        final fileSize = await file.length();
        if (fileSize > AppConstants.maxPhotoSize) {
          throw Exception(
              'File size too large. Maximum size is ${AppConstants.maxPhotoSize / (1024 * 1024)}MB');
        }

        // Move to app directory
        final appDir = await getApplicationDocumentsDirectory();
        final fileName = '${DateTime.now().millisecondsSinceEpoch}.jpg';
        final savedFile =
            await file.copy(path.join(appDir.path, 'photos', fileName));

        return savedFile;
      }
      return null;
    } catch (e) {
      logger.e('Take picture error: $e');
      rethrow;
    }
  }

  static Future<File?> pickFromGallery() async {
    try {
      final XFile? image = await _picker.pickImage(
        source: ImageSource.gallery,
        imageQuality: 80,
        maxWidth: 1920,
        maxHeight: 1080,
      );

      if (image != null) {
        final file = File(image.path);

        // Check file size
        final fileSize = await file.length();
        if (fileSize > AppConstants.maxPhotoSize) {
          throw Exception(
              'File size too large. Maximum size is ${AppConstants.maxPhotoSize / (1024 * 1024)}MB');
        }

        return file;
      }
      return null;
    } catch (e) {
      logger.e('Pick from gallery error: $e');
      rethrow;
    }
  }

  static Future<List<File>> pickMultipleFromGallery() async {
    try {
      final List<XFile> images = await _picker.pickMultiImage(
        imageQuality: 80,
        maxWidth: 1920,
        maxHeight: 1080,
      );

      final List<File> files = [];
      for (final image in images) {
        final file = File(image.path);

        // Check file size
        final fileSize = await file.length();
        if (fileSize <= AppConstants.maxPhotoSize) {
          files.add(file);
        } else {
          logger.w('Skipping file ${image.name} - too large');
        }
      }

      return files;
    } catch (e) {
      logger.e('Pick multiple from gallery error: $e');
      return [];
    }
  }
}


===== lib/services/media/signature_service.dart =====
import 'dart:typed_data';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:signature/signature.dart';
import '../../config/logger.dart';

class SignatureService {
  static Future<Uint8List?> exportSignature(
      SignatureController controller) async {
    try {
      if (controller.isEmpty) {
        return null;
      }

      final image = await controller.toPngBytes(
        height: 300,
        width: 600,
      );

      return image;
    } catch (e) {
      logger.e('Export signature error: $e');
      return null;
    }
  }

  static SignatureController createController() {
    return SignatureController(
      penStrokeWidth: 2,
      penColor: Colors.black,
      exportBackgroundColor: Colors.white,
    );
  }

  static Widget buildSignaturePad(SignatureController controller) {
    return Container(
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Signature(
        controller: controller,
        backgroundColor: Colors.white,
        height: 200,
      ),
    );
  }
}


