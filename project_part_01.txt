                      color: AppPalette.textSecondary,
                      ),
                    ),
                  ],
                ),
              );
            }

            return ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: pendingPayments.length,
              itemBuilder: (context, index) {
                final payment = pendingPayments[index];
                return PaymentCard(
                  payment: payment,
                  onTap: () => _processPayment(payment),
                );
              },
            );
          },
          error: (message) => Center(child: Text(message)),
        );
      },
    );
  }

  Widget _buildCompletedPayments() {
    return BlocBuilder<PaymentsCubit, PaymentsState>(
      builder: (context, state) {
        return state.when(
          initial: () => const Center(child: Text('Cargando...')),
          loading: () => const Center(child: CircularProgressIndicator()),
          loaded: (payments) {
            final completedPayments =
                payments.where((p) => p.status == 'COMPLETED').toList();

            return ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: completedPayments.length,
              itemBuilder: (context, index) {
                final payment = completedPayments[index];
                return PaymentCard(
                  payment: payment,
                  onTap: () => _showPaymentDetails(payment),
                );
              },
            );
          },
          error: (message) => Center(child: Text(message)),
        );
      },
    );
  }

  void _showNewPaymentForm() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => const NewPaymentForm(),
    );
  }

  void _processPayment(dynamic payment) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => PaymentProcessForm(payment: payment),
    );
  }

  void _showPaymentDetails(dynamic payment) {
    // TODO: Show payment details
  }
}

class PaymentCard extends StatelessWidget {
  final dynamic payment;
  final VoidCallback onTap;

  const PaymentCard({
    super.key,
    required this.payment,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Text(
                      'Cliente Ejemplo',
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                  Text(
                    '\$2,500.00',
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: AppPalette.primary,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Row(
                children: [
                  const Icon(
                    Icons.schedule,
                    size: 16,
                    color: AppPalette.textSecondary,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    'Vence: 15/08/2025',
                    style: const TextStyle(
                      fontSize: 14,
                      color: AppPalette.textSecondary,
                    ),
                  ),
                  const Spacer(),
                  Container(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: AppPalette.warning.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      'PENDIENTE',
                      style: TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.w600,
                        color: AppPalette.warning,
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class NewPaymentForm extends StatefulWidget {
  const NewPaymentForm({super.key});

  @override
  State<NewPaymentForm> createState() => _NewPaymentFormState();
}

class _NewPaymentFormState extends State<NewPaymentForm> {
  final _formKey = GlobalKey<FormState>();
  final _amountController = TextEditingController();
  final _notesController = TextEditingController();

  Customer? _selectedCustomer;
  String _selectedMethod = 'EFECTIVO';

  @override
  Widget build(BuildContext context) {
    return Container(
      height: MediaQuery.of(context).size.height * 0.8,
      padding: const EdgeInsets.all(16),
      child: Form(
        key: _formKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            const Text(
              'Registrar Nuevo Cobro',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
            const Divider(),

            // Form fields
            Expanded(
              child: SingleChildScrollView(
                child: Column(
                  children: [
                    // Customer selection
                    DropdownButtonFormField<Customer>(
                      value: _selectedCustomer,
                      decoration: const InputDecoration(
                        labelText: 'Cliente *',
                        border: OutlineInputBorder(),
                      ),
                      items: [], // TODO: Load customers
                      onChanged: (customer) {
                        setState(() {
                          _selectedCustomer = customer;
                        });
                      },
                      validator: (value) {
                        if (value == null) return 'Cliente es requerido';
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Amount
                    TextFormField(
                      controller: _amountController,
                      keyboardType:
                          TextInputType.numberWithOptions(decimal: true),
                      decoration: const InputDecoration(
                        labelText: 'Monto *',
                        prefixText: '\$',
                        border: OutlineInputBorder(),
                      ),
                      validator: (value) {
                        if (value?.isEmpty ?? true) return 'Monto es requerido';
                        if (double.tryParse(value!) == null)
                          return 'Monto inválido';
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Payment method
                    DropdownButtonFormField<String>(
                      value: _selectedMethod,
                      decoration: const InputDecoration(
                        labelText: 'Método de Pago',
                        border: OutlineInputBorder(),
                      ),
                      items: const [
                        DropdownMenuItem(
                            value: 'EFECTIVO', child: Text('Efectivo')),
                        DropdownMenuItem(
                            value: 'TARJETA', child: Text('Tarjeta')),
                        DropdownMenuItem(
                            value: 'TRANSFERENCIA',
                            child: Text('Transferencia')),
                        DropdownMenuItem(
                            value: 'CHEQUE', child: Text('Cheque')),
                      ],
                      onChanged: (value) {
                        if (value != null) {
                          setState(() {
                            _selectedMethod = value;
                          });
                        }
                      },
                    ),
                    const SizedBox(height: 16),

                    // Notes
                    TextFormField(
                      controller: _notesController,
                      maxLines: 3,
                      decoration: const InputDecoration(
                        labelText: 'Notas',
                        border: OutlineInputBorder(),
                      ),
                    ),
                  ],
                ),
              ),
            ),

            // Save button
            SizedBox(
              width: double.infinity,
              height: 48,
              child: ElevatedButton(
                onPressed: _savePayment,
                child: const Text('Registrar Cobro'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _savePayment() {
    if (_formKey.currentState?.validate() ?? false) {
      // TODO: Save payment
      Navigator.of(context).pop();
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Cobro registrado exitosamente'),
          backgroundColor: AppPalette.success,
        ),
      );
    }
  }
}

class PaymentProcessForm extends StatefulWidget {
  final dynamic payment;

  const PaymentProcessForm({
    super.key,
    required this.payment,
  });

  @override
  State<PaymentProcessForm> createState() => _PaymentProcessFormState();
}

class _PaymentProcessFormState extends State<PaymentProcessForm> {
  final _amountController = TextEditingController();
  final _notesController = TextEditingController();
  String _selectedMethod = 'EFECTIVO';

  @override
  Widget build(BuildContext context) {
    return Container(
      height: MediaQuery.of(context).size.height * 0.7,
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Procesar Cobro',
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          const Divider(),

          // Payment amount
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: AppPalette.primary.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Monto a cobrar:',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                Text(
                  '\$2,500.00',
                  style: const TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: AppPalette.primary,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 24),

          // Form fields
          TextFormField(
            controller: _amountController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: const InputDecoration(
              labelText: 'Monto recibido *',
              prefixText: '\$',
              border: OutlineInputBorder(),
            ),
          ),
          const SizedBox(height: 16),

          DropdownButtonFormField<String>(
            value: _selectedMethod,
            decoration: const InputDecoration(
              labelText: 'Método de Pago',
              border: OutlineInputBorder(),
            ),
            items: const [
              DropdownMenuItem(value: 'EFECTIVO', child: Text('Efectivo')),
              DropdownMenuItem(value: 'TARJETA', child: Text('Tarjeta')),
              DropdownMenuItem(
                  value: 'TRANSFERENCIA', child: Text('Transferencia')),
              DropdownMenuItem(value: 'CHEQUE', child: Text('Cheque')),
            ],
            onChanged: (value) {
              if (value != null) {
                setState(() {
                  _selectedMethod = value;
                });
              }
            },
          ),
          const SizedBox(height: 16),

          TextFormField(
            controller: _notesController,
            maxLines: 3,
            decoration: const InputDecoration(
              labelText: 'Observaciones',
              border: OutlineInputBorder(),
            ),
          ),
          const Spacer(),

          // Action buttons
          Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: const Text('Cancelar'),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: ElevatedButton(
                  onPressed: _processPayment,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppPalette.success,
                  ),
                  child: const Text('Procesar Cobro'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void _processPayment() {
    // TODO: Process payment
    Navigator.of(context).pop();
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Cobro procesado exitosamente'),
        backgroundColor: AppPalette.success,
      ),
    );
  }
}


===== lib/features/payments/bloc/payments_cubit.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../../data/repositories/payments_repository.dart';
import '../../../data/models/customers/customer.dart';
import '../../../config/logger.dart';

part 'payments_state.dart';
part 'payments_cubit.freezed.dart';

class PaymentsCubit extends Cubit<PaymentsState> {
  final PaymentsRepository _repository;

  PaymentsCubit(this._repository) : super(const PaymentsState.initial());

  Future<void> loadPayments({bool forceSync = false}) async {
    emit(const PaymentsState.loading());

    try {
      final payments = await _repository.getPayments(forceSync: forceSync);
      emit(PaymentsState.loaded(payments));
    } catch (e) {
      logger.e('Load payments error: $e');
      emit(PaymentsState.error(e.toString()));
    }
  }

  Future<void> loadPendingPayments() async {
    emit(const PaymentsState.loading());

    try {
      final pendingPayments = await _repository.getPendingPayments();
      emit(PaymentsState.pendingLoaded(pendingPayments));
    } catch (e) {
      logger.e('Load pending payments error: $e');
      emit(PaymentsState.error(e.toString()));
    }
  }

  Future<void> registerPayment({
    required String? customerId,
    required double amount,
    required String method,
    String? orderId,
    String? notes,
  }) async {
    try {
      emit(const PaymentsState.processing());

      final payment = PaymentModel(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        customerId: customerId,
        orderId: orderId,
        userId: 'current_user_id', // TODO: Get from auth
        amount: amount,
        method: method,
        paidAt: DateTime.now(),
        notes: notes,
        status: 'COMPLETED',
      );

      final registeredPayment = await _repository.registerPayment(payment);

      // Update the payments list
      final currentState = state;
      if (currentState is PaymentsLoaded) {
        final updatedPayments = [registeredPayment, ...currentState.payments];
        emit(PaymentsState.loaded(updatedPayments));
      } else {
        // If not loaded, just show success
        emit(PaymentsState.paymentRegistered(
          registeredPayment,
          'Pago registrado exitosamente',
        ));
      }
    } catch (e) {
      logger.e('Register payment error: $e');
      emit(PaymentsState.error(e.toString()));
    }
  }

  Future<void> processPayment({
    required String paymentId,
    required double receivedAmount,
    required String method,
    String? notes,
  }) async {
    try {
      emit(const PaymentsState.processing());

      // Find the payment to process
      final currentState = state;
      PaymentModel? paymentToProcess;

      if (currentState is PaymentsPendingLoaded) {
        paymentToProcess =
            currentState.pendingPayments.firstWhere((p) => p.id == paymentId);
      }

      if (paymentToProcess == null) {
        throw Exception('Payment not found');
      }

      // Create processed payment
      final processedPayment = PaymentModel(
        id: paymentToProcess.id,
        customerId: paymentToProcess.customerId,
        orderId: paymentToProcess.orderId,
        userId: paymentToProcess.userId,
        amount: receivedAmount,
        method: method,
        paidAt: DateTime.now(),
        notes: notes,
        status: 'COMPLETED',
        customer: paymentToProcess.customer,
      );

      await _repository.registerPayment(processedPayment);

      emit(PaymentsState.paymentProcessed(
        processedPayment,
        'Pago procesado exitosamente',
      ));

      // Reload pending payments
      await loadPendingPayments();
    } catch (e) {
      logger.e('Process payment error: $e');
      emit(PaymentsState.error(e.toString()));
    }
  }

  Future<void> searchPayments(String query) async {
    try {
      final currentState = state;
      if (currentState is PaymentsLoaded) {
        if (query.isEmpty) {
          // Return to normal loaded state
          return;
        }

        final filteredPayments = currentState.payments.where((payment) {
          final searchFields = [
            payment.customer?.name ?? '',
            payment.method ?? '',
            payment.amount.toString(),
            payment.notes ?? '',
          ];

          return searchFields.any(
              (field) => field.toLowerCase().contains(query.toLowerCase()));
        }).toList();

        emit(PaymentsState.searched(filteredPayments, query));
      }
    } catch (e) {
      logger.e('Search payments error: $e');
    }
  }

  Future<void> filterPaymentsByMethod(String method) async {
    try {
      final currentState = state;
      if (currentState is PaymentsLoaded) {
        final filteredPayments = currentState.payments
            .where((payment) => payment.method == method)
            .toList();

        emit(PaymentsState.filtered(filteredPayments, method));
      }
    } catch (e) {
      logger.e('Filter payments by method error: $e');
    }
  }

  Future<void> filterPaymentsByStatus(String status) async {
    try {
      final currentState = state;
      if (currentState is PaymentsLoaded) {
        final filteredPayments = currentState.payments
            .where((payment) => payment.status == status)
            .toList();

        emit(PaymentsState.filtered(filteredPayments, status));
      }
    } catch (e) {
      logger.e('Filter payments by status error: $e');
    }
  }

  Future<void> filterPaymentsByDateRange({
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      final currentState = state;
      if (currentState is PaymentsLoaded) {
        final filteredPayments = currentState.payments.where((payment) {
          return payment.paidAt.isAfter(startDate) &&
              payment.paidAt.isBefore(endDate.add(const Duration(days: 1)));
        }).toList();

        emit(PaymentsState.filtered(
          filteredPayments,
          '${_formatDate(startDate)} - ${_formatDate(endDate)}',
        ));
      }
    } catch (e) {
      logger.e('Filter payments by date range error: $e');
    }
  }

  void clearFilters() {
    final currentState = state;
    if (currentState is PaymentsFiltered || currentState is PaymentsSearched) {
      // Reload all payments
      loadPayments();
    }
  }

  Future<void> generatePaymentReport({
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      emit(const PaymentsState.generatingReport());

      final currentState = state;
      if (currentState is PaymentsLoaded) {
        // Filter payments by date range
        final payments = currentState.payments.where((payment) {
          return payment.paidAt.isAfter(startDate) &&
              payment.paidAt.isBefore(endDate.add(const Duration(days: 1)));
        }).toList();

        // Calculate report data
        final totalAmount =
            payments.fold<double>(0, (sum, payment) => sum + payment.amount);

        final paymentsByMethod = <String, PaymentMethodSummary>{};
        for (final payment in payments) {
          final method = payment.method ?? 'UNKNOWN';
          if (paymentsByMethod.containsKey(method)) {
            paymentsByMethod[method] = paymentsByMethod[method]!.copyWith(
              count: paymentsByMethod[method]!.count + 1,
              amount: paymentsByMethod[method]!.amount + payment.amount,
            );
          } else {
            paymentsByMethod[method] = PaymentMethodSummary(
              method: method,
              count: 1,
              amount: payment.amount,
            );
          }
        }

        final report = PaymentReport(
          period: '${_formatDate(startDate)} - ${_formatDate(endDate)}',
          totalPayments: payments.length,
          totalAmount: totalAmount,
          averagePayment:
              payments.isNotEmpty ? totalAmount / payments.length : 0,
          paymentsByMethod: paymentsByMethod.values.toList(),
          dailyPayments: _calculateDailyPayments(payments, startDate, endDate),
        );

        emit(PaymentsState.reportGenerated(report));
      }
    } catch (e) {
      logger.e('Generate payment report error: $e');
      emit(PaymentsState.error(e.toString()));
    }
  }

  List<DailyPaymentSummary> _calculateDailyPayments(
    List<PaymentModel> payments,
    DateTime startDate,
    DateTime endDate,
  ) {
    final dailyPayments = <DateTime, DailyPaymentSummary>{};

    // Initialize all days with zero
    DateTime currentDate = startDate;
    while (currentDate.isBefore(endDate.add(const Duration(days: 1)))) {
      final dateKey =
          DateTime(currentDate.year, currentDate.month, currentDate.day);
      dailyPayments[dateKey] = DailyPaymentSummary(
        date: dateKey,
        count: 0,
        amount: 0,
      );
      currentDate = currentDate.add(const Duration(days: 1));
    }

    // Add actual payments
    for (final payment in payments) {
      final dateKey = DateTime(
        payment.paidAt.year,
        payment.paidAt.month,
        payment.paidAt.day,
      );

      if (dailyPayments.containsKey(dateKey)) {
        dailyPayments[dateKey] = dailyPayments[dateKey]!.copyWith(
          count: dailyPayments[dateKey]!.count + 1,
          amount: dailyPayments[dateKey]!.amount + payment.amount,
        );
      }
    }

    return dailyPayments.values.toList()
      ..sort((a, b) => a.date.compareTo(b.date));
  }

  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }
}

@freezed
class PaymentsState with _$PaymentsState {
  const factory PaymentsState.initial() = _Initial;
  const factory PaymentsState.loading() = _Loading;
  const factory PaymentsState.loaded(List<PaymentModel> payments) =
      PaymentsLoaded;
  const factory PaymentsState.pendingLoaded(
      List<PaymentModel> pendingPayments) = PaymentsPendingLoaded;
  const factory PaymentsState.filtered(
      List<PaymentModel> payments, String filter) = PaymentsFiltered;
  const factory PaymentsState.searched(
      List<PaymentModel> payments, String query) = PaymentsSearched;
  const factory PaymentsState.processing() = _Processing;
  const factory PaymentsState.paymentRegistered(
      PaymentModel payment, String message) = _PaymentRegistered;
  const factory PaymentsState.paymentProcessed(
      PaymentModel payment, String message) = _PaymentProcessed;
  const factory PaymentsState.generatingReport() = _GeneratingReport;
  const factory PaymentsState.reportGenerated(PaymentReport report) =
      _ReportGenerated;
  const factory PaymentsState.error(String message) = _Error;
}

@freezed
class PaymentReport with _$PaymentReport {
  const factory PaymentReport({
    required String period,
    required int totalPayments,
    required double totalAmount,
    required double averagePayment,
    required List<PaymentMethodSummary> paymentsByMethod,
    required List<DailyPaymentSummary> dailyPayments,
  }) = _PaymentReport;
}

@freezed
class PaymentMethodSummary with _$PaymentMethodSummary {
  const factory PaymentMethodSummary({
    required String method,
    required int count,
    required double amount,
  }) = _PaymentMethodSummary;
}

@freezed
class DailyPaymentSummary with _$DailyPaymentSummary {
  const factory DailyPaymentSummary({
    required DateTime date,
    required int count,
    required double amount,
  }) = _DailyPaymentSummary;
}


===== lib/features/auth/pages/sign_in_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../core/theme/palette.dart';
import '../bloc/auth_cubit.dart';

class SignInPage extends StatefulWidget {
  const SignInPage({super.key});

  @override
  State<SignInPage> createState() => _SignInPageState();
}

class _SignInPageState extends State<SignInPage> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _obscurePassword = true;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: BlocConsumer<AuthCubit, AuthState>(
        listener: (context, state) {
          state.whenOrNull(
            authenticated: (_) => context.go('/dashboard'),
            error: (message) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(message),
                  backgroundColor: AppPalette.error,
                ),
              );
            },
          );
        },
        builder: (context, state) {
          return SafeArea(
            child: Center(
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(24),
                child: Form(
                  key: _formKey,
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      // Logo
                      Container(
                        width: 120,
                        height: 120,
                        decoration: const BoxDecoration(
                          color: AppPalette.primary,
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(
                          Icons.business_center,
                          size: 60,
                          color: Colors.white,
                        ),
                      ),
                      const SizedBox(height: 32),

                      // Title
                      const Text(
                        'Arsenal Sell App',
                        style: TextStyle(
                          fontSize: 28,
                          fontWeight: FontWeight.bold,
                          color: AppPalette.primary,
                        ),
                      ),
                      const SizedBox(height: 8),
                      const Text(
                        'Control de Fuerza de Ventas',
                        style: TextStyle(
                          fontSize: 16,
                          color: AppPalette.textSecondary,
                        ),
                      ),
                      const SizedBox(height: 48),

                      // Email Field
                      TextFormField(
                        controller: _emailController,
                        keyboardType: TextInputType.emailAddress,
                        decoration: const InputDecoration(
                          labelText: 'Email',
                          prefixIcon: Icon(Icons.email_outlined),
                        ),
                        validator: (value) {
                          if (value?.isEmpty ?? true) {
                            return 'Email es requerido';
                          }
                          if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
                              .hasMatch(value!)) {
                            return 'Email inválido';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),

                      // Password Field
                      TextFormField(
                        controller: _passwordController,
                        obscureText: _obscurePassword,
                        decoration: InputDecoration(
                          labelText: 'Contraseña',
                          prefixIcon: const Icon(Icons.lock_outlined),
                          suffixIcon: IconButton(
                            icon: Icon(
                              _obscurePassword
                                  ? Icons.visibility
                                  : Icons.visibility_off,
                            ),
                            onPressed: () {
                              setState(() {
                                _obscurePassword = !_obscurePassword;
                              });
                            },
                          ),
                        ),
                        validator: (value) {
                          if (value?.isEmpty ?? true) {
                            return 'Contraseña es requerida';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 32),

                      // Sign In Button
                      SizedBox(
                        width: double.infinity,
                        height: 48,
                        child: ElevatedButton(
                          onPressed: state.maybeWhen(
                            loading: () => null,
                            orElse: () => _signIn,
                          ),
                          child: state.maybeWhen(
                            loading: () => const SizedBox(
                              height: 20,
                              width: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                valueColor:
                                    AlwaysStoppedAnimation<Color>(Colors.white),
                              ),
                            ),
                            orElse: () => const Text(
                              'Iniciar Sesión',
                              style: TextStyle(fontSize: 16),
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  void _signIn() {
    if (_formKey.currentState?.validate() ?? false) {
      context.read<AuthCubit>().signIn(
            _emailController.text.trim(),
            _passwordController.text,
          );
    }
  }
}


===== lib/features/auth/bloc/auth_cubit.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../../data/models/auth/user_profile.dart';
import '../../../data/repositories/auth_repository.dart';
import '../../../config/logger.dart';

part 'auth_state.dart';
part 'auth_cubit.freezed.dart';

class AuthCubit extends Cubit<AuthState> {
  final AuthRepository _authRepository;

  AuthCubit(this._authRepository) : super(const AuthState.initial());

  Future<void> checkAuthStatus() async {
    emit(const AuthState.loading());

    try {
      final user = await _authRepository.getCurrentUser();
      if (user != null) {
        emit(AuthState.authenticated(user));
      } else {
        emit(const AuthState.unauthenticated());
      }
    } catch (e) {
      logger.e('Check auth status error: $e');
      emit(AuthState.error(e.toString()));
    }
  }

  Future<void> signIn(String email, String password) async {
    emit(const AuthState.loading());

    try {
      final user = await _authRepository.signIn(email, password);
      if (user != null) {
        emit(AuthState.authenticated(user));
      } else {
        emit(const AuthState.error('Invalid credentials'));
      }
    } catch (e) {
      logger.e('Sign in error: $e');
      emit(AuthState.error(e.toString()));
    }
  }

  Future<void> signOut() async {
    try {
      await _authRepository.signOut();
      emit(const AuthState.unauthenticated());
    } catch (e) {
      logger.e('Sign out error: $e');
      emit(AuthState.error(e.toString()));
    }
  }
}

@freezed
class AuthState with _$AuthState {
  const factory AuthState.initial() = _Initial;
  const factory AuthState.loading() = _Loading;
  const factory AuthState.authenticated(UserProfile user) = _Authenticated;
  const factory AuthState.unauthenticated() = _Unauthenticated;
  const factory AuthState.error(String message) = _Error;
}


===== lib/features/visits/pages/visit_photos_page.dart =====
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../core/theme/palette.dart';
import '../../../services/media/camera_service.dart';
import '../bloc/visits_cubit.dart';

class VisitPhotosPage extends StatefulWidget {
  final String visitId;

  const VisitPhotosPage({
    super.key,
    required this.visitId,
  });

  @override
  State<VisitPhotosPage> createState() => _VisitPhotosPageState();
}

class _VisitPhotosPageState extends State<VisitPhotosPage> {
  final List<File> _capturedPhotos = [];
  bool _isUploading = false;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Evidencia Fotográfica'),
        actions: [
          TextButton(
            onPressed: _capturedPhotos.isNotEmpty
                ? () => context.push('/visit/signature/${widget.visitId}')
                : null,
            child: Text(
              'Siguiente',
              style: TextStyle(
                color:
                    _capturedPhotos.isNotEmpty ? Colors.white : Colors.white54,
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          // Instructions
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(16),
            color: AppPalette.info.withOpacity(0.1),
            child: const Text(
              'Toma fotos como evidencia de tu visita. Mínimo 1 foto requerida.',
              style: TextStyle(
                fontSize: 14,
                color: AppPalette.info,
              ),
              textAlign: TextAlign.center,
            ),
          ),

          // Photo grid
          Expanded(
            child: _capturedPhotos.isEmpty
                ? _buildEmptyState()
                : _buildPhotoGrid(),
          ),

          // Camera buttons
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.white,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.1),
                  blurRadius: 4,
                  offset: const Offset(0, -2),
                ),
              ],
            ),
            child: Row(
              children: [
                Expanded(
                  child: ElevatedButton.icon(
                    onPressed: _isUploading ? null : _takePicture,
                    icon: const Icon(Icons.camera_alt),
                    label: const Text('Tomar Foto'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppPalette.primary,
                    ),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: _isUploading ? null : _pickFromGallery,
                    icon: const Icon(Icons.photo_library),
                    label: const Text('Galería'),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState() {
    return const Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.camera_alt_outlined,
            size: 80,
            color: AppPalette.textSecondary,
          ),
          SizedBox(height: 16),
          Text(
            'No hay fotos capturadas',
            style: TextStyle(
              fontSize: 18,
              color: AppPalette.textSecondary,
            ),
          ),
          SizedBox(height: 8),
          Text(
            'Toma fotos como evidencia de tu visita',
            style: TextStyle(
              fontSize: 14,
              color: AppPalette.textDisabled,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildPhotoGrid() {
    return GridView.builder(
      padding: const EdgeInsets.all(16),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
        crossAxisSpacing: 8,
        mainAxisSpacing: 8,
        childAspectRatio: 1,
      ),
      itemCount: _capturedPhotos.length,
      itemBuilder: (context, index) {
        final photo = _capturedPhotos[index];
        return Stack(
          children: [
            Container(
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(8),
                image: DecorationImage(
                  image: FileImage(photo),
                  fit: BoxFit.cover,
                ),
              ),
            ),
            Positioned(
              top: 4,
              right: 4,
              child: Container(
                decoration: const BoxDecoration(
                  color: Colors.black54,
                  shape: BoxShape.circle,
                ),
                child: IconButton(
                  icon: const Icon(
                    Icons.close,
                    color: Colors.white,
                    size: 20,
                  ),
                  onPressed: () => _removePhoto(index),
                ),
              ),
            ),
            Positioned(
              bottom: 4,
              right: 4,
              child: Container(
                decoration: const BoxDecoration(
                  color: Colors.black54,
                  shape: BoxShape.circle,
                ),
                child: IconButton(
                  icon: const Icon(
                    Icons.fullscreen,
                    color: Colors.white,
                    size: 20,
                  ),
                  onPressed: () => _viewPhoto(photo),
                ),
              ),
            ),
          ],
        );
      },
    );
  }

  Future<void> _takePicture() async {
    try {
      final photo = await CameraService.takePicture();
      if (photo != null) {
        setState(() {
          _capturedPhotos.add(photo);
        });
      }
    } catch (e) {
      _showError('Error al tomar foto: $e');
    }
  }

  Future<void> _pickFromGallery() async {
    try {
      final photos = await CameraService.pickMultipleFromGallery();
      if (photos.isNotEmpty) {
        setState(() {
          _capturedPhotos.addAll(photos);
        });
      }
    } catch (e) {
      _showError('Error al seleccionar fotos: $e');
    }
  }

  void _removePhoto(int index) {
    setState(() {
      _capturedPhotos.removeAt(index);
    });
  }

  void _viewPhoto(File photo) {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => PhotoViewPage(photo: photo),
      ),
    );
  }

  void _showError(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: AppPalette.error,
      ),
    );
  }
}

class PhotoViewPage extends StatelessWidget {
  final File photo;

  const PhotoViewPage({super.key, required this.photo});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.black,
        foregroundColor: Colors.white,
      ),
      body: Container(
        color: Colors.black,
        child: Center(
          child: Image.file(photo),
        ),
      ),
    );
  }
}


===== lib/features/visits/pages/visit_signature_page.dart =====
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:signature/signature.dart';
import '../../../core/theme/palette.dart';
import '../../../services/media/signature_service.dart';
import '../bloc/visits_cubit.dart';

class VisitSignaturePage extends StatefulWidget {
  final String visitId;

  const VisitSignaturePage({
    super.key,
    required this.visitId,
  });

  @override
  State<VisitSignaturePage> createState() => _VisitSignaturePageState();
}

class _VisitSignaturePageState extends State<VisitSignaturePage> {
  late SignatureController _signatureController;
  final _signerNameController = TextEditingController();
  Uint8List? _signatureData;

  @override
  void initState() {
    super.initState();
    _signatureController = SignatureService.createController();
  }

  @override
  void dispose() {
    _signatureController.dispose();
    _signerNameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Firma del Cliente'),
        actions: [
          TextButton(
            onPressed: _signatureData != null ? _finishVisit : null,
            child: Text(
              'Finalizar',
              style: TextStyle(
                color: _signatureData != null ? Colors.white : Colors.white54,
              ),
            ),
          ),
        ],
      ),
      body: BlocConsumer<VisitsCubit, VisitsState>(
        listener: (context, state) {
          state.whenOrNull(
            completed: (visit) {
              context.go('/dashboard');
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('Visita completada exitosamente'),
                  backgroundColor: AppPalette.success,
                ),
              );
            },
            error: (message) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(message),
                  backgroundColor: AppPalette.error,
                ),
              );
            },
          );
        },
        builder: (context, state) {
          return SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Instructions
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: AppPalette.info.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: AppPalette.info.withOpacity(0.3)),
                  ),
                  child: const Text(
                    'Solicita al cliente que firme en el área designada para confirmar la visita.',
                    style: TextStyle(
                      fontSize: 14,
                      color: AppPalette.info,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ),
                const SizedBox(height: 24),

                // Signer name
                const Text(
                  'Nombre del firmante',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _signerNameController,
                  decoration: const InputDecoration(
                    hintText: 'Nombre completo',
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 24),

                // Signature pad
                const Text(
                  'Firma',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 8),
                Container(
                  height: 250,
                  width: double.infinity,
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.grey),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Signature(
                    controller: _signatureController,
                    backgroundColor: Colors.white,
                  ),
                ),
                const SizedBox(height: 16),

                // Signature controls
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton.icon(
                        onPressed: _clearSignature,
                        icon: const Icon(Icons.clear),
                        label: const Text('Limpiar'),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton.icon(
                        onPressed: _captureSignature,
                        icon: const Icon(Icons.check),
                        label: const Text('Capturar'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppPalette.success,
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),

                // Preview signature
                if (_signatureData != null) ...[
                  const Text(
                    'Firma capturada',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Container(
                    height: 150,
                    width: double.infinity,
                    decoration: BoxDecoration(
                      border: Border.all(color: AppPalette.success),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Image.memory(
                      _signatureData!,
                      fit: BoxFit.contain,
                    ),
                  ),
                  const SizedBox(height: 32),
                ],

                // Finish visit button
                SizedBox(
                  width: double.infinity,
                  height: 48,
                  child: ElevatedButton(
                    onPressed: state.maybeWhen(
                      loading: () => null,
                      orElse: () =>
                          _signatureData != null ? _finishVisit : null,
                    ),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppPalette.success,
                    ),
                    child: state.maybeWhen(
                      loading: () => const SizedBox(
                        height: 20,
                        width: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor:
                              AlwaysStoppedAnimation<Color>(Colors.white),
                        ),
                      ),
                      orElse: () => const Text(
                        'Finalizar Visita',
                        style: TextStyle(fontSize: 16),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }

  Future<void> _captureSignature() async {
    try {
      final signatureData =
          await SignatureService.exportSignature(_signatureController);
      if (signatureData != null) {
        setState(() {
          _signatureData = signatureData;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Firma capturada exitosamente'),
            backgroundColor: AppPalette.success,
          ),
        );
      } else {
        _showError('Por favor, dibuja una firma antes de capturar');
      }
    } catch (e) {
      _showError('Error al capturar firma: $e');
    }
  }

  void _clearSignature() {
    _signatureController.clear();
    setState(() {
      _signatureData = null;
    });
  }

  void _finishVisit() {
    if (_signatureData == null) {
      _showError('Firma requerida para finalizar la visita');
      return;
    }

    if (_signerNameController.text.isEmpty) {
      _showError('Nombre del firmante requerido');
      return;
    }

    context.read<VisitsCubit>().finishVisit(
          visitId: widget.visitId,
          notes: 'Firmado por: ${_signerNameController.text}',
        );
  }

  void _showError(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: AppPalette.error,
      ),
    );
  }
}


===== lib/features/visits/pages/visit_checkin_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../core/theme/palette.dart';
import '../../../data/models/customers/customer.dart';
import '../../../data/models/visits/visit.dart';
import '../bloc/visits_cubit.dart';

class VisitCheckinPage extends StatefulWidget {
  final String customerId;
  final String? purpose;

  const VisitCheckinPage({
    super.key,
    required this.customerId,
    this.purpose,
  });

  @override
  State<VisitCheckinPage> createState() => _VisitCheckinPageState();
}

class _VisitCheckinPageState extends State<VisitCheckinPage> {
  final _notesController = TextEditingController();
  VisitPurpose _selectedPurpose = VisitPurpose.visita;
  Customer? _customer;

  @override
  void initState() {
    super.initState();
    _loadCustomer();
    if (widget.purpose != null) {
      _selectedPurpose = _parseVisitPurpose(widget.purpose!);
    }
  }

  @override
  void dispose() {
    _notesController.dispose();
    super.dispose();
  }

  void _loadCustomer() {
    // TODO: Load customer from repository
    _customer = Customer(
      id: widget.customerId,
      companyId: 'company_id',
      name: 'Cliente Ejemplo',
      address: 'Dirección del cliente',
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Iniciar Visita'),
      ),
      body: BlocConsumer<VisitsCubit, VisitsState>(
        listener: (context, state) {
          state.whenOrNull(
            activeVisit: (visit) {
              context.go('/visit/forms/${visit.id}');
            },
            error: (message) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(message),
                  backgroundColor: AppPalette.error,
                ),
              );
            },
          );
        },
        builder: (context, state) {
          if (_customer == null) {
            return const Center(child: CircularProgressIndicator());
          }

          return SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Customer info card
                Card(
                  child: Padding(
                    padding: const EdgeInsets.all(16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          _customer!.name,
                          style: const TextStyle(
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 8),
                        if (_customer!.address != null) ...[
                          Row(
                            children: [
                              const Icon(Icons.location_on, size: 16),
                              const SizedBox(width: 4),
                              Expanded(child: Text(_customer!.address!)),
                            ],
                          ),
                          const SizedBox(height: 4),
                        ],
                        if (_customer!.phone != null) ...[
                          Row(
                            children: [
                              const Icon(Icons.phone, size: 16),
                              const SizedBox(width: 4),
                              Text(_customer!.phone!),
                            ],
                          ),
                        ],
                      ],
                    ),
                  ),
                ),
                const SizedBox(height: 24),

                // Purpose selection
                const Text(
                  'Propósito de la visita',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 8),
                DropdownButtonFormField<VisitPurpose>(
                  value: _selectedPurpose,
                  decoration: const InputDecoration(
                    border: OutlineInputBorder(),
                  ),
                  items: VisitPurpose.values.map((purpose) {
                    return DropdownMenuItem(
                      value: purpose,
                      child: Text(_getVisitPurposeLabel(purpose)),
                    );
                  }).toList(),
                  onChanged: (value) {
                    if (value != null) {
                      setState(() {
                        _selectedPurpose = value;
                      });
                    }
                  },
                ),
                const SizedBox(height: 16),

                // Notes
                const Text(
                  'Notas (opcional)',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _notesController,
                  maxLines: 3,
                  decoration: const InputDecoration(
                    hintText: 'Agregar notas sobre la visita...',
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 32),

                // Start visit button
                SizedBox(
                  width: double.infinity,
                  height: 48,
                  child: ElevatedButton(
                    onPressed: state.maybeWhen(
                      loading: () => null,
                      orElse: () => _startVisit,
                    ),
                    child: state.maybeWhen(
                      loading: () => const SizedBox(
                        height: 20,
                        width: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor:
                              AlwaysStoppedAnimation<Color>(Colors.white),
                        ),
                      ),
                      orElse: () => const Text(
                        'Iniciar Visita',
                        style: TextStyle(fontSize: 16),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }

  void _startVisit() {
    context.read<VisitsCubit>().startVisit(
          customer: _customer!,
          purpose: _selectedPurpose,
          notes:
              _notesController.text.isNotEmpty ? _notesController.text : null,
        );
  }

  VisitPurpose _parseVisitPurpose(String purpose) {
    switch (purpose.toLowerCase()) {
      case 'venta':
        return VisitPurpose.venta;
      case 'cobro':
        return VisitPurpose.cobro;
      case 'entrega':
        return VisitPurpose.entrega;
      case 'auditoria':
        return VisitPurpose.auditoria;
      case 'devolucion':
        return VisitPurpose.devolucion;
      default:
        return VisitPurpose.visita;
    }
  }

  String _getVisitPurposeLabel(VisitPurpose purpose) {
    switch (purpose) {
      case VisitPurpose.venta:
        return 'Venta';
      case VisitPurpose.cobro:
        return 'Cobro';
      case VisitPurpose.entrega:
        return 'Entrega';
      case VisitPurpose.visita:
        return 'Visita General';
      case VisitPurpose.auditoria:
        return 'Auditoría';
      case VisitPurpose.devolucion:
        return 'Devolución';
      case VisitPurpose.otro:
        return 'Otro';
    }
  }
}


===== lib/features/visits/pages/visit_forms_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../core/theme/palette.dart';
import '../bloc/visits_cubit.dart';

class VisitFormsPage extends StatefulWidget {
  final String visitId;

  const VisitFormsPage({
    super.key,
    required this.visitId,
  });

  @override
  State<VisitFormsPage> createState() => _VisitFormsPageState();
}

class _VisitFormsPageState extends State<VisitFormsPage> {
  final _formKey = GlobalKey<FormState>();
  final Map<String, dynamic> _formData = {};

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Formularios de Visita'),
        actions: [
          TextButton(
            onPressed: () => context.push('/visit/photos/${widget.visitId}'),
            child: const Text(
              'Siguiente',
              style: TextStyle(color: Colors.white),
            ),
          ),
        ],
      ),
      body: BlocBuilder<VisitsCubit, VisitsState>(
        builder: (context, state) {
          return state.maybeWhen(
            activeVisit: (visit) =>
                _buildFormContent(visit.customer?.name ?? 'Cliente'),
            orElse: () => const Center(child: CircularProgressIndicator()),
          );
        },
      ),
    );
  }

  Widget _buildFormContent(String customerName) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Form(
        key: _formKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Customer info
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Row(
                  children: [
                    const Icon(Icons.person, color: AppPalette.primary),
                    const SizedBox(width: 8),
                    Text(
                      customerName,
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 24),

            // Dynamic form fields
            _buildFormSection('Información General', [
              _buildTextFormField(
                'observaciones',
                'Observaciones',
                maxLines: 3,
              ),
              _buildDropdownField(
                'estado_cliente',
                'Estado del Cliente',
                ['Activo', 'Inactivo', 'Prospecto', 'Moroso'],
              ),
              _buildSwitchField(
                'acepta_promociones',
                'Acepta promociones',
              ),
            ]),

            _buildFormSection('Información Comercial', [
              _buildTextFormField(
                'ultimo_pedido',
                'Último Pedido',
                keyboardType: TextInputType.datetime,
              ),
              _buildTextFormField(
                'monto_promedio',
                'Monto Promedio',
                keyboardType: TextInputType.number,
                prefix: '\$',
              ),
              _buildDropdownField(
                'frecuencia_compra',
                'Frecuencia de Compra',
                ['Semanal', 'Quincenal', 'Mensual', 'Trimestral'],
              ),
            ]),

            _buildFormSection('Satisfacción', [
              _buildRatingField(
                'satisfaccion_servicio',
                'Satisfacción con el Servicio',
              ),
              _buildRatingField(
                'satisfaccion_productos',
                'Satisfacción con los Productos',
              ),
              _buildTextFormField(
                'sugerencias',
                'Sugerencias',
                maxLines: 2,
              ),
            ]),

            const SizedBox(height: 32),

            // Continue button
            SizedBox(
              width: double.infinity,
              height: 48,
              child: ElevatedButton(
                onPressed: _saveAndContinue,
                child: const Text('Continuar a Fotos'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFormSection(String title, List<Widget> fields) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
            color: AppPalette.primary,
          ),
        ),
        const SizedBox(height: 16),
        ...fields.map((field) => Padding(
              padding: const EdgeInsets.only(bottom: 16),
              child: field,
            )),
        const SizedBox(height: 16),
      ],
    );
  }

  Widget _buildTextFormField(
    String key,
    String label, {
    TextInputType? keyboardType,
    int maxLines = 1,
    String? prefix,
  }) {
    return TextFormField(
      keyboardType: keyboardType,
      maxLines: maxLines,
      decoration: InputDecoration(
        labelText: label,
        prefixText: prefix,
        border: const OutlineInputBorder(),
      ),
      onSaved: (value) => _formData[key] = value,
    );
  }

  Widget _buildDropdownField(String key, String label, List<String> options) {
    return DropdownButtonFormField<String>(
      decoration: InputDecoration(
        labelText: label,
        border: const OutlineInputBorder(),
      ),
      items: options
          .map((option) => DropdownMenuItem(
                value: option,
                child: Text(option),
              ))
          .toList(),
      onChanged: (value) => _formData[key] = value,
    );
  }

  Widget _buildSwitchField(String key, String label) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(label),
        Switch(
          value: _formData[key] ?? false,
          onChanged: (value) {
            setState(() {
              _formData[key] = value;
            });
          },
        ),
      ],
    );
  }

  Widget _buildRatingField(String key, String label) {
    final rating = _formData[key] ?? 0;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label),
        const SizedBox(height: 8),
        Row(
          children: List.generate(5, (index) {
            return GestureDetector(
              onTap: () {
                setState(() {
                  _formData[key] = index + 1;
                });
              },
              child: Icon(
                index < rating ? Icons.star : Icons.star_border,
                color: AppPalette.warning,
                size: 32,
              ),
            );
          }),
        ),
      ],
    );
  }

  void _saveAndContinue() {
    if (_formKey.currentState?.validate() ?? false) {
      _formKey.currentState?.save();
      // TODO: Save form data
      context.push('/visit/photos/${widget.visitId}');
    }
  }

  VisitPurpose _parseVisitPurpose(String purpose) {
    switch (purpose.toLowerCase()) {
      case 'venta':
        return VisitPurpose.venta;
      case 'cobro':
        return VisitPurpose.cobro;
      case 'entrega':
        return VisitPurpose.entrega;
      case 'auditoria':
        return VisitPurpose.auditoria;
      case 'devolucion':
        return VisitPurpose.devolucion;
      default:
        return VisitPurpose.visita;
    }
  }
}


===== lib/features/visits/bloc/visits_cubit.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:geolocator/geolocator.dart';
import '../../../data/models/visits/visit.dart';
import '../../../data/models/customers/customer.dart';
import '../../../data/repositories/visits_repository.dart';
import '../../../services/location/location_service.dart';
import '../../../config/logger.dart';
import '../../../config/app_constants.dart';

part 'visits_state.dart';
part 'visits_cubit.freezed.dart';

class VisitsCubit extends Cubit<VisitsState> {
  final VisitsRepository _repository;
  final LocationService _locationService;

  VisitsCubit(this._repository, this._locationService)
      : super(const VisitsState.initial());

  Future<void> startVisit({
    required Customer customer,
    required VisitPurpose purpose,
    String? notes,
  }) async {
    emit(const VisitsState.loading());

    try {
      final position = await _locationService.getCurrentLocation();
      if (position == null) {
        emit(const VisitsState.error('No se pudo obtener la ubicación actual'));
        return;
      }

      // Validate geofence
      if (customer.latitude != null && customer.longitude != null) {
        final distance = _locationService.calculateDistance(
          position.latitude,
          position.longitude,
          customer.latitude!,
          customer.longitude!,
        );

        if (distance > AppConstants.defaultGeofenceRadius) {
          emit(VisitsState.error(
              'Estás a ${distance.toStringAsFixed(1)}m del cliente. '
              'Debes estar dentro de ${AppConstants.defaultGeofenceRadius.toInt()}m para iniciar la visita.'));
          return;
        }
      }

      final visit = Visit(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        companyId: customer.companyId,
        customerId: customer.id,
        purpose: purpose,
        startedAt: DateTime.now(),
        checkinLatitude: position.latitude,
        checkinLongitude: position.longitude,
        checkinAccuracyM: position.accuracy,
        notes: notes,
        customer: customer,
      );

      final createdVisit = await _repository.startVisit(visit);
      emit(VisitsState.activeVisit(createdVisit));
    } catch (e) {
      logger.e('Start visit error: $e');
      emit(VisitsState.error(e.toString()));
    }
  }

  Future<void> finishVisit({
    required String visitId,
    String? notes,
  }) async {
    try {
      final currentState = state;
      if (currentState is VisitsActiveVisit) {
        final position = await _locationService.getCurrentLocation();

        final updatedVisit = currentState.visit.copyWith(
          finishedAt: DateTime.now(),
          checkoutLatitude: position?.latitude,
          checkoutLongitude: position?.longitude,
          checkoutAccuracyM: position?.accuracy,
          notes: notes ?? currentState.visit.notes,
        );

        await _repository.finishVisit(updatedVisit);
        emit(VisitsState.completed(updatedVisit));
      }
    } catch (e) {
      logger.e('Finish visit error: $e');
      emit(VisitsState.error(e.toString()));
    }
  }

  Future<void> loadVisitHistory(String customerId) async {
    emit(const VisitsState.loading());

    try {
      final visits = await _repository.getVisitsByCustomer(customerId);
      emit(VisitsState.history(visits));
    } catch (e) {
      logger.e('Load visit history error: $e');
      emit(VisitsState.error(e.toString()));
    }
  }

  void resetState() {
    emit(const VisitsState.initial());
  }
}

@freezed
class VisitsState with _$VisitsState {
  const factory VisitsState.initial() = _Initial;
  const factory VisitsState.loading() = _Loading;
  const factory VisitsState.activeVisit(Visit visit) = VisitsActiveVisit;
  const factory VisitsState.completed(Visit visit) = _Completed;
  const factory VisitsState.history(List<Visit> visits) = _History;
  const factory VisitsState.error(String message) = _Error;
}


===== lib/features/map/pages/live_map_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import '../../../core/theme/palette.dart';
import '../../../data/models/customers/customer.dart';
import '../bloc/map_cubit.dart';
import '../widgets/customer_marker.dart';

class LiveMapPage extends StatefulWidget {
  const LiveMapPage({super.key});

  @override
  State<LiveMapPage> createState() => _LiveMapPageState();
}

class _LiveMapPageState extends State<LiveMapPage> {
  GoogleMapController? _controller;
  Set<Marker> _markers = {};

  @override
  void initState() {
    super.initState();
    context.read<MapCubit>().initializeMap();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Mapa en Vivo'),
        actions: [
          IconButton(
            icon: const Icon(Icons.my_location),
            onPressed: _centerOnCurrentLocation,
          ),
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () => context.read<MapCubit>().initializeMap(),
          ),
        ],
      ),
      body: BlocConsumer<MapCubit, MapState>(
        listener: (context, state) {
          state.whenOrNull(
            error: (message) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(message),
                  backgroundColor: AppPalette.error,
                ),
              );
            },
          );
        },
        builder: (context, state) {
          return state.when(
            initial: () => const Center(child: Text('Inicializando...')),
            loading: () => const Center(child: CircularProgressIndicator()),
            ready: (currentPosition, customers, teamLocations) {
              _updateMarkers(currentPosition, customers, teamLocations);

              return GoogleMap(
                onMapCreated: (GoogleMapController controller) {
                  _controller = controller;
                  context.read<MapCubit>().setMapController(controller);
                },
                initialCameraPosition: CameraPosition(
                  target: currentPosition,
                  zoom: 15.0,
                ),
                markers: _markers,
                myLocationEnabled: true,
                myLocationButtonEnabled: false,
                zoomControlsEnabled: false,
                mapToolbarEnabled: false,
              );
            },
            error: (message) => Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.error_outline,
                    size: 64,
                    color: AppPalette.error,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    message,
                    textAlign: TextAlign.center,
                    style: const TextStyle(fontSize: 16),
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () => context.read<MapCubit>().initializeMap(),
                    child: const Text('Reintentar'),
                  ),
                ],
              ),
            ),
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // Navigate to customer selection for visit
        },
        child: const Icon(Icons.add_location),
      ),
    );
  }

  void _updateMarkers(
    LatLng currentPosition,
    List<Customer> customers,
    List<dynamic> teamLocations,
  ) {
    final markers = <Marker>{};

    // Customer markers
    for (final customer in customers) {
      if (customer.latitude != null && customer.longitude != null) {
        markers.add(
          Marker(
            markerId: MarkerId('customer_${customer.id}'),
            position: LatLng(customer.latitude!, customer.longitude!),
            icon:
                BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueBlue),
            infoWindow: InfoWindow(
              title: customer.name,
              snippet: customer.address,
            ),
            onTap: () => _onCustomerMarkerTap(customer),
          ),
        );
      }
    }

    setState(() {
      _markers = markers;
    });
  }

  void _onCustomerMarkerTap(Customer customer) {
    showModalBottomSheet(
      context: context,
      builder: (context) => CustomerBottomSheet(customer: customer),
    );
  }

  void _centerOnCurrentLocation() {
    final state = context.read<MapCubit>().state;
    if (state is MapReady && _controller != null) {
      _controller!.animateCamera(
        CameraUpdate.newLatLng(state.currentPosition),
      );
    }
  }
}

class CustomerBottomSheet extends StatelessWidget {
  final Customer customer;

  const CustomerBottomSheet({
    super.key,
    required this.customer,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            customer.name,
            style: const TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          if (customer.address != null) ...[
            Row(
              children: [
                const Icon(Icons.location_on, size: 16),
                const SizedBox(width: 4),
                Expanded(child: Text(customer.address!)),
              ],
            ),
            const SizedBox(height: 4),
          ],
          if (customer.phone != null) ...[
            Row(
              children: [
                const Icon(Icons.phone, size: 16),
                const SizedBox(width: 4),
                Text(customer.phone!),
              ],
            ),
            const SizedBox(height: 16),
          ],

          // Action buttons
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _ActionButton(
                icon: Icons.visibility,
                label: 'Visita',
                color: AppPalette.info,
                onTap: () => _startVisit(context, VisitPurpose.visita),
              ),
              _ActionButton(
                icon: Icons.shopping_cart,
                label: 'Venta',
                color: AppPalette.success,
                onTap: () => _startVisit(context, VisitPurpose.venta),
              ),
              _ActionButton(
                icon: Icons.payment,
                label: 'Cobro',
                color: AppPalette.warning,
                onTap: () => _startVisit(context, VisitPurpose.cobro),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void _startVisit(BuildContext context, VisitPurpose purpose) {
    Navigator.of(context).pop();
    context.push('/visit/checkin/${customer.id}?purpose=${purpose.name}');
  }
}

class _ActionButton extends StatelessWidget {
  final IconData icon;
  final String label;
  final Color color;
  final VoidCallback onTap;

  const _ActionButton({
    required this.icon,
    required this.label,
    required this.color,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: color),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: color, size: 24),
            const SizedBox(height: 4),
            Text(
              label,
              style: TextStyle(
                color: color,
                fontSize: 12,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===== lib/features/map/widgets/route_layer.dart =====
import 'dart:async';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import '../../../data/models/routes/route_plan.dart';
import '../../../data/models/customers/customer.dart';
import '../../../core/theme/palette.dart';
import '../../../core/utils/geoutils.dart';

class RouteLayerService {
  /// Create polylines for a route plan
  static Set<Polyline> createRoutePolylines({
    required RoutePlan routePlan,
    Color? routeColor,
  }) {
    final polylines = <Polyline>{};

    if (routePlan.stops.length < 2) return polylines;

    // Sort stops by sequence
    final sortedStops = List<RouteStop>.from(routePlan.stops)
      ..sort((a, b) => (a.sequence ?? 0).compareTo(b.sequence ?? 0));

    final routePoints = <LatLng>[];

    for (final stop in sortedStops) {
      if (stop.customer?.latitude != null && stop.customer?.longitude != null) {
        routePoints.add(LatLng(
          stop.customer!.latitude!,
          stop.customer!.longitude!,
        ));
      }
    }

    if (routePoints.length < 2) return polylines;

    // Main route polyline
    polylines.add(Polyline(
      polylineId: PolylineId('route_${routePlan.id}'),
      points: routePoints,
      color: routeColor ?? AppPalette.primary,
      width: 4,
      patterns: [PatternItem.solid],
    ));

    // Add segment polylines with different colors for completed/pending
    for (int i = 0; i < routePoints.length - 1; i++) {
      final segment = [routePoints[i], routePoints[i + 1]];
      final stop = sortedStops[i];

      // Determine segment color based on visit completion
      Color segmentColor = AppPalette.textSecondary; // Default: not visited

      if (stop.customer != null) {
        // TODO: Check if this stop has been visited
        // For now, use different logic
        segmentColor = AppPalette.primary;
      }

      polylines.add(Polyline(
        polylineId: PolylineId('segment_${routePlan.id}_$i'),
        points: segment,
        color: segmentColor,
        width: 3,
        patterns: [PatternItem.solid],
      ));
    }

    return polylines;
  }

  /// Create markers for route stops
  static Future<Set<Marker>> createRouteStopMarkers({
    required List<RouteStop> stops,
    required Function(RouteStop) onStopTap,
  }) async {
    final markers = <Marker>{};

    for (int i = 0; i < stops.length; i++) {
      final stop = stops[i];

      if (stop.customer?.latitude == null || stop.customer?.longitude == null) {
        continue;
      }

      final marker = await _createRouteStopMarker(
        stop: stop,
        sequence: i + 1,
        onTap: () => onStopTap(stop),
      );

      markers.add(marker);
    }

    return markers;
  }

  /// Create a single route stop marker
  static Future<Marker> _createRouteStopMarker({
    required RouteStop stop,
    required int sequence,
    required VoidCallback onTap,
  }) async {
    final icon = await _createSequenceIcon(
      sequence: sequence,
      isCompleted: false, // TODO: Check if stop is completed
      isPending: true,
    );

    return Marker(
      markerId: MarkerId('route_stop_${stop.id}'),
      position: LatLng(
        stop.customer!.latitude!,
        stop.customer!.longitude!,
      ),
      icon: icon,
      infoWindow: InfoWindow(
        title: '${sequence}. ${stop.customer?.name ?? 'Cliente'}',
        snippet: stop.plannedTime != null
            ? 'Programado: ${_formatTime(stop.plannedTime!)}'
            : 'Sin horario programado',
        onTap: onTap,
      ),
      onTap: onTap,
    );
  }

  /// Create navigation polyline between two points
  static Future<Polyline?> createNavigationPolyline({
    required LatLng origin,
    required LatLng destination,
    Color? color,
  }) async {
    try {
      // In a real implementation, you would use Google Directions API
      // For now, create a simple straight line
      final points = [origin, destination];

      return Polyline(
        polylineId: const PolylineId('navigation'),
        points: points,
        color: color ?? AppPalette.info,
        width: 5,
        patterns: [
          PatternItem.dash(20),
          PatternItem.gap(10),
        ],
      );
    } catch (e) {
      return null;
    }
  }

  /// Create optimized route polylines
  static Set<Polyline> createOptimizedRoute({
    required List<LatLng> waypoints,
    required LatLng currentLocation,
    Color? routeColor,
  }) {
    final polylines = <Polyline>{};

    if (waypoints.isEmpty) return polylines;

    // Simple optimization: nearest neighbor
    final optimizedWaypoints = _optimizeRoute(currentLocation, waypoints);

    // Add current location as starting point
    final allPoints = [currentLocation, ...optimizedWaypoints];

    polylines.add(Polyline(
      polylineId: const PolylineId('optimized_route'),
      points: allPoints,
      color: routeColor ?? AppPalette.success,
      width: 4,
      patterns: [PatternItem.solid],
    ));

    return polylines;
  }

  /// Simple route optimization using nearest neighbor algorithm
  static List<LatLng> _optimizeRoute(LatLng start, List<LatLng> waypoints) {
    final unvisited = List<LatLng>.from(waypoints);
    final optimized = <LatLng>[];
    LatLng current = start;

    while (unvisited.isNotEmpty) {
      double minDistance = double.infinity;
      int nearestIndex = 0;

      for (int i = 0; i < unvisited.length; i++) {
        final distance = GeoUtils.calculateDistance(
          current.latitude,
          current.longitude,
          unvisited[i].latitude,
          unvisited[i].longitude,
        );

        if (distance < minDistance) {
          minDistance = distance;
          nearestIndex = i;
        }
      }

      current = unvisited.removeAt(nearestIndex);
      optimized.add(current);
    }

    return optimized;
  }

  /// Create sequence number icon for route stops
  static Future<BitmapDescriptor> _createSequenceIcon({
    required int sequence,
    required bool isCompleted,
    required bool isPending,
  }) async {
    const size = 48.0;
    final pictureRecorder = ui.PictureRecorder();
    final canvas = Canvas(pictureRecorder);

    Color backgroundColor;
    Color textColor = Colors.white;

    if (isCompleted) {
      backgroundColor = AppPalette.success;
    } else if (isPending) {
      backgroundColor = AppPalette.warning;
    } else {
      backgroundColor = AppPalette.textSecondary;
    }

    // Draw background circle
    final backgroundPaint = Paint()
      ..color = backgroundColor
      ..style = PaintingStyle.fill;

    final borderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3;

    final center = Offset(size / 2, size / 2);
    final radius = size / 2 - 2;

    canvas.drawCircle(center, radius, backgroundPaint);
    canvas.drawCircle(center, radius, borderPaint);

    // Draw sequence number
    final textPainter = TextPainter(textDirection: ui.TextDirection.ltr);
    textPainter.text = TextSpan(
      text: sequence.toString(),
      style: TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.bold,
        color: textColor,
      ),
    );

    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        (size - textPainter.width) / 2,
        (size - textPainter.height) / 2,
      ),
    );

    final picture = pictureRecorder.endRecording();
    final image = await picture.toImage(size.toInt(), size.toInt());
    final bytes = await image.toByteData(format: ui.ImageByteFormat.png);

    return BitmapDescriptor.fromBytes(bytes!.buffer.asUint8List());
  }

  /// Calculate route statistics
  static RouteStatistics calculateRouteStatistics({
    required List<RouteStop> stops,
    LatLng? currentLocation,
  }) {
    if (stops.isEmpty) {
      return const RouteStatistics(
        totalDistance: 0,
        estimatedDuration: Duration.zero,
        completedStops: 0,
        pendingStops: 0,
      );
    }

    final validStops = stops
        .where((stop) =>
            stop.customer?.latitude != null && stop.customer?.longitude != null)
        .toList();

    if (validStops.isEmpty) {
      return const RouteStatistics(
        totalDistance: 0,
        estimatedDuration: Duration.zero,
        completedStops: 0,
        pendingStops: validStops.length,
      );
    }

    double totalDistance = 0;
    int completedStops = 0;
    int pendingStops = validStops.length;

    // Calculate distances between consecutive stops
    LatLng? previousPoint = currentLocation;

    for (final stop in validStops) {
      final stopLocation = LatLng(
        stop.customer!.latitude!,
        stop.customer!.longitude!,
      );

      if (previousPoint != null) {
        totalDistance += GeoUtils.calculateDistance(
          previousPoint.latitude,
          previousPoint.longitude,
          stopLocation.latitude,
          stopLocation.longitude,
        );
      }

      previousPoint = stopLocation;

      // TODO: Check if stop is completed
      // For now, assume all are pending
    }

    // Estimate duration (average 30 km/h + 15 minutes per stop)
    final travelTime =
        Duration(milliseconds: (totalDistance / 30000 * 3600 * 1000).round());
    final stopTime = Duration(minutes: validStops.length * 15);
    final estimatedDuration = travelTime + stopTime;

    return RouteStatistics(
      totalDistance: totalDistance,
      estimatedDuration: estimatedDuration,
      completedStops: completedStops,
      pendingStops: pendingStops,
    );
  }

  /// Create route bounds that include all stops
  static LatLngBounds? createRouteBounds(List<RouteStop> stops) {
    final validLocations = stops
        .where((stop) =>
            stop.customer?.latitude != null && stop.customer?.longitude != null)
        .map((stop) =>
            LatLng(stop.customer!.latitude!, stop.customer!.longitude!))
        .toList();

    if (validLocations.isEmpty) return null;

    return GeoUtils.getBounds(validLocations);
  }

  /// Format time for display
  static String _formatTime(DateTime dateTime) {
    return '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }
}

class RouteStatistics {
  final double totalDistance; // in meters
  final Duration estimatedDuration;
  final int completedStops;
  final int pendingStops;

  const RouteStatistics({
    required this.totalDistance,
    required this.estimatedDuration,
    required this.completedStops,
    required this.pendingStops,
  });

  String get formattedDistance {
    if (totalDistance < 1000) {
      return '${totalDistance.toStringAsFixed(0)} m';
    } else {
      return '${(totalDistance / 1000).toStringAsFixed(1)} km';
    }
  }

  String get formattedDuration {
    final hours = estimatedDuration.inHours;
    final minutes = estimatedDuration.inMinutes % 60;

    if (hours > 0) {
      return '${hours}h ${minutes}m';
    } else {
      return '${minutes}m';
    }
  }

  int get totalStops => completedStops + pendingStops;

  double get completionPercentage {
    if (totalStops == 0) return 0;
    return (completedStops / totalStops) * 100;
  }
}

// Helper widget for route information display
class RouteInfoWidget extends StatelessWidget {
  final RouteStatistics statistics;
  final VoidCallback? onOptimize;
  final VoidCallback? onStartNavigation;

  const RouteInfoWidget({
    super.key,
    required this.statistics,
    this.onOptimize,
    this.onStartNavigation,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Información de Ruta',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                if (onOptimize != null)
                  TextButton.icon(
                    onPressed: onOptimize,
                    icon: const Icon(Icons.route),
                    label: const Text('Optimizar'),
                  ),
              ],
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: _buildStatItem(
                    'Distancia',
                    statistics.formattedDistance,
                    Icons.straighten,
                  ),
                ),
                Expanded(
                  child: _buildStatItem